<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>置顶◇代办◇与更新记录</title>
    <url>/Archive/The-First-Blog/</url>
    <content><![CDATA[<p>欢迎光临willkyu的Blog，这是第一次使用博客的方式记录东西，希望能坚持下去！
此博客基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo<i class="fa fa-external-link-alt"></i></span> 打造，主题使用的是 <a
href="https://theme-next.js.org/">NexT</a>.</p>
<p>当你在阅读的时候有任何的问题,欢迎与我联系.</p>
<p>封面 [ID:85357809].</p>
<span id="more"></span>
<h1 id="about-willkyu-and-this-blog">About willkyu and This Blog</h1>
<p>一只不务正业的谜拟Q 与其创建的不务正业的Blog.</p>
<p>更多 <em>关于</em> 请参见 <a href="/about/">About 页面</a>.</p>
<p><br></p>
<hr />
<p><br></p>
<h1 id="archives">Archives</h1>
<ul>
<li><a href="/Archive/1-Pokemon/">宝可梦◇熵增定律◇与死亡誓言</a></li>
<li><a href="/Archive/1-Learning/">学习◇生存博弈◇与纯利他主义</a></li>
<li><a href="/Archive/1-Game/">游戏◇动机判定◇与去悲剧化</a></li>
<li><a href="/Archive/1-Life/">生活◇奥康剃刀◇与自由意识</a></li>
<li><a href="/Archive/1-Collection/">收藏◇知觉丧失◇与不完备定理</a></li>
<li><a href="/Archive/1-TRPG/">跑团◇量子骰子◇与观察者效应</a></li>
</ul>
<p><br></p>
<hr />
<p><br></p>
<h1 id="to-do-list">To-do list</h1>
<p>下面是一些之后的计划,用小标题表示,具体的进度会随时更新在下面.</p>
<h2 id="记录与分享生活">记录与分享生活</h2>
<ul>
<li>2021-12-04 创建<a
href="/Pokemon/See-My-Loving-Pokemons/">亲爱的宝可梦♡</a>页面.</li>
<li>2021-12-05 创建<a
href="/Game/Share-Splatoon2-Happiness/">快乐的喷喷生活</a>页面.</li>
<li>2021-12-06 创建<a href="/Pokemon/VS-Recorder/">VS.
Recorder</a>页面.</li>
<li>2022-01-07 创建<a
href="/Game/Undercover-Brella-Diary">间谍伞日记</a>页面.</li>
<li>2022-07-03 创建<a href="/Life/Zheng-with-his-five-dads">Zheng. w/
his five DADs</a>页面.</li>
</ul>
<p>AnyTime.</p>
<h2
id="整理一些宝可梦系列相关的知识等包含游戏内知识与游戏外知识">整理一些宝可梦系列相关的知识等，包含游戏内知识与游戏外知识</h2>
<ul>
<li>2021-12-03 创建<a href="/Archive/1-Pokemon/">宝可梦攻略整理</a>页面.
<ul>
<li>2021-12-13 已合并至宝可梦归档页面：<a
href="/Archive/1-Pokemon/">宝可梦◇熵增定律◇与死亡誓言</a>.</li>
</ul></li>
<li>2021-12-04 完成文章<a
href="/Pokemon/Strategies/In-Game/How-To-Back-Up-Your-Savefiles">如何备份你的存档</a>页面.</li>
<li>2021-12-07 完成文章<a
href="/Pokemon/Strategies/Out-Game/Pokemon-Cartridges-Authenticate/">宝可梦卡带鉴别</a>.</li>
<li>2021-12-16 完成文章<a
href="/Pokemon/Strategies/In-Game/WCD-Distribution-Patch/">如何自制宝可梦Gen4与Gen5的配信器</a>.</li>
<li>2022-01-03 完成文章<a
href="/Pokemon/Strategies/In-Game/Battle-Pyramid-Shiny/">战斗金字塔刷闪教程</a>.</li>
<li>2022-05-24 完成文章<a
href="/Pokemon/Shiny-Lock/">锁闪宝可梦汇总</a></li>
</ul>
<p>No Hurry. 准备从自己b站专栏搬一点先.</p>
<h2
id="整理一下宝可梦各时代的乱数方法">整理一下宝可梦各时代的乱数方法</h2>
<ul>
<li>第三世代(RSE)
<ul>
<li>2021-12-03 完成文章<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part1/">宝可梦绿宝石及没有电的红蓝宝石实机乱数（不包含
ID 或 Egg）</a>.</li>
<li>2021-12-14 完成文章<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part2/">宝可梦有电的红蓝宝石实机乱数（不包含
ID 或 Egg）</a>.</li>
<li>2021-12-24 完成文章<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part3/">宝可梦火红叶绿实机乱数（不包含
ID 或 Egg）</a>.</li>
</ul></li>
<li>第四世代(DPPt HgSs)
<ul>
<li>2022-01-14 完成文章<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen4">宝可梦四代实机乱数</a>.</li>
</ul></li>
<li>第五世代(BW BW2)</li>
<li>第六世代(XY OrAs)
<ul>
<li>2022-01-15 完成文章<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen6">宝可梦六代实机乱数（破解机插件辅助
&amp; 不包含蛋）</a>.</li>
</ul></li>
<li>第七世代(SM UsUm)</li>
</ul>
<h2 id="整理一下搭建博客的方法">整理一下搭建博客的方法</h2>
<ul>
<li>2021-12-02 完成了文章<a
href="/Learning/Blog/Build-Your-Own-Blog-Like-This-One/">基于Hexo与GitHub制作私人博客</a>.</li>
<li>2021-12-19 完成文章<a
href="/Learning/Blog/Blog-Personalization/">博客个性化笔记----基于Ocean</a></li>
</ul>
<h2 id="给博客加上评论等功能">给博客加上评论等功能</h2>
<ul>
<li>2021-12-06 想鸽了.</li>
<li>2021-12-13 思考必要性.</li>
<li>2021-12-17 实现Gitalk评论功能，使用GitHub账号登陆，支持MarkDown语法.
此外新增指定post开启评论功能.
<strong><em>请不要发布无意义的评论</em></strong>
当你在某篇文章下评论后，如果有其他人跟帖，你也会收到GitHub邮件提醒.
如果想要取消，请前去<a
href="https://github.com/willkyu/Hexo-Gitalk/issues">Issues</a>中找到对应<strong>Issue</strong>，进入后选择右侧栏的取消订阅
<em>Unsubscribe</em> 即可.</li>
</ul>
<h2 id="完善博客相册已废弃">完善博客相册（已废弃）</h2>
<ul>
<li>2021-12-02 添加了3张生活照.</li>
<li>宝可梦相关的照片请见：<a
href="/Pokemon/See-My-Loving-Pokemons/">亲爱的宝可梦♡</a>页面.</li>
<li>喷喷相关的照片请见：<a
href="/Game/Share-Splatoon2-Happiness/">快乐的喷喷生活</a>页面.</li>
<li>2021-12-19 拍的好看照片太少了555，也许应该多出去走走.</li>
</ul>
<p>No Hurry.</p>
<h2 id="学习记录">学习记录</h2>
<ul>
<li>请参考<a
href="/Archive/1-Learning/">学习◇生存博弈◇与纯利他主义</a>页面.</li>
<li>2021-12-17 思考是否要将笔记转移至GitHub仓库.</li>
</ul>
<h2 id="个性化博客">个性化博客</h2>
<ul>
<li>2021-12-01 更新了首页视频为 <strong>《GOTCHA》</strong> 片段.</li>
<li>2021-12-02 开启Gallery功能.</li>
<li>2021-12-02 新增Favorites页面.</li>
<li>2021-12-02 更新了谜拟Q的icon.</li>
<li>2021-12-04 背景添加动态线条效果.</li>
<li>2021-12-04 添加了点击特效.</li>
<li>2021-12-05 更新了点击特效的颜色，使其更贴合博客风格.
试试长按再松开~</li>
<li>2021-12-06 新增博客隐藏功能.</li>
<li>2021-12-13 加入大分类页(<a
href="/Archive/1-Pokemon/">宝可梦◇熵增定律◇与死亡誓言</a>、<a
href="/Archive/1-Learning/">学习◇生存博弈◇与纯利他主义</a>、<a
href="/Archive/1-Game/">游戏◇动机判定◇与去悲剧化</a>、<a
href="/Archive/1-Life/">生活◇奥康剃刀◇与自由意识</a>、<a
href="/Archive/1-Collection/">收藏◇知觉丧失◇与不完备定理</a>)以归档所有博客并置顶.
使博客更加美观简洁，提高易读性.</li>
<li>2021-12-15 修改了博客结构，使得博客分类更加直观.</li>
<li>2021-12-15 实现背景动态线条的随机颜色效果.</li>
<li>2021-12-16
更新了博客的一些细节，修复了Category页面无法正确显示标题的错误.</li>
<li>2021-12-17 实现博客评论功能，详见<a
href="#给博客加上评论等功能">本页面对应部分</a>.</li>
<li>2021-12-18 实现图片懒加载.</li>
<li>2021-12-19 加入了<a
href="https://github.com/HFIProgramming/mikutap">Mikutap</a>，点击<a
href="/mikutap/">这里</a>进行游玩.</li>
<li>2021-12-20 新增博客加密功能.</li>
<li>2022-01-01 优化博客细节.</li>
<li><strong><em>2022-01-19 更改博客主题为NexT.</em></strong></li>
<li>2022-01-19 引入Gitter聊天室，快来聊天室聊天8！</li>
<li>2022-01-30 重新修改404页面，化繁为简:D.</li>
<li>2022-02-08 优化博客内容，修复了一些因换主题带来的显示bug.</li>
<li>2022-05-16 优化博客排版.</li>
<li>2024-02-17 加入大分类页<a
href="/Archive/1-TRPG/">跑团◇量子骰子◇与观察者效应</a>.</li>
</ul>
<p>No Hurry.</p>
<p><br></p>
<hr />
<p><br></p>
<h1 id="test">Test</h1>
<ul>
<li>点击<a
href="/ZONE/WeiChenDemo/index.html">这里</a>来访问卧看小工具测试页.
成品：<a
href="https://wokann.github.io/Tool/GEN3_Mirage_island/index.html">3代幻之岛计算器</a>.</li>
<li>点击<a href="/404/">这里</a>来访问404页面.</li>
</ul>
<p><br></p>
<hr />
<p><br></p>
<h1 id="something-else">Something else</h1>
<p>本博客中未说明来源的封面可能是忘记了来源,还请见谅.
如有侵权请与我联系!</p>
]]></content>
      <categories>
        <category>Archive</category>
      </categories>
      <tags>
        <tag>Archive</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>跑团◇量子骰子◇与观察者效应</title>
    <url>/Archive/1-TRPG/</url>
    <content><![CDATA[<blockquote>
<p>毕宿星的歌无人听晓，国王的褴衣随风飘摇，歌声默默地消逝在那，昏暗的卡尔克萨。</p>
<p>我的灵魂已无法歌唱，我的歌像泪不再流淌，只有干涸和沉默在那，失落的卡尔克萨。</p>
<p>降临吧！我们衣衫褴褛的王。</p>
</blockquote>
<p>封面 [ID:98137168].</p>
<span id="more"></span>
<h1 id="preface">Preface</h1>
<blockquote>
<p>那是你少年时所见与所爱的一切的总和，</p>
<p>它是那些奇迹凝聚而成的永恒宝石，</p>
<p>它的光芒将会照亮你夜晚的道路。</p>
</blockquote>
<p><br></p>
<hr />
<p><br></p>
<h1 id="mods">Mods</h1>
<ul>
<li><a
href="/TRPG/Mods/Third-Spiral-Grey-Sea/">《第三螺旋：灰海》</a></li>
</ul>
<p><br></p>
<hr />
<p><br></p>
<h1 id="tools">Tools</h1>
<ul>
<li><a href="/TRPG/Tools/UTLov/">UTLov for OlivOS |
像看replay一样跑团</a></li>
</ul>
]]></content>
      <categories>
        <category>TRPG</category>
      </categories>
      <tags>
        <tag>Archive</tag>
        <tag>TRPG</tag>
      </tags>
  </entry>
  <entry>
    <title>学习◇生存博弈◇与纯利他主义</title>
    <url>/Archive/1-Learning/</url>
    <content><![CDATA[<blockquote>
<p>就算没达到预期的水平也不能放弃，继续锻炼.</p>
<p>不管什么时候，</p>
<p>改变世界的都是认真追求梦想的人. --------
<strong><em>阿戴克</em></strong></p>
</blockquote>
<p>封面 [ID:90778756].</p>
<span id="more"></span>
<h1 id="learning">Learning</h1>
<p>记录与整理学习上的一些要点或者问题.</p>
<h2 id="notes">Notes</h2>
<h3 id="pytorch">PyTorch</h3>
<ul>
<li><a
href="/Learning/Notes/PyTorch/PyTorch01/">PyTorch笔记01----基本数据类型</a></li>
<li><a
href="/Learning/Notes/PyTorch/PyTorch02/">PyTorch笔记02----创建Tensor</a></li>
<li><a
href="/Learning/Notes/PyTorch/PyTorch03/">PyTorch笔记03----索引与切片</a></li>
<li><a
href="/Learning/Notes/PyTorch/PyTorch04/">PyTorch笔记04----Tensor维度变换</a></li>
<li><a
href="/Learning/Notes/PyTorch/PyTorch05/">PyTorch笔记05----Broadcast自动扩展</a></li>
<li><a
href="/Learning/Notes/PyTorch/PyTorch06/">PyTorch笔记06----拼接与拆分</a></li>
<li><a
href="/Learning/Notes/PyTorch/PyTorch07/">PyTorch笔记07----基本运算</a></li>
<li><a
href="/Learning/Notes/PyTorch/PyTorch08/">PyTorch笔记08----统计属性</a></li>
<li><a
href="/Learning/Notes/PyTorch/PyTorch09/">PyTorch笔记09----高阶OP</a></li>
<li><a
href="/Learning/Notes/PyTorch/PyTorch10/">PyTorch笔记10----激活函数与常见Loss</a></li>
</ul>
<h3 id="papers">Papers</h3>
<ul>
<li><a
href="/Learning/Notes/Papers/GraIL/">GraIL相关论文阅读笔记</a></li>
<li><a
href="/Learning/Notes/Papers/MMKG-Survey/">多模态知识图谱综述笔记</a></li>
<li><a
href="/Learning/Notes/Papers/KG-in-RS-Survey/">基于知识图谱的推荐系统综述笔记</a></li>
<li><a
href="/Learning/Notes/Papers/TKG-Note/">时序知识图谱笔记与知识图谱推理的机遇挑战</a></li>
</ul>
<h3 id="summer-the-basics">2022 Summer: the Basics</h3>
<ul>
<li><a href="/Learning/Notes/2022Summer/the-Basics01/">基础知识</a>
<ul>
<li>张量</li>
<li>参数初始化策略</li>
<li>参数范数与正则化</li>
<li>梯度下降法</li>
<li>梯度爆炸与梯度消失</li>
<li>自适应学习率算法</li>
<li>评估指标</li>
<li>归一化</li>
<li>Dropout</li>
<li>激活函数</li>
<li>损失函数</li>
<li>反向传播算法（公式推导）</li>
<li>过拟合与欠拟合</li>
</ul></li>
</ul>
<h3 id="flutter">Flutter</h3>
<ul>
<li><a href="/Learning/Notes/CommonFlutterWidgets/">Top 70 Common
Flutter Widgets</a></li>
</ul>
<h3 id="latex">Latex</h3>
<ul>
<li><a href="/Learning/Notes/LATEX/">LATEX笔记</a></li>
</ul>
<h3 id="miscellaneousness">Miscellaneousness</h3>
<ul>
<li><a
href="/Learning/Notes/Sparse-Matrix/">稀疏矩阵及其存储格式（COO、CSR、CSC）</a></li>
</ul>
<h2 id="solutions">Solutions</h2>
<ul>
<li><a
href="/Learning/Solutions/Accessing-GitHub-Slowly-Solution/">解决访问GithHub速度慢的问题</a></li>
</ul>
<p><br></p>
<hr />
<p><br></p>
<h1 id="blog">Blog</h1>
<ul>
<li><a
href="/Learning/Blog/Build-Your-Own-Blog-Like-This-One/">基于Hexo与GitHub制作私人博客</a>.</li>
<li><a
href="/Learning/Blog/Blog-Personalization/">博客个性化笔记----基于Ocean</a></li>
<li><a
href="https://markdown.com.cn/basic-syntax/">MarkDown语法</a></li>
<li><a href="/ZONE/Emoji/Emoji.html">MarkDown支持Emoji列表</a> 原地址:
<span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcnhhdmllcnMvNzM2MDkwOA==">Complete list of
github markdown emoji markup<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Archive</tag>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>生活◇奥康剃刀◇与自由意识</title>
    <url>/Archive/1-Life/</url>
    <content><![CDATA[<blockquote>
<p>重要的人和事物，</p>
<p>无论经历多久都不会改变，</p>
<p>人们如此祈祷着.</p>
</blockquote>
<p>封面 [ID:76002561].</p>
<span id="more"></span>
<h1 id="life-recorder">Life-Recorder</h1>
<blockquote>
<p>趁阳光正好，趁微风不燥，趁现在的双手还能拥抱彼此，趁我们还能呼吸，去见你想见的人，做你想做的事.</p>
</blockquote>
<blockquote>
<p>只要留存在什么人的记忆里......</p>
<p>那就是曾经存在过的证明.</p>
</blockquote>
<!-- ## Delicacies
> 疏八珍之谱，以为知味，不如庖丁之一啜。

### Beverages
- [百分茶 BeFineTea](/Life/foods/BeFineTea/)
- [乐乐茶 LeLeTea](/Life/foods/LeLeTea/)

### Dessert & Bread
- [广莲申](/Life/foods/GuangLianShen/)
- [泽田](/Life/foods/ZeTian/)

### Hamburger
- [Shake Shake](/Life/foods/shakeshake/)

### Staple Food
- [小川洋风料理](/Life/foods/XiaoChuan/)

### Snacks -->
<p><br></p>
<hr />
<p><br></p>
<h1 id="imprisoned-post">Imprisoned Post</h1>
<ul>
<li><a href="/Life/Draw-100Days/">Draw 100Days</a></li>
<li><a href="/Life/Zheng-with-his-five-dads/">纪念我们的529</a></li>
</ul>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Archive</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>宝可梦◇熵增定律◇与死亡誓言</title>
    <url>/Archive/1-Pokemon/</url>
    <content><![CDATA[<blockquote>
<p>强大的宝可梦，</p>
<p>弱小的宝可梦，</p>
<p>那只是人的一己之见.</p>
<p>真正强大的训练家应该为了用自己喜欢的宝可梦获胜而努力才对哦.</p>
<p>你知道什么才是最重要的呢.</p>
<p>像以往那样前进吧，</p>
<p>冠军在等你哦. -------- <strong><em>梨花</em></strong></p>
</blockquote>
<p>封面 [ID:79498766].</p>
<span id="more"></span>
<h1 id="preface">Preface</h1>
<blockquote>
<p>我知道你，你就是那个把宝可梦往死里使唤的训练师！</p>
<p>你算什么！没有宝可梦，你算什么！</p>
<p>你……到底伤害了多少精灵才走到今天这一步的？</p>
</blockquote>
<hr />
<blockquote>
<p>我有话要对你说.</p>
<p>那是我在唐草镇第一次遇见你的时候.</p>
<p>从你的宝可梦那里听到的声音让我很震惊………</p>
<p>因为它说</p>
<p>喜欢你，</p>
<p>想和你在一起.</p>
<p>当时我不理解.</p>
<p>世界上居然有喜欢人类的宝可梦.</p>
<p>在那之前我还不知道有这样的宝可梦………</p>
<p>从那之后，随著我继续旅行，我的内心逐渐动摇………</p>
<p>因为我遇到的都是心灵相通、互相帮助的宝可梦和人类.</p>
<p>所以，我才想和你战斗，看看自己相信的东西究竟是什么………</p>
<p>我曾希望能同样作为英雄，与你面对面………</p>
<p>只考虑宝可梦………</p>
<p>不，连宝可梦也无法理解的我………</p>
<p>根本不可能战胜与众多宝可梦邂逅，身边还围绕著同伴的你………</p>
<p>冠军原谅我了………</p>
<p>但是今后我该怎么做，还是要我自己决定………</p>
<p>你说过，你有梦想.</p>
<p>那就去实现那个梦想吧！</p>
<p>实现美好的梦想，将它作为你所追求的真实！</p>
<p>那么………</p>
<p>再见了！ -------- <strong><em>N</em></strong></p>
</blockquote>
<p><br></p>
<hr />
<p><br></p>
<h1 id="vs.-recorder"><a href="/Pokemon/VS-Recorder/">VS.
Recorder</a></h1>
<p>An amazing device that can record a battle either between friends or
at a special battle facility.</p>
<p><br></p>
<hr />
<p><br></p>
<h1 id="strategies">Strategies</h1>
<p>这里我会用来专门整理宝可梦相关攻略，我之后写的攻略也会将直达链接放在这里，方便大家直接查找.</p>
<h2 id="in-game-strategies">In-Game Strategies</h2>
<ul>
<li><p>关于游戏的锁区</p>
<details>
<summary>
<p><img no-lazy data-src="/images/mimikyu.png" alt="请点击丘丘" align=left></p>
</summary>
<p><img data-src="/images/body/1-Pokemon/ZoneLock.jpg" alt="游戏锁区表"></p>
<p>-- gba不锁区 <br> -- 3ds玩3ds卡必锁区 <br> --
主机（不包括ns）全部锁区（n64不清楚 有待考证）</p>
</details>
<p><br><br></p></li>
<li><p>3-5代努力值推荐表，右击另存为图片保存高清大图</p>
<details>
<summary>
<p><img no-lazy data-src="/images/mimikyu.png" alt="请点击丘丘" align=left></p>
</summary>
<p><img data-src="/images/body/1-Pokemon/EVTips.png" alt="努力值推荐表"></p>
</details>
<p><br><br></p></li>
<li><p>3DS关服前软件整理</p>
<details>
<summary>
<p><img no-lazy data-src="/images/mimikyu.png" alt="请点击丘丘" align=left></p>
</summary>
<p><img data-src="/images/body/1-Pokemon/3DSSoftware.png" alt="3DS下载版软件表"></p>
</details>
<p><br><br></p></li>
<li><p><a
href="https://tieba.baidu.com/p/6580100866?red_tag=2783794550">【攻略】【直播演示】GEN3
全图鉴 全精灵 理论规划及演示 -- 卧看微尘 百度贴吧</a></p></li>
<li><p><a
href="/Pokemon/Strategies/In-Game/How-To-Back-Up-Your-Savefiles/">如何备份你的存档</a></p></li>
<li><p><a
href="/Pokemon/Strategies/In-Game/WCD-Distribution-Patch/">如何自制宝可梦Gen4与Gen5的配信器</a></p></li>
<li><p><a
href="https://tieba.baidu.com/p/7680216276?pid=142702978152&amp;cid=#142702978152">【攻略贴】全球第1份100%开启Gen3幻之岛教程！
新年钜献 -- 卧看微尘 百度贴吧</a></p></li>
<li><p><a
href="https://tieba.baidu.com/p/7349572038?pid=139295609895&amp;cid=#139295609895">【攻略贴】神奥“甜甜蜜树”详解
dppt（珍珠钻石白金） -- 卧看微尘 百度贴吧</a></p></li>
<li><p><a
href="/Pokemon/Strategies/In-Game/Battle-Pyramid-Shiny/">战斗金字塔刷闪教程</a>.</p></li>
<li><p><a href="/Pokemon/Shiny-Lock/">锁闪宝可梦汇总</a></p></li>
</ul>
<h3 id="rng-abuse">RNG Abuse</h3>
<ul>
<li>第三世代(RSE)
<ul>
<li><a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part1/">宝可梦绿宝石及没有电的红蓝宝石实机乱数（不包含
ID 或 Egg）</a></li>
<li><a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part2/">宝可梦有电的红蓝宝石实机乱数（不包含
ID 或 Egg）</a></li>
<li><a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part3/">宝可梦火红叶绿实机乱数（不包含
ID 或 Egg）</a></li>
</ul></li>
<li>第四世代(DPPt HgSs)
<ul>
<li><a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen4">宝可梦四代实机乱数</a></li>
</ul></li>
<li>第五世代(BW BW2)
<ul>
<li>贴吧有详细教程，需要注意，bw的seed0会极小程度波动（实操时可以看作不波动）而bw2的seed0可能会有好几个可能的取值，乱数时需要多加尝试，建议花时间通过统计来得到概率最大的seed0。
&gt; 可能会有更加方便或者准确的方法，请读者自行去外网查阅资料。</li>
</ul></li>
<li>第六世代(XY OrAs)
<ul>
<li><a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen6">宝可梦六代实机乱数（破解机插件辅助
&amp; 不包含蛋）</a></li>
</ul></li>
<li>第七世代(SM UsUm)
<ul>
<li>贴吧有详细教程，丘丘尚未深入研究。</li>
</ul></li>
</ul>
<h2 id="out-game-strategies">Out-Game Strategies</h2>
<ul>
<li><a
href="/Pokemon/Strategies/Out-Game/Pokemon-Cartridges-Authenticate/">宝可梦卡带鉴别</a></li>
</ul>
<p><br></p>
<hr />
<p><br></p>
<h1 id="competition-promotion">Competition Promotion</h1>
<ul>
<li><a
href="/Pokemon/Promotion/Magi-cup-1st/">苏州大学第一届鲤鱼王杯</a></li>
</ul>
<p><br></p>
<hr />
<p><br></p>
<h1 id="commemoration">Commemoration</h1>
<ul>
<li><a
href="/Pokemon/See-My-Loving-Pokemons/">纪念我爱的宝可梦们.</a></li>
<li><a href="/Pokemon/PokeSchedule/">willkyu的宝可梦计划</a></li>
</ul>
]]></content>
      <categories>
        <category>Pokemon</category>
      </categories>
      <tags>
        <tag>Archive</tag>
        <tag>Pokemon</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏◇动机判定◇与去悲剧化</title>
    <url>/Archive/1-Game/</url>
    <content><![CDATA[<blockquote>
<p>真想见识更多的景色啊.</p>
<p>正因为知道了世界的广阔和自己的渺小，</p>
<p>才会对明天充满希望！</p>
</blockquote>
<blockquote>
<p>有的人说，</p>
<p>因为世界如此之大，</p>
<p>才有了各种各样的想法.</p>
<p>也有的人说，</p>
<p>正是因为各种各样的想法，</p>
<p>世界才如此广阔.</p>
<p>这两种说法，</p>
<p>都是正确的.</p>
</blockquote>
<p>封面 [ID:90778756].</p>
<span id="more"></span>
<h1 id="preface">Preface</h1>
<blockquote>
<p>如果你面对抉择的时候，让别人替你做决定.</p>
<p>你会对事情的结果后悔的.</p>
</blockquote>
<p><br></p>
<hr />
<p><br></p>
<h1 id="flash-card">Flash Card</h1>
<ul>
<li><a href="/Game/DSTWO/">DSTWO相关资源整理</a></li>
<li><a href="/Game/EZODE/">EZ-Flash Omega Definitive
Edition相关资源整理</a></li>
</ul>
<p><br></p>
<hr />
<p><br></p>
<h1 id="splatoon2">Splatoon2</h1>
<ul>
<li><a href="/Game/Share-Splatoon2-Happiness/">快乐的喷喷生活</a></li>
<li><a href="/Game/Undercover-Brella-Diary">间谍伞日记</a></li>
</ul>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>Archive</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>收藏◇知觉丧失◇与不完备定理</title>
    <url>/Archive/1-Collection/</url>
    <content><![CDATA[<blockquote>
<p>纵然身朽去，心美亦永恒</p>
</blockquote>
<p>封面 [ID:71672001].</p>
<span id="more"></span>
<h1 id="overview.">Overview.</h1>
<figure>
<img data-src="/images/body/Collection/Overview.jpg" title="Overview"
alt="总览" />
<figcaption aria-hidden="true">总览</figcaption>
</figure>
]]></content>
      <categories>
        <category>Collection</category>
      </categories>
      <tags>
        <tag>Collection</tag>
        <tag>Archive</tag>
      </tags>
  </entry>
  <entry>
    <title>UTLov for OlivOS | 像看replay一样跑团</title>
    <url>/TRPG/Tools/UTLov/</url>
    <content><![CDATA[<p>封面 [ID:99703082].</p>
<span id="more"></span>
<h1 id="功能介绍">功能介绍</h1>
<p>本插件基于OlivOS实现跑团时实时窗口,
PL、KP和OB的发言均可以显示在实时窗口中,
并且会将PC、KP和NPC的话实时转语音播放,
掷骰时也会有一点点replay的感觉(有但不多), 使得PL们跑团时更有沉浸感,
希望能鼓励PL们的RP.
此外你也可以使用它来进行跑团直播或是录制当作简单的replay.</p>
<p><a
href="https://www.bilibili.com/video/BV144421c7pP/?vd_source=e1ff0185e3ca082e7577b5654e16f3da">实际演示请看视频.</a></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpbGxreXUvVVRMb3Y=">已在Github开源.<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="截图示例">截图示例</h1>
<p><img data-src="/images/body/UTLov/UTLov.png" /></p>
<h1 id="使用环境">使用环境</h1>
<ul>
<li>源码运行的OlivOS, 因为我们需要在运行环境里引入其他第三方库,
我这里使用的是3.11版本的python</li>
<li>在运行环境中, 需要使用pip安装以下的库:
<ul>
<li>flet == 0.19.0 注意, 这个库只能运行在windows10以上.</li>
<li>playsound == 1.2.2 注意, 这个库最好和我的版本一致,
最新版本有bug.</li>
<li>baidu-api == 4.16.13</li>
</ul></li>
<li>此外,
本插件在运行的时候的界面是出现在OlivOS所运行的服务器(电脑)上的,
所以最好该电脑是私人电脑而不是云端服务器.</li>
</ul>
<p>在满足以上条件后,
我们需要先将<code>.opk</code>格式的插件后缀改为<code>.zip</code>,
然后解压并打开<code>UTLovConfig.py</code>文件. 找到第七行的"Path"配置,
将后面的文件路径改为你的资源文件夹的位置.</p>
<blockquote>
<p>如果你不知道资源文件夹是什么,
你只需要随便在一个位置创建一个新的文件夹, 然后输入其地址即可.</p>
</blockquote>
<p>保存后重新打包为<code>.zip</code>的压缩包,
然后更改后缀为<code>.opk</code>,
最后将其放入OlivOS的插件文件夹然后重载插件即可.</p>
<h1 id="资源准备">资源准备</h1>
<p><em>以下操作都在你的资源文件夹中进行.</em></p>
<p>首先是资源文件夹的文件结构如下图所示:</p>
<p><img data-src="/images/body/UTLov/files.png" /></p>
<blockquote>
<p>这里我的资源文件夹就是data. 其中, 打码的部分为用户的QQ号.</p>
</blockquote>
<p>文件结构为:</p>
<ul>
<li>若干个以QQ号命名的文件夹, 他们是KP或者PL们的资源文件夹.</li>
<li>一个名为<code>bg</code>的文件夹, 里面放的是若干你需要使用的背景图片.
(在本插件中, 图片仅支持<code>.jpg</code>或<code>.png</code>格式)</li>
<li>一个名为<code>npc</code>的文件夹,
里面放的是各个npc的资源文件夹.</li>
<li>一个名为<code>ob</code>的文件夹, 不用管它, 一个空的文件夹即可.</li>
<li>一张名为<code>avatar</code>的图片, 它是未找到图像时的默认头像,
一般用于不重要的npc.</li>
<li>一张名为<code>dice_bot_avatar</code>的图片, 它是骰娘的头像.</li>
<li>一个名为<code>dice</code>的音频文件, 只支持<code>.mp3</code>格式,
它是掷骰音效.</li>
<li>一张名为<code>fig</code>的图片, 它是未找到图像时的默认立绘,
一般用于懒得找立绘的pc.</li>
<li>一个名为<code>UTLov</code>的配置文件, 后缀是<code>.ini</code>,
这是主要的配置文件之一, 可以通过新建文本文档然后改后缀来创建.</li>
</ul>
<p>下面我们将按顺序来准备这些文件.</p>
<h2 id="pl的资源文件夹">PL的资源文件夹</h2>
<p>PL的资源文件夹主要有三个文件: - 一个名为<code>avatar</code>的图片,
它是该PL的PC的头像. 如果没有会自动获取该PL的QQ头像. -
一个名为<code>fig</code>的图片, 它是该PL的PC的立绘.
如果没有会自动使用上述根资源文件夹的名为<code>fig</code>的图片. -
一个名为<code>userinfo</code>的配置文件.</p>
<h3 id="userinfo.ini">userinfo.ini</h3>
<p>下图是该文件的一个示例.</p>
<p><img data-src="/images/body/UTLov/userinfo.png" /></p>
<p>其中Main模块中的name和job分别为PC的名字和职业.</p>
<p>audio模块中的spd、pit、vol和per分别为语速(取值0-15，默认为5中语速)、音调(取值0-15，默认为5中语调)、音量(基础音库取值0-9，精品音库取值0-15，默认为5中音量.
取值为0时为音量最小值，并非为无声)和音源(度小宇=1，度小美=0，度逍遥（基础）=3，度丫丫=4，(后面的是精品音库)
度逍遥（精品）=5003，度小鹿=5118，度博文=106，度小童=110，度小萌=111，度米朵=103，度小娇=5)</p>
<p>status中的应该看了都知道什么意思.</p>
<p>下面贴上可以直接复制的示例: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Main]</span><br><span class="line">name = 焦糖色</span><br><span class="line">job = 陪酒妹妹</span><br><span class="line"></span><br><span class="line">[audio]</span><br><span class="line">spd = 5</span><br><span class="line">pit = 7</span><br><span class="line">vol = 5</span><br><span class="line">per = 5118</span><br><span class="line"></span><br><span class="line">[status]</span><br><span class="line">hp = 11</span><br><span class="line">hpmax = 12</span><br><span class="line">san = 56</span><br><span class="line">sanmax = 60</span><br><span class="line">mp = 12</span><br><span class="line">mpmax = 12</span><br><span class="line">status = 正常</span><br></pre></td></tr></table></figure></p>
<h2 id="kp的资源文件夹">KP的资源文件夹</h2>
<p>KP的资源文件夹与PL的类似, 只是没有配置文件<code>userinfo</code>.</p>
<h2 id="背景图片文件夹">背景图片文件夹</h2>
<p>请至少放入一张名为<code>bg</code>的图片文件, 其他的背景随意命名.</p>
<h2 id="npc文件夹">npc文件夹</h2>
<p>npc文件夹里面包含:</p>
<ul>
<li>若干以NPC名字命名的文件夹, 用于存放各个重要NPC的资源文件,
其与PL文件夹内容类似.
<ul>
<li>一个名为<code>avatar</code>的图片, 它是该NPC的头像.</li>
<li>一个名为<code>fig</code>的图片, 它是该NPC的立绘.</li>
<li>一个名为<code>audio</code>的配置文件.</li>
</ul></li>
<li>一张名为<code>default_avatar</code>的图片, 它是不重要NPC的头像.</li>
<li>一张名为<code>default_female</code>的图片,
它是不重要女NPC的立绘.</li>
<li>一个名为<code>default_female</code>的配置文件,
它的内容与npc文件夹里的配置文件<code>audio</code>一致,
它是不重要女NPC的声音配置文件.</li>
<li>一张名为<code>default_male</code>的图片, 它是不重要男NPC的立绘.</li>
<li>一个名为<code>default_male</code>的配置文件,
它的内容与npc文件夹里的配置文件<code>audio</code>一致,
它是不重要男NPC的声音配置文件.</li>
</ul>
<blockquote>
<p>所有没有单独文件夹(以名字命名)的NPC都是不重要NPC</p>
</blockquote>
<h3 id="audio.ini">audio.ini</h3>
<p>下图是该文件的一个示例.</p>
<p><img data-src="/images/body/UTLov/audio.png" /></p>
<p>同PL的配置文件<code>userinfo</code>里的audio模块. 注意,
上述配置文件<code>default_male</code>与<code>default_female</code>的文件内容与这个一致(具体声音配置可以更改).</p>
<h2 id="ob文件夹">OB文件夹</h2>
<p>空文件夹, 运行后如果有人不在配置的PL或是KP中则会被自动归入OB列表,
届时该文件夹会存储他们的QQ头像</p>
<h2 id="utlov.ini">UTLov.ini</h2>
<p>主配置文件, 下图是该文件的一个示例.</p>
<p><img data-src="/images/body/UTLov/UTLov.png" /></p>
<p>其中Main模块的Master_id是用于触发启动命令的QQ号,
一般为运行OlivOS的电脑的所有者. KP_id是KP的QQ号,
Group_id是运行该插件的群号. Opening是插件启动时自动用KP配置说出的话,
已被废弃, 可以不要. Bot_name为显示在窗口中的的骰娘名字.</p>
<p>BaiduAPI模块的三个配置请使用自己的Baidu API信息替换,
这是用于百度语音合成的, 具体请百度 <strong>百度语音合成</strong>,
注册会赠送3w次免费试用(好像).</p>
<p>KP_audio模块是KP声音的配置.</p>
<p>下面贴上可以直接复制的示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Main]</span><br><span class="line">Master_id = 49xxxxxx8</span><br><span class="line">KP_id = 49xxxxxx8</span><br><span class="line">Group_id = 95xxxxxx5</span><br><span class="line">Opening = 大家好，我是本次测试KP 丘丘。</span><br><span class="line">Bot_name = 黑巧的容器</span><br><span class="line"></span><br><span class="line">[BaiduAPI]</span><br><span class="line">APP_ID = 48xxxx84</span><br><span class="line">API_KEY = Ts**************EOe</span><br><span class="line">SECRET_KEY = aG****************************Ld</span><br><span class="line"></span><br><span class="line">[KP_audio]</span><br><span class="line">spd = 5</span><br><span class="line">pit = 7</span><br><span class="line">vol = 5</span><br><span class="line">per = 5118</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有其他的多余文件不会影响插件运行,
所以可以放入一些备用文件以便替换.</p>
</blockquote>
<blockquote>
<p>整个资源文件夹的示例已上传至github.</p>
</blockquote>
<h1 id="使用方法">使用方法</h1>
<p>在配置的群聊中使用<code>.utlov</code>命令即可开始.
使用<code>.utlov end</code>命令即可结束. <strong>注意,
结束后如果要再次使用请重载一次插件</strong>(这是bug懒得修了).</p>
<p>支持的命令:</p>
<ul>
<li>rd</li>
<li>rb</li>
<li>rp</li>
<li>ra</li>
<li>rh</li>
<li>st hp或san或mp + 运算表达式 (如果掉了1血就<code>.st hp-1</code>,
不要直接<code>.st hp 数值</code> 这会无法识别从而不能同步进窗口)</li>
</ul>
<p>特别的命令: -
以<code>(</code>(中英文皆可)开头的PL或KP的发言会进入窗口的meta区(超游区),
并且不会进行语音合成. - <code>.sset PC名字 状态</code>
可以设置窗口中PC的状态, 如果该状态不是"正常", 则其头像会变红.
例如:<code>.sset 小夜子 疯狂</code> - 对于KP,
可以使用<code>.NPC名字.NPC说的话</code>来进行NPC发言,
如果是非重要女NPC则需要在第一个点后面加一个英文问号. 例如: -
命令<code>.Mia.大家好,我是Mia</code>,
如果上述资源准备中有配置npc/Mia的相关资源,
那么会以配置的头像立绘与声音来发言:"大家好,我是Mia". -
命令<code>.路人A.大家好,我是路人A</code>,
如果上述资源准备中没有配置npc/路人A的相关资源,
那么会以default_male的立绘声音来发言:"大家好,我是路人A" -
命令<code>.?路人B.大家好,我是路人B</code>,
如果上述资源准备中没有配置npc/路人B的相关资源,
那么会以default_female的立绘声音来发言:"大家好,我是路人B" - 此外,
不论是KP还是PL,
所有其他以<code>.</code>或<code>。</code>开头的话不会进行处理(OB除外).</p>
<h1 id="写在最后">写在最后</h1>
<p>UTLov这个名字取自我的跑团小群Untitled Tavern的缩写UT加上love,
感谢所有PL们以及和我一起入坑跑团的火龙果.</p>
<p>祝大家次次大成功!</p>
]]></content>
      <categories>
        <category>TRPG</category>
      </categories>
      <tags>
        <tag>TRPG</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>第三螺旋：灰海</title>
    <url>/TRPG/Mods/Third-Spiral-Grey-Sea/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Invalid Password. Check And Try Again! (♯｀∧´)" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e8a1abf830c5eb6c6d41c79403be405bf67fa40db3bd4829db4652a7bf508fb4">a9154d246928e9e831e6545b33e2d3386fd120119228a405fcd316f4a77f0d9ed16869148bdaef9d382d9486957d6653d73b7041547ff3898089e451c1b7133ed2f1df2ef8019261e2e64fe509af0e5cabcc6933b4cb59abb968fc89b1f3c390a14b971b4e62cde95594f7b68f0212a5a826baec7dff3b1a596c8f32f55c6c5e2fa21d664958df669cdb45add72ac69e473bb55753b7b34c53d4376f39e40b848444aa9233dc4c5607c96f1846a86c47ba256841028f411f59e975488275cb8d06f2fc173388b0aff8da7ccf555cd37a0fcfab93d78583a9096bbc0c2f21908adb02d9891dea6f90f7f6f52f5e172047ebb3cf5aae68f026fc9231f1d10d90c5fab5db9d3072c3816f759dee39175ff6aeeee19999d5ffeaeb7325e6803abd709836ab18876a54ab09c4c69932731af5797da4febd62cbed58734c0e0531f472</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>TRPG</category>
      </categories>
      <tags>
        <tag>TRPG</tag>
        <tag>Mods</tag>
      </tags>
  </entry>
  <entry>
    <title>时序知识图谱笔记与知识图谱推理的机遇挑战</title>
    <url>/Learning/Notes/Papers/TKG-Note/</url>
    <content><![CDATA[<h1 id="简介">简介</h1>
<p>主要来自： - Tittle: <strong>Reasoning over Different Types of
Knowledge Graphs: Static, Temporal and Multi-Modal</strong> - Author: Ke
Liang, Lingyuan Meng, Meng Liu, Yue Liu, Wenxuan Tu, Siwei Wang, Sihang
Zhou, Xinwang Liu , Senior Member, IEEE, Fuchun Sun, Fellow, IEEE -
Time: 24 Jan 2023 - Journal:</p>
<span id="more"></span>
<h1 id="定义">定义</h1>
<p>时序知识图谱推理（Temporal Knowledge Graph Reasoning）： Given a
temporal knowledge graph</p>
<p><span class="math display">\[
\mathcal{TKG=\{SKG_1, SKG_2, SKG_3, \ldots, SKG_t\}}
\]</span></p>
<p>where <span
class="math inline">\(\mathcal{SKG_t=\{E,R,F_t\}}\)</span> and timestamp
<span class="math inline">\(t \in \mathcal{T}\)</span>. With the queried
fact <span class="math inline">\((e^q_h, r^q, e^q_t, t^q)\)</span>,
reasoning can be classified into three types, including entity
reasoning, relation reasoning and timestamp reasoning.</p>
<figure>
<img data-src="/images/body/Papers/TKG-Note/Fig1.png" alt="Fig.1" />
<figcaption aria-hidden="true">Fig.1</figcaption>
</figure>
<p>根据queried fact的时间，推理又分为两类：interpolation reasoning 和
extrapolation reasoning（内推和外推）。详见Fig.1.</p>
<h1 id="模型">模型</h1>
<p>主要分为RNN-based Model和RNN-agnostic Model。</p>
<h2 id="rnn-based-model">RNN-based Model</h2>
<p>RNN很适合挖掘时间的变化，因此很多TKGR模型使用RNN来直接建模时序信息，称为RNN-based
Model。 根据使用的RNN的变种，可以分为三类：RNN、LSTM和GRU。</p>
<p>就先不细看了。</p>
<h2 id="rnn-agnostic-model">RNN-agnostic Model</h2>
<p>这些模型不适用RNN框架来采用时序信息，从而扩充原始的static
KGR模型。时间信息如何指导模型，可以将其大致分为两类：time-vector guided
models 和 time-operation guided models。</p>
<h3 id="time-vector-guided-model">Time-Vector Guided Model</h3>
<p>时间向量引导模型直接为时序信息生成附加时序嵌入t并将其作为附加信息与原始事实嵌入结合。虽然简单，但是模型效果主要依赖于时间编码器和嵌入融合模块是否合适。</p>
<h3 id="time-operation-guided-model">Time-Operation Guided Model</h3>
<p>时间操作引导模型利用一些特定的操作来组合时序信息到实体和关系嵌入中而不是直接生成时序嵌入t。比如将事实编码到设计的特定时间超平面中，并生成与时间相关的奖励。</p>
<p>RNN-agnostic Model比起RNN-based Model更为灵活。但是RNN-based
Model对时间信息建模的最好而且更容易使用在外推场景中。外推场景仍在早期阶段，有很大发展空间。</p>
<h1 id="数据集">数据集</h1>
<p>原文写的很多，可以直接看原文4.2节。</p>
<h1 id="机遇与挑战">机遇与挑战</h1>
<h2 id="分布外推理-out-of-distribution-reasoning">分布外推理
Out-of-distribution Reasoning</h2>
<p>使用增量对事实的推理叫做分布外推理，这对KGR模型的设计要求很高。最近一些尝试
为<strong>推断不可见实体</strong>提供了潜在方案，被称为
归纳推理模型。这些模型不考虑实体的具体含义，只挖掘图结构下的逻辑规则，取得了良好的性能。对于<strong>不可见关系推断</strong>，少镜头KGR模型倾向于提高模型的泛化能力，使训练后的模型能够很好地拓展到含有少量事实的不可见关系上。也就是说，少镜头KGR模型可以根据之前学习的相似知识快速学习新的任务。此外BERTRL试图根据语言模型计算出的文本语义来处理这种情况。而当语言模型没有得到很好的训练时，这些模型的性能会急剧下降。综上所述，分布外推理任务的KGR模型仍处于早期阶段，值得未来深入探索。</p>
<h2 id="大尺度推理-large-scale-reasoning">大尺度推理 Large-scale
Reasoning</h2>
<p>工业知识图谱都相当的大，需要更加有效率的KGR模型。因此当前有些工作尝试以渐进的方式优化传播过程。</p>
<h2 id="多关系推理-multi-relational-reasoning">多关系推理
Multi-relational Reasoning</h2>
<figure>
<img data-src="/images/body/Papers/TKG-Note/Fig2.png" alt="Fig.2" />
<figcaption aria-hidden="true">Fig.2</figcaption>
</figure>
<p>多关系在知识图谱中是很常见的，和uni-relational、bi-relational
facts相比有更多样的结构和更复杂的语义，因此现今的KGR模型主要关注uni-relational、bi-relational
facts，甚至常常将多关系简化视作uni-relational、bi-relational
facts。这样的KGR模型不能准确地模拟真实情况，丢失了大量有意义的语义信息，导致表达能力不足。未来有必要研究如何利用多关系事实来提高推理能力。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Papers</tag>
      </tags>
  </entry>
  <entry>
    <title>基于知识图谱的推荐系统综述笔记</title>
    <url>/Learning/Notes/Papers/KG-in-RS-Survey/</url>
    <content><![CDATA[<h1 id="简介">简介</h1>
<ul>
<li>Tittle: <strong>A Survey on Knowledge Graph-Based Recommender
Systems</strong></li>
<li>Author: Qingyu Guo, Fuzhen Zhuang, Chuan Qin, Hengshu Zhu, Senior
Member, IEEE, Xing Xie, Senior Member, IEEE, Hui Xiong, Fellow, IEEE,
and Qing He</li>
<li>Time: 7 October 2020</li>
<li>Journal: IEEE Transactions on Knowledge and Data Engineering</li>
</ul>
<p>20年利用知识图谱的推荐系统综述。</p>
<span id="more"></span>
<h1 id="基于知识图谱的推荐系统综述">基于知识图谱的推荐系统综述</h1>
<h2 id="methods">Methods</h2>
<h3 id="embedding-based-method">Embedding-based Method</h3>
<p>基于嵌入的方法通过利用kg中的多样事实来丰富item或user的表示，主要分为两个基础模块：图嵌入模块（学习图谱中的实体和关系表示）和推荐模块（使用学习到的特征来估计user对item的倾向）。</p>
<p>分类：<em>the two-stage learning method</em>、<em>the joint learning
method</em> 、and <em>the multi-task learning method</em>。</p>
<p>挑战：如何通过正确的知识图谱嵌入方法来获得实体嵌入，如何在推荐模块中结合已学习的实体嵌入。</p>
<h4 id="two-stage-learning-method-两阶段学习方法">Two-stage Learning
Method 两阶段学习方法</h4>
<p>分别训练图嵌入模块和推荐模块，图嵌入模块使用KGE训练之后与user、item的特征一起输入推荐模块进行预测。</p>
<p>优点：容易实现、kge不需要useritem的互动数据，对于大尺度数据集不会增加计算复杂度</p>
<p>缺点：transductive的缺点，训练好之后难以更新，需要重新训练，两模块直接联系不够紧密，不太适合kg外任务（有个解决方法是使用gan或贝叶斯生成模型来初始化实体嵌入）。</p>
<h4 id="joint-learning-method-联合学习方法">Joint Learning Method
联合学习方法</h4>
<p>把两模块端到端结合起来一起训练，推荐模块可以指导图嵌入模块的特征学习。</p>
<p>优点：可以端到端地训练，可以利用kg结构来规范推荐系统。</p>
<p>缺点：对于结合不同目的的函数，需要微调（fine-turning）</p>
<h4 id="multi-task-learning-method-多任务学习方法">Multi-task Learning
Method 多任务学习方法</h4>
<p>多任务学习就像是几个网络共用前多少层，然后对于不同的任务选择不同的分支进行？
使用kg相关的任务来指导推荐任务的训练，动机是因为useritem二部图中的items与kg中关联的实体的结构相似，因此在他们之间传递low-level
特征（有点像是细粒度？比如卷积一次的图还是能看出来原来是什么，卷积多次之后就是high-level
feature）对促进推荐系统的提升有帮助。</p>
<p>优点：能帮助避免推荐系统过拟合，提升泛化能力。</p>
<p>缺点：与联合学习方法类似，在一个框架下需要联合不同的任务。</p>
<h3 id="connection-based-method">Connection-based Method</h3>
<p>基于连接的方法利用图中的连接模式来指导推荐系统。大部分工作利用useritem的kg来挖掘图中实体的关系。</p>
<p>分类：<em>Meta-structure Based Method</em>、and <em>Path-embedding
Based methods</em>。</p>
<p>挑战：如何为困难的任务设计合适的元路径，如何建模实体间的连接模式。</p>
<h4 id="meta-structure-based-method-基于元结构的方法">Meta-structure
Based Method 基于元结构的方法</h4>
<p>元结构包括 meta-path 和
meta-graph，利用元结构来计算实体间的相似性，可以作为user和item表示的约束，或者用来从互动历史中的相似user、相似item来预测用户的兴趣。其中一种实现是利用不同元路径的实体的连接相似性作为图规范化来约束user和item的表示，动机是有高度元路径相似度的实体在潜在空间中都比较接近。</p>
<p>优点：容易实现，且大部分都基于矩阵分解技术（MF），使得模型复杂度低。</p>
<p>缺点：元路径或元图的选择需要相应领域的知识，且这些元结构在不同的数据集中差距很大。在某些特殊场景，该方法并不合适，例如新闻推荐任务中，一个新闻的实体可能属于不同的领域，使得很难设计元路径。连接模式没有明确地建模，因此这个方法缺乏一定的表示能力（FMG通过用元图代替元路径，捕捉更丰富的语义来解决这个问题）。</p>
<h4 id="path-embedding-based-methods-基于路径嵌入的方法">Path-embedding
Based methods 基于路径嵌入的方法</h4>
<p>基于元结构的方法中有个问题就是连接模式没有明确地建模，这使得很难学到useritem对和连接模式之间的相互作用。基于路径嵌入的方法就是来明确学习连接模式的嵌入。一些工作学习useritem知识图谱中的useritem对的连接、或item知识图谱中的itemitem对的连接的路径的明确嵌入来直接对useritem关系或itemitem关系建模。</p>
<p>优点：能够考虑目标用户、候选item和连接模式之间的相互作用。大部分模型能不借助预定义的元结构的帮助，自动地通过计算合格的路径并选择主要的那些来挖掘连接模式。因此可以能捕捉有表达力的连接模式。</p>
<p>缺点：如果图中的关系十分复杂，可能的路径数会相当大。实际中几乎不可能利用大规模知识图谱中每个实体对的所有路径，不然会妨碍模型的性能。</p>
<h3 id="propagation-based-method">Propagation-based Method</h3>
<blockquote>
<p>High-order relations contain spatial relations (e.g., “behind”,
“below”, “left”) and semantic relations (e.g., “playing”, “wearing”,
“holding”). Then these relations are combined with visual features to
enrich the representations of images.</p>
</blockquote>
<p>基于嵌入的方法利用知识图谱中的语义关系来丰富用户与物品表示或规范化推荐，但很难捕捉实体间的高阶关系（high-order
relations）。
基于连接的方法将复杂的useritem连接模式分解为线性路径，不可避免地会丢失信息。
基于传播的方法结合实体关系表示和高阶连接模式来创造一个更加人性化的推荐系统。基于传播的方法是基于表征传播（embedding
propagation）的思想。这些方法（GNN）通过聚合多跳邻居节点完善了实体嵌入，然后再进行推荐。</p>
<p>基于传播的方法一般都很消耗计算资源，为了提升效率，提出了更快的图卷积操作，在每层中通常使用邻居采样。然而随机采样会不可避免地损失信息，无法完整地explore图中的知识。</p>
<p>分类：<em>Refinement of User Representation</em>、<em>Refinement of
Item Representation</em>、and <em>Refinement of both User and Item
Representation</em>。</p>
<p>挑战：如何给不同的邻居分配合适的权重，如何在不同关系的边上传播信息，如何提升模型的泛化能力。</p>
<h4 id="refinement-of-user-representation-丰富用户表示">Refinement of
User Representation 丰富用户表示</h4>
<p>基于用户的互动历史来丰富用户表示，这些工作构建多种关系连接互动items和候选items的item
KG。动机是用户可以通过他们互动过的items和其多跳邻居来聚合为一个整体。</p>
<p>优点：在这个方法中item
KG的边的权重是明确的，因此可以选择连接候选item与交互过的item的主要路径（salient
path）来作为推荐结果的解释。</p>
<p>缺点：尽管利用了实体嵌入和高阶连接信息，在传播过程中只有用户表示得到了更新。</p>
<h4 id="refinement-of-item-representation-丰富物品表示">Refinement of
Item Representation 丰富物品表示</h4>
<p>在item
KG中，通过聚合候选物品的多跳邻居来学习其高阶表示。在向内的传播过程中，采用图注意力机制，其中不同邻居的权重是根据用户与关系特定的。动机是用户对不同的关系会有不同的倾向，这会引导知识图谱中的信息流动。</p>
<p>优缺点与丰富用户表示类似。</p>
<h4
id="refinement-of-both-user-and-item-representation-丰富用户与物品表示">Refinement
of both User and Item Representation 丰富用户与物品表示</h4>
<p>在useritem
KG中的传播机制，user、item和他们相关联的实体都在一张图中连接起来，useritem对之间的交互可以看作关系的一种。用户与物品嵌入可以通过他们相关的邻居节点上的传播过程来进行增强。</p>
<blockquote>
<p>和我想的useritementity的知识图谱很像，使用这种方法来获得user和item的嵌入，然后进行推荐预测。但本质上还是基于嵌入的链接预测？没法处理新的item和新的user，不然要重新嵌入，而且也会遇到冷启动问题？</p>
</blockquote>
<p>优点：权重也是user-specific的，所以也有一定的可解释性。特别是user也作为node，所以解释更直觉，高阶连接模式被充分利用。</p>
<p>缺点（downside）：图中更多的关系会带来不相关的实体，这会误导聚合过程中的用户倾向（为了解决，AKGE在子图中学习useritem对的加强表示）。</p>
<h2 id="datasets">Datasets</h2>
<p>See Table.1 .</p>
<figure>
<img data-src="/images/body/Papers/KG-in-RS-Survey/Table01.png"
alt="Table.1" />
<figcaption aria-hidden="true">Table.1</figcaption>
</figure>
<h2 id="future-directions">Future Directions</h2>
<h3 id="动态推荐">动态推荐</h3>
<p>GNN或GCN架构的KG-based推荐系统效果很好但是很耗时，因此可以被视作静态推荐。但在某些场景中，用户的兴趣会被社会事件或是朋友快速影响，这种情况下静态推荐无法理解实时的兴趣。可以利用动态图网络，来捕捉动态倾向。</p>
<h3 id="多任务学习">多任务学习</h3>
<p>KG-based推荐系统可以自然地视为图中的链接预测，所以考虑知识图谱的特性可能可以提升基于知识图谱的推荐性能。比如，kg中可能存在缺失事实，导致缺失关系或缺失实体，然而用户的倾向可能会因为这些事实的缺失而被忽略，这可能是推荐结果的决定性因素。Papers
[54], [71]
显示训练知识图谱补全后的推荐系统会有更好的结果。其他工作利用多任务学习，通过用kge任务[53]和item关系规范任务[55]来训练推荐模块。充分利用其他kg任务如实体分类与分解来将知识转移从而提升推荐效果会很有趣。</p>
<h3 id="跨领域推荐">跨领域推荐</h3>
<p>跨领域的交互数据是不均衡的，比如亚马逊平台的书的集合是大于别的领域的。通过迁移学习技术，源领域的交互数据可以被目标领域所利用，从而更好地推荐。Zhang
et al. [110]提出了基于矩阵的方法来跨领域推荐，Zhao et al.
[111]提出了PPGN，将不同领域的user和products放在一种图中，然后利用useritem交互图来跨领域推荐。尽管PPGN效果很好，但useritem图只包含了交互信息，没有考虑其他的关系。合并不同类型的useritem数据来进行跨领域推荐的前景不错。</p>
<h3 id="知识增强的语言表示">知识增强的语言表示</h3>
<p>将额外的知识集成到语言表示模型中来提升各种nlp任务，这样可以人为增强知识表示和文本表示。在新闻推荐系统或是其他基于文本的推荐任务中采用知识增强的文本表示很有前景，能有更好的表示学习，促进更准确的推荐。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Papers</tag>
      </tags>
  </entry>
  <entry>
    <title>Top 70 Common Flutter Widgets</title>
    <url>/Learning/Notes/CommonFlutterWidgets/</url>
    <content><![CDATA[<p>From <span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9HMUxHT0g0MjRsbw==">Best Flutter Widgets
EVER!<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h1 id="top-70-common-flutter-widgets">Top 70 Common Flutter
Widgets</h1>
<ol type="1">
<li>MaterialBanner 点击按钮 从上方弹出提示</li>
<li>PreferredSize 创建你自己的appbar</li>
<li>BottomSheet 点击按钮 从底部弹出新页面（占据一半）</li>
<li>LongPressedDraggable 长按拖拽</li>
<li>InteractiveViewer 可以缩放</li>
<li>RecorderableListView 可以给listview里的拖拽排序</li>
<li>CheckboxListTile 勾选框</li>
<li>CircleAvatar 一个圆</li>
<li>CupertinoContextMenu 一个按钮触发多个选项供选择（省略号常用）</li>
<li>Table 表格</li>
<li>AlertDialog 提示</li>
<li>AnimatorContainer 可以变换的container</li>
<li>Card 有阴影的container？</li>
<li>DataPicker 选择日期的widget</li>
<li>TimePicker 选择时间的widget</li>
<li>DateRangePicker 选择时间区间的widget</li>
<li>Dismissable 可以左滑删除item的widget</li>
<li>DraggableScrollableSheet 可以拖动的scrollable sheet</li>
<li>DragTarget 可以拖拽Draggable widget进去的widget</li>
<li>Draggable 可以拖拽的widget</li>
<li>AnimatedCrossFade fade效果的widgets切换</li>
<li>Drawer 侧边栏</li>
<li>DrawerHeader 侧边栏header</li>
<li>PopupMenuButtom 有点像9，但是给的是返回值？</li>
<li>AnimatedDefaultTextStyle 可变换的textstyle？</li>
<li>AspectRatio 填充固定比例</li>
<li>AutoComplete 文本自动补全（联想）</li>
<li>ErrorWidget 出现错误的widget</li>
<li>Expaned 根据比例分配高/宽</li>
<li>Flexible 和expanded差不多，但是会被height覆盖</li>
<li>FloatingActionButton 悬浮按钮</li>
<li>Form 规定输入格式</li>
<li>TextFromField</li>
<li>AnimatedIcon 可变换的icon（例如播放暂停）</li>
<li>ChoiceChip 可供选择的文本标签</li>
<li>FadeInImage 加载出来图片之前可以设置默认图片</li>
<li>FractionallySizedBox 设置的高宽是基于屏幕比例的</li>
<li>FutureBuilder 加载完才会显示</li>
<li>GestureDetector 增加手势识别</li>
<li>GridView 有各种元素的滚动条？</li>
<li>GridTile 图片有header和footer</li>
<li>GridTileBar 给GridTile加上各种图标功能</li>
<li>AnimatedRotation 旋转动画</li>
<li>Hero 从一个页面跳到另一个页面的动画</li>
<li>IgnorePointer 可以使得按钮无法使用</li>
<li>IndexStack 点击相应index切换</li>
<li>ListView</li>
<li>ListTile</li>
<li>NavigationBar 底部栏</li>
<li>AnimatedOpacity 改变透明度的动画？</li>
<li>Stack 类似图层？</li>
<li>Stepper 生成Step</li>
<li>SteamBuilder 一串数据获取</li>
<li>Switch 类似c的switch</li>
<li>TabPageSelector 一般app第一次使用时的page切换</li>
<li>TabBar 顶部栏</li>
<li>PageView 左右滑动的页面</li>
<li>Positioned 放置确定位置的组件</li>
<li>RadioListTile 单选组件</li>
<li>RefreshIndicator 刷新组件</li>
<li>RotatedBox 旋转组件（不是动画）</li>
<li>SelectableText 可以选中（复制）的文本组件</li>
<li>Slider 滑块</li>
<li>SnackBar 底部提示，会自动消失</li>
<li>Visibility 可以隐藏的组件</li>
<li>Wrap</li>
<li>SafeArea 只在没有手机遮挡部分的地方的框</li>
<li>LayoutBuilder 根据手机size选择显示内容</li>
<li>OrientationBuilder 可以做横竖屏切换</li>
<li>OverflowBar 如果横着放不下会自动竖着放</li>
<li>FittedBox 自适应box</li>
<li>ExpansionTile 折叠列表</li>
<li>CupertinoSlidingSegmentedControl 根据选择tag切换</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>多模态知识图谱综述笔记</title>
    <url>/Learning/Notes/Papers/MMKG-Survey/</url>
    <content><![CDATA[<h1 id="简介">简介</h1>
<ul>
<li>Tittle: <strong>Multi-Modal Knowledge Graph Construction and
Application: A Survey</strong></li>
<li>Author: Xiangru Zhu, Zhixu Li Member, IEEE, Xiaodan Wang, Xueyao
Jiang, Penglei Sun, Xuwu Wang, Yanghua Xiao Member, IEEE, Nicholas Jing
Yuan Member, IEEE</li>
<li>Time: 11 Feb 2022</li>
<li>Journal: IEEE Transactions on Knowledge and Data Engineering</li>
</ul>
<p>22年多模态知识图谱综述。</p>
<span id="more"></span>
<h1 id="主旨">主旨</h1>
<h2 id="背景">背景</h2>
<h3 id="rdf">RDF</h3>
<p>RDF(Resource Description
Framework)，即资源描述框架，其本质是一个数据模型（Data
Model）。它提供了一个统一的标准，用于描述实体/资源。可以类比知识图谱的三元组。</p>
<h3 id="traditional-kg">Traditional KG</h3>
<p>Traditional KG is defined as a directed graph <span
class="math inline">\(\mathcal{G}=\{\mathcal{E,R,A,V,T_R,T_A}\}\)</span>.</p>
<ul>
<li><span class="math inline">\(\mathcal{E}\)</span>: entities</li>
<li><span class="math inline">\(\mathcal{R}\)</span>: relations</li>
<li><span class="math inline">\(\mathcal{A}\)</span>: attributes</li>
<li><span class="math inline">\(\mathcal{V}\)</span>: literal attribute
values</li>
<li><span class="math inline">\(\mathcal{T_R=E\times R\times
E}\)</span>, <span class="math inline">\(\mathcal{T_A=E\times A\times
V}\)</span> are sets of relation triples and attribute triples
respectively.</li>
</ul>
<h3 id="two-ways-for-representing-mmkg">Two Ways for representing
MMKG</h3>
<p>MMKG (Multi-Modal Knowledge Graph，多模态知识图谱)</p>
<figure>
<img data-src="/images/body/Papers/MMKG-Survey/Fig1.png" alt="Fig.1" />
<figcaption aria-hidden="true">Fig.1</figcaption>
</figure>
<ul>
<li><p><strong>A-MMKG</strong>: Taking multi-model data as particular
attribute values of entities or concepts, as shown in Fig.1(a).<br>
Denote as <span
class="math inline">\(\mathcal{G}=\{\mathcal{E,R,A,V,T_R,T_A}\}\)</span>
where <span class="math inline">\(\mathcal{T_A=E\times A\times
(V_{KG}\cup V_{MM})}\)</span> is the set of attribute triples,<br> <span
class="math inline">\(\mathcal{V_{KG}}\)</span> is the set of the KG’s
attribute values and <span
class="math inline">\(\mathcal{V_{MM}}\)</span> is the set of
multi-modal data.<br></p>
<blockquote>
<p>就是将原来的 <span class="math inline">\(\mathcal{T_A}\)</span> 中的
<span class="math inline">\(V\)</span> 并上多模态的数据。</p>
</blockquote></li>
<li><p><strong>N-MMKG</strong>: Taking multi-model data as entities in
KGs as the example shown in Fig.1(b).<br> Denote as <span
class="math inline">\(\mathcal{G}=\{\mathcal{E,R,A,V,T_R,T_A}\}\)</span>
where<br> <span class="math inline">\(\mathcal{T_R=(E_{KG}\cup
E_{MM})\times R\times (E_{KG}\cup E_{MM})}\)</span> is the set of
relation triples,<br> <span
class="math inline">\(\mathcal{E_{KG}}\)</span> is the set of KG
entities and <span class="math inline">\(\mathcal{E_{MM}}\)</span> is
the set of multi-modal data.<br></p>
<blockquote>
<p>将多模态数据拓展到实体集，当作实体考虑。</p>
</blockquote>
<p>Two images can also be associated in one of the following
relations:</p>
<ul>
<li>contain: One image entity visually contains another image entity by
the relative position of images.</li>
<li>nearBy: One image entity is visually nearby another image entity in
an image.</li>
<li>sameAs: Two different image entities refer to the same entity.</li>
<li>similar: Two image entities are visually similar to each other.</li>
</ul>
<p><br> In addition, in N-MMKGs an image is usually abstracted into a
number of image descriptors, which are usually summarized into feature
vectors of the image entity at pixel level, such as GHD
(灰度直方图描述符, Gray Histogram Descriptor), HOG (定向梯度直方图,
Histogram of Oriented Gradients Descriptor), CLD (颜色布局描述符, Color
Layout Descriptor) and so on.<br></p>
<blockquote>
<p>简单来说，N-MMKG中的图像是经过某些方法处理过后的特征向量。</p>
</blockquote></li>
</ul>
<p>Examples of A-MMKG and N-MMKG illustrated in Table.1.</p>
<figure>
<img data-src="/images/body/Papers/MMKG-Survey/Table1.png" alt="Table.1" />
<figcaption aria-hidden="true">Table.1</figcaption>
</figure>
<h3 id="multi-modal-tasks">Multi-Modal Tasks</h3>
<ul>
<li><em>Image Captioning. 图像描述.</em> Image captioning aims at
generating the descriptive caption for a given image.</li>
<li><em>Visual Grounding. 视觉定位.</em> Visual grounding aims at
locating an object with designated description in a given image.</li>
<li><em>Visual Question Answering (VQA). 视觉问答.</em> VQA aims at
generating a textual answer for a textual question with the help of a
relevant image.</li>
<li><em>Cross-Modal Retrieval. 跨模态检索.</em> There are two classic
cross-modal retrieval tasks including searching for images through a
text, and searching for texts through an image.</li>
</ul>
<h3 id="fundamental-challenges-of-multi-modal-learning">Fundamental
challenges of Multi-Modal Learning</h3>
<ul>
<li><p><em>Multi-modal Representation.</em> The multi-modal
representation uses the potential complementary of multi-modality to
learn feature representation.<br>
主要是两种方法，拼接和融合。拼接是将每种模态投射到各自的向量空间，如<strong>linear
correlation</strong>，再通过一些别的方法来将各个模态进行交融。融合是将所有模态全部投射到一个统一的空间，如<strong>VGG</strong>、<strong>ResNet</strong>。<br></p>
<blockquote>
<p>potential complementary:
指模态的潜在互补，每种模态都有一些别的模态没有的信息，如文字“这有一个男孩”，在图片中可以看出男孩的肤色是黑色，那么实际上我们知道这是一个黑人男孩。</p>
</blockquote></li>
<li><p><em>Multi-Model Translation.</em> Multi-modal translation learns
to translate from a source instance in one modality to a target instance
in another. <br> The example-based translation models build bridges
between different modality through dictionary, <br> while the generative
translation models build a more flexible model which can transform one
modal to another.</p></li>
<li><p><em>Multi-Model Alignment.</em> Multi-modal alignment aims to
find the correspondences between different modalities. <br> It can
either be directly applied in some multi-modal tasks such as visual
grounding, or be taken as a pre-training task in multi-modal pretrained
language models.</p></li>
<li><p><em>Multi-modal Fusion.</em> Multi-modal fusion refers to the
process of joining information from different modalities to perform a
prediction, <br> where various attention mechanism such as <strong>gated
cross-modality attention</strong>, <strong>bottom up attention</strong>
etc. are applied to model the interaction between different kinds of
features in the cross-modal module.</p></li>
<li><p><em>Multi-modal Co-Learning.</em> Multi-modal co-learning aims to
alleviate the low-resource problems in a certain modality by leveraging
the resources of other modalities through the alignment between
them.<br>
多模态联合学习通过多模态对齐利用其他类型的模态来缓解某一low-resource的模块。</p></li>
</ul>
<h3 id="multi-modal-pretrained-language-model">Multi-Modal Pretrained
Language Model</h3>
<p>Based on a large-scale unsupervised multi-modal data set with
text-image pairs, 许多工作都在学习多模态预训练语言模型 with designed
预训练自监督任务, including <strong>masked language model</strong>,
<strong>sentence image alignment</strong>, <strong>masked region label
classification</strong>, <strong>masked region feature
regression</strong>, <strong>masked object prediction</strong>, etc.
多模态预训练语言模型在下游任务中确实有效。</p>
<p>Can be divided into 1. <strong>single-stream models</strong> and 2.
<strong>two-stream models</strong>, in terms of the
<em>Transformer-based</em> fusion process of different modality.</p>
<ul>
<li><p>单流模型 Single-stream models, such as <strong>VL-BERT</strong>,
<strong>ViLT</strong>, input <em>all</em> modal information into
<em>a</em> single Transformer encoder for fusion by self-attention
modules.</p></li>
<li><p>双流模型 Two-stream models, such as <strong>LXMERT</strong>,
input <em>different</em> modal information into their <em>own</em>
encoders and fuse these representation from <em>different</em> modal
encoder by an additional cross-attention module.<br> The final output
representation not only contains the cross-modal interaction, but also
preserves the interaction within each modality.<br>
不仅包含了每个模块之间的交互，还保留了每个模块内部的交互。</p></li>
</ul>
<h3 id="mmkg-benefit-downstream-tasks">MMKG benefit downstream
tasks</h3>
<ol type="1">
<li>MMKG为实体与概念的表达补充足够丰富的background
knowledge，特别是那些long-tail ones 长尾问题。<br> long-tail: a few
classes(a.k.a. head class) occupy most of the data, while most
classes(a.k.a. tail class) have rarely few samples.
少数类(头类)占用大部分数据，而大多数类(尾类)只有少量的数据。</li>
<li>MMKG可以提升模型对图像中隐藏的物体的理解能力。Unseen object pose
great challenge for statistic based models.
这主要是利用符号知识提供的在视觉上不可见物体的符号信息，或在可见物体和不可见物体之间建立语义关系。</li>
<li>MMKG支持多模态推理。Multi-modal reasoning.</li>
<li>MMKG在一些NLP任务中，可以提供多模态数据作为附加特征来帮助弥合信息鸿沟。Take
entity recognition for example, an image could provide sufficient
infomation to identify whether "Rocky" is the name of a dog or a
person.</li>
</ol>
<h2 id="mmkg-construction.-mmkg的构建">MMKG Construction.
MMKG的构建</h2>
<p>MMKG构建的实质是将KG中的符号知识（实体、概念、关系等）与他们对应的图像相关联。有两种相反的方式来完成：1.
From images to symbols: Labeling images; 2. From symbols to images:
Symbol grounding.</p>
<figure>
<img data-src="/images/body/Papers/MMKG-Survey/Table2.png" alt="Table.2" />
<figcaption aria-hidden="true">Table.2</figcaption>
</figure>
<h3 id="from-images-to-symbols-labeling-images">From Images to Symbols:
Labeling Images</h3>
<p>The CV community has developed many <em>image labeling
solutions</em>, which could be leveraged in labeling images with
knowledge symbols in KG. Most image labeling solutions learn the
<strong>mapping</strong> from image content to a wide varity of label
sets (including objects, sences, entities, attributes, relations, events
and other symbols).<br> The learning procedure is supervised by a human
annotated data set, seen Fig.2.</p>
<figure>
<img data-src="/images/body/Papers/MMKG-Survey/Fig2.png" alt="Fig.2" />
<figcaption aria-hidden="true">Fig.2</figcaption>
</figure>
<p>Table.2(a) lists some well-known image-based visual knowledge
extraction systems constructed. 这些系统可以通过图像标注来构建MMKG。
According to <em>the category of symbols to be linked</em>, the process
of linking images to symbols could be divided into several fractionized
tasks:</p>
<ol type="1">
<li><strong>visual entity/concept extraction</strong>: Aim to detect and
locate target visual objects in images, and then label these objects
with entity/concept symbols in KGs.
从图像中识别实体并用KG中的entity标记;</li>
<li><strong>visual relation extracion</strong>: Aim at identifying
semantic relations among detected visual entities/concepts in images,
and then labeling them with the relations in KGs.
识别已识别的实体之间的语义关系并用KG中的relation标记;</li>
<li><strong>visual event extraction</strong>: Aim at 1) predicting the
visual event types and 2) locating and exacting objects in source images
or videos as visual arguments.
预测视觉事件类型，定位并提取对象作为可视参数。
<ul>
<li>EVENT: dynamic interaction among arguments, including a trigger and
several arguments with their corresponding argument roles.</li>
<li>Trigger: a verb or a noun indicating the occurrence of an
event.</li>
<li>Argument role: the semantic relation between an event and an
argument such as <em>Time</em>, <em>Person</em>, <em>Place</em>.</li>
</ul>
<blockquote>
<p>如“我在十点半睡觉”是一个event，<em>睡觉</em>是trigger，argument是<em>十点半</em>，argument
role是Time，另外<em>我</em>也可以是argument，这时argument
role就是Person。</p>
</blockquote></li>
</ol>
<h4 id="visual-entityconcept-extraction-视觉实体概念提取">Visual
Entity/Concept Extraction 视觉实体/概念提取</h4>
<h5 id="challanges">Challanges</h5>
<p>The main challenge with this task lies on how to learn an effective
fine-grained extraction model without a large-scale, fine-grained,
well-annotated concept and entity image dataset. <br>
CV中虽然有丰富的标注良好的图像数据，但这些数据集几乎都是粗粒度coarse-grained的概念图像，无法满足MMKG构建对细粒度概念和实体图像标注数据的要求。</p>
<blockquote>
<p>CV图像分类中的细粒度/粗粒度(fine-grained/coarse-grained):
粗粒度指类别之间差异大，如人、汽车、树；细粒度指类别之间差异小，如200种鸟的分类、100种花的分类。<br>
由于细粒度类别属于同一个大类，所以各类别之间的差距很小，这些细微的差距容易被光照、颜色、背景、形状和位置等变化因素覆盖，导致细粒度图像分类相对困难。</p>
</blockquote>
<h5 id="progresses">Progresses</h5>
<p>Existing efforts could be roughly divided into two categories: <br>
1) object recognition methods, which label a visual entity/concept by
classifying the region of a detected object; and<br> 2) visual grounding
methods, which label a visual entity/concept by mapping a word or phrase
in a caption to the most relevant region.</p>
<p>对象识别方法对检测到对象的区域进行分类，来标记视觉实体/概念；视觉定位是将标题中的单词或短语映射到图像中最相关的区域。这两个的侧重点分别是<strong>从图像区域到实体</strong>，一个是<strong>从实体到图像区域</strong>。</p>
<h6 id="object-recognition-methods">Object Recognition methods</h6>
<p>早期工作中，提供的图片基本都只有一个物体，但现实生活中的图像往往十分复杂，以至于无法用仅仅一个label来表示。为了识别多个视觉实体，我们需要预训练的检测器和分类器来标注视觉实体（以及属性及场景）及其在图像中的位置。<br>
检测器的训练数据都是有监督数据，主要来自public image-text datasets(such
as <strong>MSCOCO</strong>, <strong>Flickr30k</strong>, <strong>Flick30k
Entities</strong> and <strong>OpenImages</strong>)或预标注的种子图像
pre-labeled seed images.</p>
<p>在检测过程中，检测器捕获一组可能对象的候选区域region
proposals，并挑出实际包含对象的候选。在检测到的区域中，预先训练的分类器识别具有entity-level(例如BMW
320)或concept-level(例如Car)标签的候选视觉对象。</p>
<p>被识别出来的实体一般不会直接被认为是visual
entities，这是因为一般会有大量重复的实例 at different view points,
positions, poses and appearances. 因此我们一般会选择最具有代表性的
visual object 作为 visual entitiy。<br>
最常用的方法是对选出来的图像区域进行聚类，每个聚类的中心就被认为是一个新的
visual entity。</p>
<p>缺点：当该方案需要生成大量labels时，需要很多的预处理工作，比如预训练的规则、预确定的实体列表、预训练的细粒度检测器和分类器等，这会导致该方案的鲁棒性scalability下降。</p>
<h6 id="visual-grounding-method">Visual Grounding Method</h6>
<p>视觉实体提取问题简化为开域视觉定位问题，即定位标题中的每个短语对应的图像区域，从而获得图像中的视觉对象及其标签。</p>
<blockquote>
<p>一般在visual entity extraction中，训练用的 labeled data 需要 with
bounding boxes and pre-defined schema with a fixed set of concept, which
is difficult to be used for large-scale visual knowledge
acquisition.<br> 幸运的是，Web上有很多image-captions pairs，来为visual
knowledge extraction提供<strong>弱监督weakly supervise</strong> without
relying on the labeled bounding boxes.</p>
</blockquote>
<blockquote>
<p>As illustrated in Fig.3 below, weakly supervised learning mainly
includs three classical categories:<br> 1) 不完全监督 Incomplete
supervision:
训练数据中只有一部分数据被给了标签，有一些数据是没有标签的。<br> 2)
不确切监督 Inexact supervision: 训练数据只给出了粗粒度标签。<br> 3)
不精确监督 Inaccurate supervision: 给出的标签不总是正确的。<br> <img
src="/images/body/Papers/MMKG-Survey/Fig3.png" alt="Fig.3" />
在实际操作中，这三类经常同时发生。</p>
</blockquote>
<blockquote>
<p>关于弱监督学习可以参考周志华 《A Brief Introduction to Weakly
Supervised Learning》（2018.1）</p>
</blockquote>
<p>当从弱监督的图像标题对重提取信息时，通常根据<strong>空间热力图</strong>(shown
as Fig.4)直接选择给定单词的活动像素作为视觉对象的区域。</p>
<figure>
<img data-src="/images/body/Papers/MMKG-Survey/Fig4.png" alt="Fig.4" />
<figcaption aria-hidden="true">Fig.4</figcaption>
</figure>
<p>在同一语义空间中的文本、图像表示，每个短语的热图可以通过<strong>基于注意力的方法</strong>和<strong>基于显著性的方法</strong>作为跨模态权重来学习，shown
as Fig.5。</p>
<figure>
<img data-src="/images/body/Papers/MMKG-Survey/Fig5.png" alt="Fig.5" />
<figcaption aria-hidden="true">Fig.5</figcaption>
</figure>
<ol type="1">
<li>在训练时，基于显著性的方法通过梯度计算，直接将像素对给定短语的敏感度视为热力图的值。</li>
<li>基于注意力的方法将跨模态相关性视为热力图的值，与基于显著性的方法相比，其更受欢迎。</li>
</ol>
<blockquote>
<p>有的热图是根据标题中提到的每个实体的图像区域之间的相似性生成的，
而有的热图是根据图像区域与可能的事件参数角色类型之间的相似性生成的。</p>
</blockquote>
<blockquote>
<p>在测试时，对热图进行阈值设置，以获得可视对象的合适包围框。如果kg中已有视觉实体/概念的边界框与新的边界框没有重叠，则将该边界框创建为新的视觉实体或概念。</p>
</blockquote>
<p>尽管视觉定位方法不依赖于带有边界框的标记数据，但实际上仍需要人工验证。
一些工作试图在训练阶段增加对常识、关系和事件参数的约束，以增加监督信息。
在与MMKG的构建相关的工作中，视觉定位的精确度低于 70%。</p>
<p>通过视觉定位的视觉对象可以是实体（例如 Barack Hussein
Obama）、概念（例如地点、汽车、石头）、属性（例如红色、短）。然而，图像和文本的语义尺度不一致可能导致不正确的匹配。例如，<strong>troops</strong>可能会映射到<strong>several
individuals wearing military uniforms</strong>，而<strong>Ukraine
(country)</strong>可能会映射到<strong>Ukrainian
flag</strong>，这两者都是相关的但并不等同。</p>
<h5 id="opportunities">Opportunities</h5>
<p>随着多模态预训练语言模型的出现，多模态预训练语言模型强大的表示能力增强了提取实体和概念的能力。
图像块和单词的映射可以直接在模型的自注意力图中可视化，而无需额外的训练。
ViLT 的预测示例如图 6 所示。多模态预训练语言模型如
CLIP，在数亿网络规模的图像-文本数据上进行了预训练，在著名人物和地标建筑上具有很高的准确性，这将在构建一个MMKG人物或建筑时减少大量的数据收集和模型训练工作量。一些预训练的视觉转换器模型已经具有很强的视觉对象分割能力，即使在高度模糊的情况下也能聚焦于前景对象，例如
DINO ，这将提高定位视觉对象和对齐跨模态知识的性能。</p>
<figure>
<img data-src="/images/body/Papers/MMKG-Survey/Fig6.png" alt="Fig.6" />
<figcaption aria-hidden="true">Fig.6</figcaption>
</figure>
<h4 id="visual-relation-extraction-视觉关系提取">Visual Relation
Extraction 视觉关系提取</h4>
<h5 id="challanges-1">Challanges</h5>
<p>虽然视觉关系检测在CV社区已经得到了广泛的研究，但大多数检测到的关系都是视觉对象之间的表面视觉关系，如(person,
standing on,
beach)。不同的是，为了构建MMKG，视觉关系提取任务旨在识别在kg中定义的更一般的语义关系类型，如(Jack,
spouse, Rose)。</p>
<h5 id="progresses-1">Progresses</h5>
<p>现有的工作大致可分为<strong>基于规则的关系抽取</strong>和<strong>基于统计的关系抽取</strong>，其余的一些工作主要集中在长尾关系和细粒度关系上。</p>
<h6 id="rule-based-relation-extration">Rule-based Relation
Extration</h6>
<p>传统的基于规则的方法主要关注一些特定类型的关系，如空间关系和动作关系。这些规则通常由专家预先定义，判别特征通过启发式方法进行评分和选择。</p>
<p>在基于规则的方法中，要检测的关系是根据标签的类型和区域的相对位置来定义的。例如，如果一个对象的边界框总是在另一个对象的边界框内，则它们之间可能存在
PartOf 关系。表 3
列出了在NEIL中检测到的几种视觉关系。提取过程中，检测到的一对对象之间的关系反过来又会对新实例标记的附加约束。例如，“Wheel
is a part of Car”表示 Wheel 更有可能出现在 Car
的边界框中。基于规则的方法提供高度准确的视觉关系，但它们依赖于大量的手动工作。所以在大规模MMKG建设中是不实用的。</p>
<figure>
<img data-src="/images/body/Papers/MMKG-Survey/Table3.png" alt="Table.3" />
<figcaption aria-hidden="true">Table.3</figcaption>
</figure>
<h6 id="statistic-based-general-relation-extration">Statistic-based
General Relation Extration</h6>
<p>基于统计的方法将检测到的对象的视觉特征、空间特征和统计等特征编码为分布式向量，并通过分类模型预测给定对象之间的关系。与基于规则的方法相比，基于统计的方法能够检测到训练集中出现的所有关系。</p>
<p>一些工作证明谓词在很大程度上依赖于主客体的类别，但主客体不依赖于谓词，主客体之间也没有依赖关系。
例如，在三元组（人、骑、大象）中，人和大象表示关系可能是骑而不是穿。因此，为了利用依赖关系，一些工作通过对象的标签将语言模型的语言先验添加到统计模型中，设置了一个更严格的约束，即三元组的隐藏层表示应满足主语
+ 谓词 <span class="math inline">\(\approx\)</span>
宾语。令人尴尬的是，语言模型带来很大的改进，但视觉信息的贡献却很小。</p>
<p>图像中检测到的对象和关系可以表示为图。图结构使边能够从其他节点和边中获得更多消息，从而以更高的精度对关系进行分类。例如，对象和关系可以表示为两个互补的子图，其中节点根据周围边的值迭代更新，反之亦然。
一些工作使用注意力图卷积神经网络来学习上下文对象和边。</p>
<h6 id="long-tail-and-fine-grained-relation-extraction">Long-tail and
Fine-grained Relation Extraction</h6>
<p>尽管基于统计的方法能够检测一般关系，但很难检测长尾关系。原因是具有大量样本的有偏差的数据集使得预测关系更加困难。为了消除训练集中不平衡样本的影响，为了消除训练集中不平衡样本的影响，学者提出了一种新的无偏度量(Mean
Recall@K)来平均所有类型关系的召回率，而不是所有样本的召回率，避免忽略只有少量样本的关系。还有很多其他的工作，主要是通过迁移学习、少镜头学习和对比学习来检测少量样本的关系，但仍然局限于隐层的特征融合。</p>
<p>细粒度关系是一种长尾关系。现有的从特征融合角度对长尾关系问题的研究未能很好地区分细粒度的关系。例如，例如，模型倾向于预测“on”而不是细粒度的关系“sit
on”/"walk on"/"lay on"。</p>
<p>检测更复杂和细粒度的关系更困难，例如人与对象交互和动作检测。因为一个人的姿势是由身体的许多组成部分决定的。例如，(person,
play, violin) 和 (person, hold, violin)
的图像之间存在细微差别。在早期研究中，动作被定义为身体不同部位的一系列姿态，并通过启发式方法挖掘识别特征。在目前基于统计量的检测中，判别特征采用更严格的对比损失函数滤波，但显然仍过于粗糙。</p>
<h5 id="opportunitiies">Opportunitiies</h5>
<p>尽管现有的工作很多，但仍有许多具有挑战性的问题没有解决。例如：</p>
<ol type="1">
<li><p><strong>视觉知识关​​系判断</strong>
许多从图像中提取的视觉三元组只描述了图像的场景，由于它们不是被广泛接受的事实，因此不能被视为视觉知识。难点在于我们如何从场景信息的三元组中识别视觉知识的三元组。</p></li>
<li><p><strong>基于推理的关系检测</strong>
现有的关系检测方法通过融合视觉特征和语言先验的隐藏统一表示来预测关系。例如，如果一个图像中有一个人和一个足球，并且(head,
look at, sth) (arm, swing, -) (foot, kick, sth)
同时满足，则该动作将被判断为(person, kick,
football)。不幸的是，这个数据集是手动构建的。我们需要自动总结关系检测的推理链。</p></li>
</ol>
<h4 id="visual-event-extraction-视觉事件提取">Visual Event Extraction
视觉事件提取</h4>
<p>视觉事件提取可以分为两个子任务:</p>
<ol type="1">
<li>预测视觉事件类型;以及</li>
<li>定位和提取源图像或视频中的对象作为可视参数</li>
</ol>
<h5 id="challenges">Challenges</h5>
<p>该任务面临以下几个挑战:</p>
<ol type="1">
<li>视觉事件提取需要对不同的事件类型预先定义模式，但大量的视觉事件还没有被专家定义。如何将视觉模式自动挖掘为事件模式?</li>
<li>如何从图像或视频中提取视觉事件的视觉论据?</li>
</ol>
<h5 id="progresses-2">Progresses</h5>
<p>当前工作主要focuses on两个方面: 1)
视觉事件模式挖掘，将最相关的视觉实体（或概念）检测并标记为新模式； 2)
视觉事件参数提取，根据事件模式从视觉数据中提取参数角色区域。</p>
<h6 id="visual-event-schema-mining">Visual Event Schema Mining</h6>
<p>例如，事件 Clipping 具有诸如 Agent、Source、Tool、Item、Place
等参数角色，并且在剪羊毛的图像中它们分别是
Man、Sheep、Shears、Wool、Field。该任务主要旨在识别视觉事件，而不是定位和提取其视觉参数。</p>
<p>然而，在大规模的可视化事件提取中（如新闻），许多事件的视觉图式还没有被手动定义，这需要大量专家的工作。</p>
<p>来自Internet的大量图像标题对使得挖掘和标记事件模式的视觉模式成为可能。因此，此任务简化为从给定事件的图像中查找指示正确事件类型的视觉模式的频繁项集。可以从带有事件触发器的图像标题对中检索事件的图像集合作为查询。通过视觉定位的方法，将候选图像补丁用文字或短语标注在字幕中。可以利用启发式方法(如Apriori算法)挖掘频繁的视觉图像补丁，找到关联规则，通过视觉模式预测事件类型。</p>
<h6 id="visual-event-arguments-extraction">Visual Event Arguments
Extraction</h6>
<p>视觉事件参数提取实际上是提取一组具有关系约束的视觉对象的任务。视觉参数可以通过完全监督方法(如对象识别)或弱监督方法(如视觉基础)进行标记。根据视觉事件提取的两个子任务，根据事件图像的全局特征对事件类型进行分类，并将事件参数提取为对事件类型最敏感的局部区域。</p>
<p>但是，在弱监督方法中，我们不能确定所提取的视觉对象之间的关系是否与文本中的关系一致。因此，视觉参数和文本参数的关系也应该分别对齐。有的工作将从一个事件的图像中提取的情景图与抽象意义表示图(AMR图)对齐，AMR图根据跨模态参数的语义和类别表示该事件标题的语义结构。联合提取中还增加了语义、事件类型、事件参数角色、视觉信息和文本信息一致性等诸多约束条件。</p>
<p>与图像相比，视频更适合于事件提取，因为一个事件的时间包围框可能跨越整个视频，所有的参数可能不会在一帧中显示。为了简化任务，可以从只包含一个事件的短视频片段中提取了三个关键帧的参数，这些关键帧是与视频标题最匹配的帧。</p>
<h5 id="opportunities-1">Opportunities</h5>
<p>这一课题的研究还处于早期阶段，还有很多问题值得探索。例如:</p>
<ol type="1">
<li>从包含多个事件的长视频中提取连续事件的问题还没有解决。</li>
<li>多子事件视频事件提取。例如，将“煮咖啡”事件分为清洁咖啡机→倒入咖啡豆→打开咖啡机等一系列步骤，每一步也可以视为一个事件。顺序步骤需要按照步骤的时间轴进行提取和列出，这是目前方法难以解决的问题。</li>
</ol>
<h3 id="from-symbols-to-images-symbol-grounding">From Symbols to Images:
Symbol Grounding</h3>
<p>符号定位是指寻找合适的多模态数据项(如图像)来表示传统KG中存在符号知识的过程。与图像标注方式相比，符号接地方式在MMKG施工中应用更为广泛。大多数现有的MMKG都是这样构造的。</p>
<p>We cover the process of grounding symbols to images in several
fractionized tasks: <strong>Entity Grounding</strong>, <strong>Concept
Grounding</strong>, <strong>Relation Grounding</strong>.</p>
<h4 id="entity-grounding">Entity Grounding</h4>
<p>实体定位旨在将知识图谱中的文本实体定位到其相应的多模态数据，例如图像、视频和音频。</p>
<h5 id="challenges-1">Challenges</h5>
<ol type="1">
<li>如何以低成本为实体找到足够多的高质量图像？</li>
<li>如何从大量噪声中选择最匹配实体的图像？</li>
</ol>
<h5 id="progresses-3">Progresses</h5>
<h6 id="from-online-encyclopedia-such-as-wikipedia">From Online
Encyclopedia (such as Wikipedia)</h6>
<p>在维基百科中，一篇文章通常用图像和其他多模态数据来描述一个实体。
Wikipedia 和 DBpedia 提供了许多工具（例如 Wikimedia Commons ）来帮助在
DBpedia 中的实体与 Wikipedia
中的相应图像或其他模态数据之间建立连接。研究人员很容易使用像维基百科这样的在线百科全书来构建大规模
MMKG 的第一个版本。</p>
<p>然而，基于百科全书的方法有三个主要缺点：</p>
<ol type="1">
<li>首先，每个实体的图像数量是有限的。维基百科中每个实体的平均图像数量为
1.16。</li>
<li>其次，维基百科中的许多实体图像仅与其对应的实体相关，而不是与实体完全相关。例如，维基百科中北京动物园的图片中存在动物、建筑、牌匾、雕刻等多张图片，很容易导致语义漂移。</li>
<li>最后，基于维基百科构建的MMKG的覆盖范围仍有待提高。英文维基百科有600万个实体（文章），这是从英文维基百科收获的MMKG容量的上限。根据我们的调查，近
80%的英文维基百科文章没有对应的图像，其中只有 8.6 %有超过 2
个图像。</li>
</ol>
<h6 id="from-the-internet-through-web-search-engines">From The Internet
Through Web Search Engines</h6>
<p>为了提高 MMKG
的覆盖率，提出了基于搜索引擎的解决方案。通过查询实体名称从搜索引擎的搜索结果中找到图像。一般来说，排名靠前的结果图像很有可能是要搜索的实体的正确图像。然而，基于搜索引擎的方法很容易将错误的事实引入
MMKG。众所周知，搜索引擎结果可能是嘈杂的。另一个原因是指定搜索关键字并非易事。例如，搜索查询“Bank”不足以找到
Commercial Bank 的图像，因为它也产生了 River Bank
的图像。因此，已经有很多清理候选图像的工作。通常通过添加父同义词集或实体类型来扩展查询词以消除歧义。在为实体选择最佳图像时，多样性也是不可忽视的问题。训练图像多样性检索模型以去除冗余的相似图像，使图像尽可能多样化。</p>
<p>由于在构建过程中实体及其视觉特征的解耦，基于实体接地的MMKG具有区分视觉相似实体的能力，如图7所示。实体定位方法使得构建面向领域的细粒度MMKG成为可能。</p>
<figure>
<img data-src="/images/body/Papers/MMKG-Survey/Fig7.png" alt="Fig.7" />
<figcaption aria-hidden="true">Fig.7</figcaption>
</figure>
<p>与基于百科全书的方法相比，基于搜索引擎的方法覆盖面更好，但质量更差，因此这两种方法经常一起使用。例如，可以通过从搜索引擎为每个实体收集更多图像或将每个图像映射到它包含的所有实体以扩大实体图像的数量来提高从维基百科获取的
MMKG 的覆盖范围。</p>
<h5 id="opportunities-2">Opportunities</h5>
<p>这个方向还有很多未解决的问题。 1)
实体被定位成几个图像，每个图像只是实体的一个方面。例如，一个人的图像集合可以是不同年龄的图像、生活照片、事件照片、单人照片和家庭照片。如何确定最典型的图像？图8以特朗普为例。</p>
<figure>
<img data-src="/images/body/Papers/MMKG-Survey/Fig8.png" alt="Fig.8" />
<figcaption aria-hidden="true">Fig.8</figcaption>
</figure>
<ol start="2" type="1">
<li>现实世界的实体是多角度的，在不同的上下文中将一个实体与多个图像相关联是合理的。这促使我们提出一项新的多定位任务，该任务从给定特定上下文的实体中选择最相关的图像。例如，美国第
45 任和现任总统唐纳德·特朗普 (Donald Trump)
拥有许多可以从网络上收集的不同图像。但如图 8
所示，任何单个图像都不适用于所有不同的上下文。然而，将实体的不同方面映射到不同上下文中最相关的图像并非易事。首先，实体的图像池很难建立，因为图像池的完整性无法保证，在某些上下文中很容易漏掉一些相关的图像。其次，为特定上下文的实体消歧图像具有挑战性，因为上下文通常是嘈杂的并且包含稀疏信息，并且需要更多的背景信息来指导语义信息的获取。最后，作为一项新任务，标记数据的缺乏是一个大问题。</li>
</ol>
<h3 id="concept-grounding">Concept Grounding</h3>
<p>概念定位旨在为视觉概念找到具有代表性的、有区别的和多样化的图像。</p>
<h4 id="challenges-2">Challenges</h4>
<p>虽然一些视觉上统一的概念（如男人、女人、卡车和狗）也可以使用实体定位方法连接到图像。然而</p>
<p>1）并非所有的概念都可以正确可视化。例如，irreligionist（非宗教主义者）不能指定某种具体醒醒。因此，如何区分可视化概念和非可视化概念成为一个难点</p>
<p>2）如何从一组相关图像中找到一个可视化概念的代表性图像？请注意，可视化概念的图像可能非常多样化。例如，一提到公主，人们往往会想到几种不同的形象，迪士尼公主、历史电影中的古代公主或新闻中的现代公主。因此，我们必须考虑图像的多样性。</p>
<h4 id="progresses-4">Progresses</h4>
<p>针对上述挑战，相关研究分为三个任务：<strong>可视化概念判断</strong>、<strong>代表性图像选择</strong>和<strong>图像多样化</strong>。</p>
<h5 id="可视化概念判断">可视化概念判断</h5>
<p>该任务旨在判断概念是否可视化，研究人员发现只有 12.8 %的 Person
子树的同义词集具有公认的可视化性。并且许多其余同义词集没有相应的视觉描述。例如，摇滚明星是可视化的，而求职者是不可视化的。手动注释在构建大规模
MMKG 时明显不实用。</p>
<p>为了自动判断视觉概念，研究人员构建了以下方法，比如：认为抽象名词概念是非可视化的，只收集非抽象名词概念的图像。但是，这些方法都不是很准确。例如，愤怒或快乐可以指定为一个人感到愤怒或快乐的形象。由于图像来自互联网，因此可以使用搜索引擎点击来识别视觉概念。例如，如果谷歌图片点击的数量大于谷歌网络点击的数量，可以表明一个实体可能是可视化的。</p>
<p>此外，可视化的高质量图像的一些特征可以用来识别视觉概念，例如代表性和辨别性。
一些研究人员认为具有代表性图像的前景是相似的，前景易于与背景分离，并且具有较小的类间方差。因此，因此考虑反过来训练分类器来选择其图像集合具有这些特征的概念。</p>
<h5 id="代表性图像选择">代表性图像选择</h5>
<p>该任务本质上旨在根据图像的代表性重新排列图像。图像的代表性是根据基于聚类的方法的结果来评分的，例如
K-means、谱聚类等。聚类内的方差越小，聚类中图像的得分越高。在对图像的代表性得分重新排序后，排在前面的可能是代表性图像。此外，图像也受到规则的约束，以区分不同的簇。例如，一些工作添加了一个新的度量标准来对图像和聚类内的相似度进行排序，即类间距离和类内距离的比率，比率越大，图像的判别力越强。</p>
<p>来自搜索引擎的图像的标题和标签也可以用来评估图像在语义层面的代表性和区分性。标题和标签提供图像没有的语义信息。例如，一张冰岛风景的照片和一张英国风景的照片可能看起来很相似，但文本标签可以帮助我们区分它们的概念差异。一些工作中，标签基于语义特征进行聚类，图像根据标签的语义聚类重新分配到每个聚类中。</p>
<h5 id="多样化图像选择">多样化图像选择</h5>
<p>该任务要求以概念为基础的图像应平衡多样性和相关性。图像也应该在聚类后重新排序，但与代表性图像选择的区别在于，我们想展示尽可能多的集群的结果。
具体来说，在每次选择中，尽量从聚类中选择没有被选择的图像。</p>
<p>这些研究集中在文本图像检索领域，很少有与多模态知识图谱相关的研究。来自互联网的关于性别、种族、肤色和年龄的概念图像的多样性仍然存在许多未解决的偏见，现在这个问题在很大程度上依赖于众包。</p>
<h4 id="opportunities-3">Opportunities</h4>
<h5 id="抽象概念定位">抽象概念定位。</h5>
<p>以前关于概念可视化判断的工作很少考虑抽象概念。但抽象的概念也可以以图像为基础。例如，快乐通常与微笑联系在一起，而愤怒通常与愤怒的脸联系在一起。一些抽象名词具有多样而固定的视觉联想，如自然、人、行为等。例如，“美”的图像与以下词群相关:女人/女孩、水/海滩/海洋、花/玫瑰、天空/云/日落。同样，爱的形象与以下词群相关:婴儿/可爱/新生儿，狗/宠物，心/红/情人节，海滩/海/情侣，天空/云/日落，花/玫瑰。可以看出，一些抽象名词在情感上往往具有一般的、固定的意象，在语义上往往具有辨别性的意象。</p>
<h5 id="动名词概念基础">动名词概念基础。</h5>
<p>动名词是一类特殊的名词，可以转化为动词，如singing→sing。通过众包将许多动名词与图片联系起来，例如争吵、摔跤和跳舞。这些涉及人际交往的动词对人的身体角度、注视角度、关节位置和表情等特征较为敏感。</p>
<h5
id="通过实体定位的非可视化概念定位">通过实体定位的非可视化概念定位。</h5>
<p>如果一个概念是非可视化的，但这个概念的实体是可以可视化的，那么这个概念也可以通过它的实体来建立基础。例如，合理选择这样一个概念的接地图像是使用该概念最典型实体的图像。如使用一张爱因斯坦的照片作为物理学家这个概念的基础。这是合理的，因为当我们提到物理学家时，我们大多数人都会想到爱因斯坦。但是，目前还存在许多未解决的问题:(a)一般来说，不同的人对一个概念的思考具有不同的典型实体，因此在概念的基础上要解决这种主观性。一个实体在其概念的约束下是否是一个典型的实体?(b)我们应该选择几个典型实体的图像来表达这个概念。如何总结和选择典型实体来表示概念?(c)我们是否应该从多个实体图像中提取共同的视觉特征?</p>
<h3 id="relation-grounding">Relation Grounding</h3>
<p>关系定位是从图像数据语料库或互联网中找到可以表示特定关系的图像。输入可以是这个关系的一个或多个三元组，输出应该是这个关系中最具代表性的图像。</p>
<h4 id="challenges-3">Challenges</h4>
<p>当我们将三元组作为查询来检索关系的图像时，排名靠前的图像通常与三元组的主题和对象更相关，但与关系本身无关。如何找到能够反映输入三元组语义关系的图像？</p>
<h4 id="progresses-5">Progresses</h4>
<p>现有的关系指定研究侧重于空间或动作关系，例如left of、on、ride
和eat。</p>
<p>虽然文本问询可以通过抽象语义表示图（主题、关系、对象）的格式表示为结构化数据，但候选图像也可以结构化为场景图。然后，通过文本-图像匹配或图形匹配，可以将结构化文本和结构化图像进行细粒度匹配，下面将具体展开。</p>
<h5 id="文本图像匹配">文本图像匹配</h5>
<p>在文本-图像匹配任务中，文本和图像通常表示为统一语义嵌入空间中的向量。通过跨模态表示的相似度得分找到与查询最匹配的图像。跨模态表示通常由注意力机制融合，因此全局表示的缺点是缺乏显式细粒度关系的语义。除了基于表示的检索之外，一种更方便的方法是基于标题的检索，如互联网上的搜索引擎。基于标题的检索的缺点是没有使用视觉特征进行匹配。</p>
<p>为了表示对象之间的明确关系，许多研究集中在考虑图像局部结构的图像编码器上。最终的图像表示是全局视觉特征、局部结构特征和文本对齐嵌入的融合。一些工作将所有一阶（实体或概念）、二阶（属性或动作）、三阶（三元组）事实均统一遵循
建模，分别由多层图像编码器的不同分支的输出来表示。
一些研究使用场景图来表示图像中的所有三元组
，并使用图卷积神经网络来学习视觉关系。最后，每张图像学习到的​​所有具有关系特征的视觉表示都必须接近。因此，可以通过使用三元组作为查询而不是句子来直接检索匹配的图像。</p>
<p>多模态预训练语言模型是考虑对象（实体或概念）和三元组的图像编码器的新替代方案。对于每个图像-标题对，使用场景图解析器从图像的标题中生成包含对象、属性和关系的场景图，然后将场景图的对象、属性和关系节点随机替换为与对应的词汇表不同的对象、属性或关系来生成大量的硬负样本。
ERNIEViL通过增加三个预训练任务，对象预测、属性预测和关系预测来增强视觉和语言模型的能力。</p>
<h5 id="图匹配">图匹配</h5>
<p>我们期望通过对象和关系的显式匹配而不是统一的跨模态嵌入的隐式匹配来建立关系基础。一种更方便的方法是基于标题的检索，如
Internet 上的搜索引擎，匹配实体的标记与
问询与标题之间的关系。基于标题的检索的缺点是没有使用视觉特征进行匹配。例如，Richpedida
提出了一个非常强的假设，即如果 Wikipedia
描述中的两个实体之间存在预定义的关系（例如 nearBy 和
contains），则两个实体对应的视觉实体之间也存在相同的关系。但实际上，这两个对象更有可能不会同时出现在一张图像中。如果我们将文本查询和候选图像表示为图形，则关系指定任务变成了图形匹配任务，如图
9
所示。可以将图像结构化为图形，其中节点是对象，边是关系。文本问询中的依赖关系可以建模为依赖分析树，它也是一个图。一个简单的解决方案是只匹配两个图中的对象和共现关系而不预测关系类型，即假设如果两个实体之间存在关系，则该关系被认为是匹配的，这也是一个强假设。显然，关系预测模块是必不可少的。
一些研究用GCN分别表示两个场景图，其中对象自己进行更新，关系节点从其邻居的聚合更新。预测时，分别测量两个不同形式的图的相似度：对象节点匹配和关系节点匹配。</p>
<figure>
<img data-src="/images/body/Papers/MMKG-Survey/Fig9.png" alt="Fig.9" />
<figcaption aria-hidden="true">Fig.9</figcaption>
</figure>
<h4 id="opportunities-4">Opportunities</h4>
<p>现有研究主要集中在空间关系和动作关系的基础上，这些关系可以在图像中直观地观察到。但是，大多数其他关系例如isA,
Occupation, Team and
Spouse在图像中可能并不明显。这些关系通常缺乏训练数据，因此很难用上述两种解决方案训练模型来检索图像。</p>
<h1 id="总结分析">总结/分析</h1>
<h2
id="多模态知识图谱综述链接预测部分参考文献">多模态知识图谱综述链接预测部分参考文献：</h2>
<ul>
<li>134 Translating embeddings for modeling multi-relational data
<strong>2013</strong> 就是TransE。</li>
<li>136 Learning entity and relation embeddings for knowledge graph
completion <strong>2015</strong> 是TransR。</li>
<li>141 Representation learning of knowledge graphs with entity
descriptions <strong>2016</strong> 具有实体描述的知识图谱表示学习。</li>
<li>142 Modeling relation paths for representation learning of knowledge
bases <strong>2015</strong> PTransE 对多跳关系的建模。</li>
<li>143 Reasoning with neural tensor networks for knowledge base
completion <strong>2013</strong>
如果两实体名字中有相同的字符串，比如apple pie和apple
cake，以往的工作中他们的嵌入是没有什么关系的，这篇以全新的方式（词向量的平均值）来嵌入实体，并且提出了新的神经网络结构ntn。</li>
</ul>
<p>以上都是单一模态知识图谱的工作，下面的才是多模态的：</p>
<ul>
<li><p>138 A multimodal translation-based approach for knowledge graph
representation learning <strong>2018</strong>
有点像是多模态的transE，主要将多模态信息与图谱结构相结合，三种融合方式，将文本信息与多模态信息拼接，将文本信息映射到多模态信息空间中，将多模态信息映射到文本信息空间中。设计了一个打分（能量）函数。别的没有什么特殊的地方。</p></li>
<li><p>144 Image-embodied knowledge representation learning
<strong>2016</strong>
IKRL是第一个将图像中的视觉信息显式编码为知识表示的尝试。</p></li>
<li><p>140 Embedding multimodal relational data for knowledge base
completion <strong>2018</strong>
提出了多模态知识库嵌入（MKBE），它对这些观察数据使用不同的神经编码器，并将它们与现有的关系模型相结合，以学习实体和多模态数据的嵌入。使用这些学习的嵌入和不同的神经解码器，引入了一种新的多模态插补模型，以从知识库中的信息生成缺失的多模态值，如文本和图像。</p></li>
<li><p>23 Answering visual-relational queries in web-extracted knowledge
graphs <strong>2017</strong>
基于FB15k构建了一个ImageGraph，使用卷积提取视觉特征然后和知识图谱嵌入相结合。<strong>给定一个不属于已知kg的图像，该模型可以给出其与另一个给定图像的关系，但我们并不知道他们对应的实体是什么</strong></p>
<ol type="1">
<li>给定一对不可见的图像，我们不知道它们的KG实体，确定潜在实体之间的未知关系。</li>
<li>给定一个不可见的图像(我们不知道其底层KG实体)和一个关系类型，确定完成查询的可见图像</li>
<li>给定一个不属于KG的全新实体的不可见图像，以及一个我们不知道底层KG实体的不可见图像，确定两个底层实体之间未知的关系。</li>
<li>给定一个不属于KG的全新实体的不可见图像和一个已知的KG实体，确定两个实体之间未知的关系。
对于这些查询类型中的每一个，在训练期间都没有观察到底层实体之间的关系。
查询类型(3)和(4)是zero-shot学习的一种形式。因为在训练过程中，新实体与其他实体的关系以及它的图像都没有被观察到。这些考虑说明了可视化查询类型的新颖特性。机器学习模型必须能够学习KG的关系语义，而不是简单地将图像分配给实体的分类器。</li>
</ol></li>
<li><p>24 Mmkg: Multi-modal knowledge graphs <strong>2019</strong>
MMKG数据集将三个知识图谱数据集Freebase15k、DBpedia15k和YAGO15k使用sameAs关系连接起来，该文章只学习了sameAs关系，证明了不同模态对同一链接预测任务是互补的。</p></li>
</ul>
<h2 id="多模态知识图谱数据集">多模态知识图谱数据集：</h2>
<p>DBpedia</p>
<p>DBpedia作为近十年来语义网研究的中心领域，其丰富的语义信息也将会成为今后多模态知识图谱的链接端点，其完整的本体结构对于构建多模态知识图谱提供了很大的便利。DBpedia项目是一个社区项目，旨在从维基百科中提取结构化信息，并使其可在网络上访问。DBpedia知识库目前描述了超过260万个实体。对于每个实体，DBpedia定义了一个唯一的全局标识符，可以将其解引用为网络上一个RDF描述的实体。DBpedia提供了30种人类可读的语言版本，与其他资源形成关系。在过去的几年里，越来越多的数据发布者开始建立数据集链接到DBpedia资源，使DBpedia成为一个新的数据web互联中心。目前，围绕DBpedia的互联网数据源网络提供了约47亿条信息，涵盖地理信息、人、公司、电影、音乐、基因、药物、图书、科技出版社等领域。</p>
<p>Wikidata</p>
<p>Wikidata中也存在大量的多模态资源，Wikidata是维基媒体基金会(WMF)联合策划的一个知识图谱，是维基媒体数据管理策略的核心项目。充分利用Wikidata的资源，主要挑战之一是提供可靠并且强大的数据共享查询服务，维基媒体基金会选择使用语义技术。活动的SPARQL端点、常规的RDF转储和链接的数据api是目前Wikidata的核心技术，Wikidata的目标是通过创造维基百科全球管理数据的新方法来克服数据不一致性。Wikidata的主要成就包括:Wikidata提供了一个可由所有人共享的免费协作知识库;Wikidata已经成为维基媒体最活跃的项目之一;越来越多的网站在浏览页面时都从Wikidata获取内容，以增加大数据的可见性和实用性。</p>
<p>IMGpedia</p>
<p>IMGpedia是一个大型的链接数据集，它从Wikimedia
Commons数据集中的图像中收集大量的可视化信息。它构建并生成了1500万个视觉内容描述符，图像之间有4.5亿个视觉相似关系，此外，在IMGpedia中单个图像与DBpedia之间还有链接。IMGpedia旨在从维基百科发布的图片中提取相关的视觉信息，从Wikimedia中收集所有术语和所有多模态数据(包括作者、日期、大小等)的图像，并为每张图像生成相应的图像描述符。链接数据很少考虑多模态数据，但多模态数据也是语义网络的重要组成部分。为了探索链接数据和多模态数据的结合，构建了IMGpedia，计算Wikipedia条目中使用的图像描述符，然后将这些图像及其描述与百科知识图谱链接起来。</p>
<p>IMGpedia是一个多模态知识图谱的先例。将语义知识图谱与多模态数据相结合，面对多种任务下的挑战和机遇。IMGpedia使用四种图像描述符进行基准测试，这些描述符的引用和实现是公开的。IMGpedia提供了Wikidata的链接。由于DBpedia中的分类对一些可视化语义查询不方便，所以IMGpedia旨在提供一个更好的语义查询平台。IMGpedia在多模态方向上是一个很好的先例，但也存在一些问题，比如关系类型稀疏，关系数量少，图像分类不清晰等，也是之后需要集中解决的问题。</p>
<p>MMKG</p>
<p>MMKG主要用于联合不同知识图谱中的不同实体和图像执行关系推理，MMKG是一个包含所有实体的数字特征和(链接到)图像的三个知识图谱的集合，以及对知识图谱之间的实体对齐。因此，多关系链接预测和实体匹配社区可以从该资源中受益。MMKG有潜力促进知识图谱的新型多模态学习方法的发展，作者通过大量的实验验证了MMKG在同一链路预测任务中的有效性。</p>
<p>MMKG选择在知识图谱补全文献中广泛使用的数据集FREEBASE-15K
(FB15K)作为创建多模态知识图谱的起点。知识图谱三元组是基于N-Triples格式的，这是一种用于编码RDF图的基于行的纯文本格式。MMKG同时也创建了基于DBpedia和YAGO的版本，称为DBpedia-15K(DB15K)和YAGO15K，通过将FB15K中的实体与其他知识图谱中的实体对齐。其中对于基于DBpedia的版本，主要构建了sameAs关系，为了创建DB15K，提取了FB15K和DBpedia实体之间的对齐，通过sameAs关系链接FB15K和DBpedia中的对齐实体；构建关系图谱，来自FB15K的很大比例的实体可以与DBpedia中的实体对齐。但是，为了使这两个知识图谱拥有大致相同数量的实体，并且拥有不能跨知识图谱对齐的实体，在DB15K中包括了额外的实体；构建图像关系，MMKG从三大搜索引擎中获取相应文本实体的图像实体，生成对应的文本-图像关系。但是，它是专门为文本知识图谱的完成而构建的，主要针对小数据集(FB15K,
DBPEDIA15K,
YAGO15K)。MMKG在将图像分发给相关文本实体时也没有考虑图像的多样性。</p>
<p>还有之前提到的ImageGraph应该也算。</p>
<h2 id="推荐系统">推荐系统</h2>
<p>将时序信息引入知识图谱可能效果会更好，因为每个人的兴趣很有可能因为时间而改变，用户链接任务也可以通过引入时序的知识图谱完成？</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Papers</tag>
      </tags>
  </entry>
  <entry>
    <title>Suda-charging-monitor</title>
    <url>/Life/Suda-charging-monitor/</url>
    <content><![CDATA[<p>苏州大学充电桩监控（已弃用！）</p>
<span id="more"></span>
<h1 id="suda-charging-piles-monitor">SUDA Charging Piles Monitor</h1>
<p>苏州大学充电桩监控</p>
<p>项目因某些原因已废弃！</p>
<p>代码已开源至<a
href="https://github.com/willkyu/SUDA_Charging_Piles_Monitor">我的GitHub仓库</a>。</p>
<h2 id="使用说明">使用说明</h2>
<ul>
<li><p>打开网站 &lt;yayan.xyz&gt;，填写相关信息。</p></li>
<li><p>关注邮箱，等待回信。</p>
<blockquote>
<p>如果选择“监控”，则可能需要等待5秒左右的时间收到Email，提示你开始监控。</p>
</blockquote>
<blockquote>
<p>如果选择“查询”，则会在1秒内发送Email给你。</p>
</blockquote></li>
<li><p>如果你监控的充电桩中途不进行充电了（被人拔了或其他原因无法充电），会在15秒内给你回Email通知你。</p></li>
<li><p>如果你监控的充电桩已充电6小时，则会自动取消监控并给你发送回执邮件。</p></li>
</ul>
<h2 id="注意事项">注意事项</h2>
<ul>
<li><p><strong><em>请输入正确的邮箱</em></strong></p></li>
<li><p><strong><em>不要重复提交（可以再次提交以更换监控的充电桩）</em></strong></p></li>
<li><p><strong><em>如果你碰上拔你充电器的人，请与他好好交流，避免肢体冲突</em></strong></p></li>
</ul>
<h2 id="其他的话">其他的话</h2>
<p>邮件全部采用英文是因为采用不同邮箱接收可能会导致中文的乱码问题。</p>
<p>如果你要自己搭建属于自己的监控，请将<strong>util.py</strong>中的一些邮件相关配置替换为自己的发件箱，运行<strong>flaskapp.py</strong>与<strong>chargingmonitor.py</strong>。</p>
<h2 id="致谢">致谢</h2>
<p>感谢苏大的<a
href="http://sudacharge.haoxiaoren.com/">充电助手网站</a>，该项目就是基于这个网页写的。</p>
<p>感谢室友<a
href="https://github.com/Gladduck">gladdduck</a>写的前端与一些改进，服务器、域名也由他提供！</p>
<p>感谢别的室友为我们测试并发现一些bug！</p>
<p>如果你有任何建议或反馈，可以通过GitHub账号内的联系方式联系我们！</p>
]]></content>
  </entry>
  <entry>
    <title>基础知识01</title>
    <url>/Learning/Notes/2022Summer/the-Basics01/</url>
    <content><![CDATA[<ul>
<li>张量</li>
<li>参数初始化策略</li>
<li>参数范数与正则化</li>
<li>梯度下降法</li>
<li>梯度爆炸与梯度消失</li>
<li>自适应学习率算法</li>
<li>评估指标</li>
<li>归一化</li>
<li>Dropout</li>
<li>激活函数</li>
<li>损失函数</li>
<li>反向传播算法（公式推导）</li>
<li>过拟合与欠拟合</li>
</ul>
<span id="more"></span>
<h1 id="张量">张量</h1>
<p>张量（tensor）是一个<strong>多维数组</strong>，张量的<strong>阶数（order）</strong>也称为维度（dimensions）。</p>
<p>一阶张量是一个<strong>矢量</strong>，二阶张量是一个<strong>矩阵</strong>，三阶或更高阶的张量叫做<strong>高阶张量</strong>。</p>
<!--
![三阶张量](/images/body/the-Basics01/third-order-tensor.png "A third-order tensor")
-->
<figure>
<img data-src="pics01/third-order-tensor.png" title="A third-order tensor"
alt="三阶张量" />
<figcaption aria-hidden="true">三阶张量</figcaption>
</figure>
<h2 id="张量的范数">张量的范数</h2>
<p>张量 <span class="math inline">\(\mathscr{X} \in \mathbb{R}^{I_1
\times I_2 \times \cdots \times I_N}\)</span>
的范数（norm）是其<strong>所有元素平方和的平方根</strong>，即</p>
<p><span class="math display">\[
\Vert \mathscr{X} \Vert =
\sqrt{\sum_{i_1=1}^{I_1}{\sum_{i_2=1}^{I_2}{\cdots
\sum_{i_N=1}^{I_N}{x_{i_1i_2 \cdots i_N}^2}}}}
\]</span></p>
<h2 id="张量的内积">张量的内积</h2>
<p>两个相同大小的张量 <span class="math inline">\(\mathscr{X} ,
\mathscr{Y} \in \mathbb{R}^{I_1 \times I_2 \times \cdots \times
I_N}\)</span> 的内积（inner product）为</p>
<p><span class="math display">\[
\langle \mathscr{X} , \mathscr{Y} \rangle =
\sum_{i_1=1}^{I_1}{\sum_{i_2=1}^{I_2} {\cdots
\sum_{i_N=1}^{I_N}{x_{i_1i_2 \cdots i_N} y_{i_1i_2 \cdots i_N}}}}
\]</span></p>
<p>且有 <span class="math inline">\(\langle \mathscr{X} , \mathscr{X}
\rangle = \Vert \mathscr{X} \Vert^2\)</span></p>
<h2 id="一些代码实现">一些代码实现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成一个随机的(n,m)的矩阵，其中的每个元素都从均值为0、标准差为1的标准高斯分布（正态</span><br><span class="line">x=torch.randn(3, 4)</span><br><span class="line"></span><br><span class="line"># 使用 arange 创建一个行向量 x。这个行向量包含以0开始的前n个整数，它们默认创建为整数</span><br><span class="line">x = torch.arange(12)</span><br><span class="line"></span><br><span class="line"># 查看x的形状</span><br><span class="line">x.shape</span><br><span class="line"></span><br><span class="line"># 改变x的形状 元素的个数总和不能改变</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">view和reshape都是用来重塑tensor的shape的。</span><br><span class="line">view只适合对满足连续性条件（contiguous）的tensor进行操作，</span><br><span class="line">而reshape同时还可以对不满足连续性条件的tensor进行操作，具有更好的鲁棒性。</span><br><span class="line">view能干的reshape都能干，如果view不能干就可以用reshape来处理</span><br><span class="line">参考连接：https://blog.csdn.net/Flag_ing/article/details/109129752</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">x.reshape(3,4)</span><br><span class="line"></span><br><span class="line"># 查看设备是否能使用cuda</span><br><span class="line">torch.cuda.is_available()</span><br><span class="line"></span><br><span class="line"># 把张量移动到GPU上</span><br><span class="line"># DEVICE=&#x27;cuda:0&#x27;</span><br><span class="line">DEVICE=&#x27;cpu&#x27;</span><br><span class="line">x.to(DEVICE)</span><br><span class="line"># 或者</span><br><span class="line"># x.cuda()</span><br><span class="line"></span><br><span class="line"># 查看张量所在的设备</span><br><span class="line">x.device</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基本的加减乘除</span><br><span class="line">x = torch.tensor([1.0, 2, 4, 8])</span><br><span class="line">y = torch.tensor([2, 2, 2, 2])</span><br><span class="line">x + y, x - y, x * y, x / y, x ** y</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 两个向量在同一维度上的拼接</span><br><span class="line">X = torch.arange(12, dtype=torch.float32).reshape((3,4))</span><br><span class="line">Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])</span><br><span class="line">torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 两个向量在新维度上的堆叠</span><br><span class="line">X = torch.arange(12, dtype=torch.float32).reshape((3,4))</span><br><span class="line">Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])</span><br><span class="line">torch.stack((X, Y), dim=0)</span><br></pre></td></tr></table></figure>
<p>索引切片和广播机制
就像在任何其他Python数组中一样，张量中的元素可以通过索引和切片访问。
张量的广播机制和numpy的广播机制一样 切片和python内置的数组一样
两个张量形状不一样时进行运算，有两种情况能够进行广播</p>
<ol type="1">
<li><p>A.ndim &gt; B.ndim, 并且A.shape最后几个元素包含B.shape,
A.shape=(2,3,4,5), B.shape=(3,4,5) A.shape=(2,3,4,5), B.shape=(4,5)
A.shape=(2,3,4,5), B.shape=(5)</p></li>
<li><p>A.ndim == B.ndim,
并且A.shape和B.shape对应位置的元素要么相同要么其中一个是1,
A.shape=(1,9,4), B.shape=(15,1,4) A.shape=(1,9,4),
B.shape=(15,1,1)</p></li>
</ol>
<h1 id="参数初始化策略">参数初始化策略</h1>
<p>参数初始化指的是网络模型在进行训练之前，对各个节点的权重和偏置进行初始化赋值的过程。</p>
<p>深度学习中，神经网络的参数初始化策略对模型的收敛速度及性能有至关重要的影响。在神经网络中，随着层数的增多，在梯度下降的过程中极易出现<a
href="#梯度爆炸与梯度消失">梯度消失或梯度爆炸</a>的问题，一个好的参数初始化对于处理这两个问题有着很大帮助。</p>
<h2 id="初始化为常数过大或过小">初始化为常数、过大或过小</h2>
<p>这些初始化策略都是不可取的，常数初始化会使得每层所有神经元相等，效果等效于一个神经元，极大限制了神经网络的学习能力。而参数过大过小会导致模型出现梯度爆炸或梯度消失的问题。</p>
<p>具体推导过程可见：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMzgwNjQxODg=">https://zhuanlan.zhihu.com/p/138064188<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="什么样的初始化是好的">什么样的初始化是好的？</h2>
<ul>
<li>因为对参数 <span class="math inline">\(w\)</span>
的大小和正负缺乏先验知识，<span class="math inline">\(w\)</span>
应为随机数，且期望 <span class="math inline">\(E(w) = 0\)</span> 。</li>
<li>为了防止梯度爆炸和梯度消失，权重不宜过大或过小，要对权重的方差 <span
class="math inline">\(Var(w)\)</span> 有所控制。</li>
<li>由于 <span class="math inline">\(dW_{l} = \frac{1}{m}dZ_{l}\cdot
A_{l-1}^T\)</span>，<span class="math inline">\(dW_{l}\)</span> 还与
<span class="math inline">\(A_{l-1}^T\)</span>
有关，所以我们希望不同激活层输出的方差相同，即 <span
class="math inline">\(Var(a_l) = Var(a_{l-1})\)</span>
，也就意味着不同激活层输入的方差相同，即 <span
class="math inline">\(Var(z_l) = Var(z_{l-1})\)</span> 。</li>
<li>权重的数值范围应考虑到前向与后向两个过程，不能过大或过小。</li>
</ul>
<h2 id="xavier初始化策略">Xavier初始化策略</h2>
<p>论文地址：<a
href="https://link.zhihu.com/?target=http%3A//jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf">Understanding
the difficulty of training deep feedforward neural networks</a></p>
<p><strong>核心思想：正向传播时，激活值的方差保持不变；反向传播时，关于状态值的梯度的方差保持不变</strong></p>
<p>Xavier初始化将每层权重设置在有界的随即均匀分布中选择的值</p>
<p><span class="math display">\[
\pm \frac{\sqrt{6}}{\sqrt{n_i+n_{i+1}}}
\]</span></p>
<p>其正态分布形式为</p>
<p><span class="math display">\[
(u, \sigma^2) = (0, \frac{2}{n_{i-1}+n_{i}})
\]</span></p>
<p>Xavier初始化策略对<strong>使用关于零对称且在[-1,
1]内有输出的激活函数（如softsign和tanh）</strong>效果较好，而如果使用ReLU激活函数则会产生梯度消失。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Xavier(m, h):</span><br><span class="line">    return torch.Tensor(m, h).uniform_(-1, 1) * math.sqrt(6. / (m + h))</span><br><span class="line"></span><br><span class="line">x = torch.randn(512)</span><br><span class="line">for i in range(100):</span><br><span class="line">    a = Xavier(512, 512)</span><br><span class="line">    x = torch.tanh(a @ x)</span><br><span class="line">print(x.mean(), x.std())</span><br><span class="line"></span><br><span class="line">x = torch.randn(512)</span><br><span class="line">for i in range(100):</span><br><span class="line">    a = Xavier(512, 512)</span><br><span class="line">    x = torch.relu(a @ x)</span><br><span class="line">print(x.mean(), x.std())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor(0.0072) tensor(0.0723)</span><br><span class="line">tensor(5.5722e-16) tensor(8.1033e-16)</span><br></pre></td></tr></table></figure>
<h2 id="kaiming初始化策略">Kaiming初始化策略</h2>
<p>论文地址：<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE1MDIuMDE4NTI=">Delving Deep
into Rectifiers: Surpassing Human-Level Performance on ImageNet
Classification<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>核心思想：正向传播时，状态值的方差保持不变；反向传播时，关于激活值的梯度的方差保持不变</strong></p>
<p>Kaiming初始化（也称he初始化）是针对Relu激活函数的初始化方法，作者证明了如果采用一下输入权重初始化策略，深层网络会更早收敛：</p>
<ul>
<li>使用适合给定图层的权重矩阵创建张量，并使用从标准正态分布中随机选择的数字填充它。</li>
<li>将每个随机选择的数字乘以<span
class="math inline">\(\frac{\sqrt{2}}{\sqrt{n}}\)</span>，其中n是从前一层输出到指定层的连接数（fan-in）</li>
<li>偏差张量初始化为零。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Kaiming(m, h):</span><br><span class="line">    return torch.randn(m, h) * math.sqrt(2. / m)</span><br><span class="line"></span><br><span class="line">x = torch.randn(512)</span><br><span class="line">for i in range(100):</span><br><span class="line">    a = Kaiming(512, 512)</span><br><span class="line">    x = torch.relu(a @ x)</span><br><span class="line">print(x.mean(), x.std())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor(0.7144) tensor(1.0703)</span><br></pre></td></tr></table></figure>
<h1 id="参数范数与正则化">参数范数与正则化</h1>
<p>正则化（regularization）技术广泛应用在机器学习和深度学习算法中，其<strong>本质作用是防止过拟合、提高模型泛化能力</strong>。在早期的机器学习领域一般只是将范数惩罚叫做正则化技术，而在深度学习领域认为：能够显著减少方差，而不过度增加偏差的策略都可以认为是正则化技术，故推广的正则化技术还有：扩增样本集、早停止、Dropout、集成学习、多任务学习、对抗训练、参数共享等</p>
<h2 id="范数">范数</h2>
<ol type="1">
<li>P范数：</li>
</ol>
<p><span class="math display">\[
L_p = (\sum_{i = 1}^n\vert x_i\vert^p)^{\frac{1}{p}}
\]</span></p>
<ol start="2" type="1">
<li>L0范数：表示向量中非零元素的个数</li>
<li>L1范数：为向量元素绝对值之和</li>
</ol>
<p><span class="math display">\[
\Vert x\Vert _1 = \sum_{i = 1}^n\vert x_i\vert
\]</span></p>
<ol start="4" type="1">
<li>L2范数：向量元素的平方和再开方，也称欧几里得距离</li>
</ol>
<p><span class="math display">\[
\Vert x\Vert _2 = \sqrt{\sum_{i = 1}^nx_i^2}
\]</span></p>
<ol start="5" type="1">
<li><span class="math inline">\(\infty\)</span>
范数：即所有向量元素绝对值中的最大值</li>
</ol>
<p><span class="math display">\[
\Vert x\Vert _\infty = \max_i\vert x_i\vert
\]</span></p>
<ol start="6" type="1">
<li><span class="math inline">\(-\infty\)</span>
范数：即所有向量元素绝对值中的最小值</li>
</ol>
<p><span class="math display">\[
\Vert x\Vert _{-\infty} = \min_i\vert x_i\vert
\]</span></p>
<h2 id="简单数值假设分析">简单数值假设分析</h2>
<!--
![不同参数下的曲线拟合结果(左欠拟合，右过拟合)](/images/body/the-Basics01/three-fitting-curve.jpg "Three fitting curve")
-->
<figure>
<img data-src="pics01/three-fitting-curve.jpg" title="Three fitting curve"
alt="不同参数下的曲线拟合结果(左欠拟合，右过拟合)" />
<figcaption
aria-hidden="true">不同参数下的曲线拟合结果(左欠拟合，右过拟合)</figcaption>
</figure>
<p>对于右边的拟合曲线，有</p>
<p><span class="math display">\[
h_\theta(x) = \theta _0 + \theta _1x_1 + \theta _2x_2^2 + \theta _3x_3^3
+ \theta _4x_4^4
\]</span></p>
<p>由于 <span class="math inline">\(\theta _3\)</span> 和 <span
class="math inline">\(\theta _4\)</span>
对应了高阶，导致拟合曲线是4阶曲线，出现了过拟合。正则化的目的为适当缩减
<span class="math inline">\(\theta _3\)</span> 和 <span
class="math inline">\(\theta _4\)</span>
的值，例如都为0.0001，则上述曲线本质上等价于</p>
<p><span class="math display">\[
h_\theta(x) = \theta _0 + \theta _1x_1 + \theta _2x_2^2
\]</span></p>
<p>也就是变成了中间的刚好合适的拟合曲线。对 <span
class="math inline">\(\theta _3\)</span> 和 <span
class="math inline">\(\theta _4\)</span>
增加L2正则项后的代价函数表达式为</p>
<p><span class="math display">\[
J(\theta) = \min_\theta \frac{1}{n} \sum_{i = 1}^n{((h_\theta(x^i) -
y^i)^2 + 1000\theta_3^2 + 1000\theta_4^2)}
\]</span></p>
<p>从上式可以看出， <span class="math inline">\(\theta _3\)</span> 和
<span class="math inline">\(\theta _4\)</span>
均大于0，其乘上了1000，要是 <span
class="math inline">\(J(\theta)\)</span> 最小，则会迫使模型学习到的
<span class="math inline">\(\theta _3\)</span> 和 <span
class="math inline">\(\theta _4\)</span> 会非常小，因为只有在 <span
class="math inline">\(\theta _3\)</span> 和 <span
class="math inline">\(\theta _4\)</span>
非常小的情况下整个代价函数值才会取的较小值。在实际开发中，是对所有参数进行正则化，为了使代价函数尽可能的小，所有的参数
<span class="math inline">\(\theta\)</span> 的值（不包括 <span
class="math inline">\(\theta_0\)</span>
）都会在一定程度上减小，但是减少程度会不一样，从而实现了权重衰减、简化模型复杂度的作用。</p>
<h2 id="参数范数与正则化的联系">参数范数与正则化的联系</h2>
<p>如果有一批数据输入指数为50的函数分布，我们至少需要输入50组数据来记录所有的函数对应的参
数。但对于深度学习这种拥有百万级参数规模的学习模型来说，那简直是不可想象的。</p>
<ol type="1">
<li>因此我们放松限制，仅仅控制参数的数目，而不是从高到低的顺序限制参数。我们将不为0的参数数
量限制再 c 以内来达到限制模型的目的(L0范数惩罚)。</li>
<li>虽然我们已经放松了限制，但是以上表达式并不完美，对于实际应用并不是太友好，那么我们不妨再
放松一下限制，不要求非零的参数个数控制再 c
以内，但要求参数绝对值数值的和控制再 c 以内。这种
参数数值总和的限制被称之为L1范数惩罚，也被成为参数稀疏性惩罚</li>
<li>虽然我们已经更加放松了限制，但是这还是不完美，因为带有绝对值，我们都知道，绝对值函数再求
梯度时不可导，因此我们再次放宽限制，将求绝对值和变为求平方和，如下式所示，这就是L2范数惩
罚，也就是我们熟悉的权重衰减惩罚。我们可以通过控制 c
值的大小来限制模型的学习能力，c 越大， 模型能力就越强（过拟合），c
越小，模型能力就越弱（欠拟合）。该条件极值可以通过拉格朗日乘子
法来进行求解。</li>
</ol>
<h1 id="梯度下降法">梯度下降法</h1>
<p>优化算法的功能是通过改善训练方法，来最小化（或最大化）损失函数 <span
class="math inline">\(J(\theta)\)</span>。</p>
<p>梯度下降背后的思想是：开始时我们随机选择一个参数的组合 <span
class="math inline">\((\theta _0, \theta _1, \theta _2, \dots, \theta
_n)\)</span>
，计算损失函数，然后我们寻找下一个能让损失函数值下降最多的参数组合。我们持续这么做直到到一个局部最小值（local
minimum），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（global
minimum），选择不同的初始参数组合，可能会找到不同的局部最小值。</p>
<!--
![不同初始参数组合找到不同的极小值](/images/body/the-Basics01/different-local-minimum.png "Different local minimum")
-->
<figure>
<img data-src="pics01/different-local-minimum.png"
title="Different local minimum"
alt="不同初始参数组合找到不同的极小值" />
<figcaption
aria-hidden="true">不同初始参数组合找到不同的极小值</figcaption>
</figure>
<p>梯度下降算法如下：</p>
<p><span class="math display">\[
\theta _j := \theta _j - \alpha\frac{\partial}{\partial\theta
_j}J(\theta)
\]</span></p>
<p>其中 <span class="math inline">\(\alpha\)</span> 是学习率（learning
rate），它决定了我们沿着该方向迈出的步子有多大。<span
class="math inline">\(\alpha\)</span>
太大或太小都不好，太小会导致收敛速度很慢，而太大可能会越过最低点，甚至无法收敛。</p>
<!--
![梯度下降法](/images/body/the-Basics01/different-local-minimum.png "Gradient descent")
-->
<figure>
<img data-src="pics01/gradient-descent.png" title="Gradient descent"
alt="梯度下降法" />
<figcaption aria-hidden="true">梯度下降法</figcaption>
</figure>
<p>传统的批量梯度下降法计算整个数据集梯度，但只进行一次更新，这在处理大型数据集时速度很慢且难以控制，甚至导致内存溢出。</p>
<p>权重的更新速度由学习率 <span class="math inline">\(\alpha\)</span>
决定，并且可以在凸面误差曲线中收敛到全局最优值，在非凸曲面中可能趋于局部最优值。</p>
<p>此外，标准形式的批量梯度下降法在训练大型数据集时存在冗杂的权重更新。</p>
<h1 id="梯度爆炸与梯度消失">梯度爆炸与梯度消失</h1>
<h2 id="梯度爆炸">梯度爆炸</h2>
<p>误差梯度是神经网络训练过程中计算的方向和数量，用于以正确的方向和合适的量更新网络权重。
在深层网络或循环神经网络中，误差梯度可在更新中累积，变成非常大的梯度，然后导致网络权重的大幅更新，并因此使网络变得不稳定。在极端情况下，权重的值变得非常大，以至于溢出，导致
NaN 值。 网络层之间的梯度（值大于
1.0）重复相乘导致的指数级增长会产生梯度爆炸。在深度多层感知机网络中，梯度爆炸会引起网络不稳定，最好的结果是无法从训练数据中学习，而最坏的结果是出现无法再更新的NaN权重值。</p>
<h2 id="梯度消失">梯度消失</h2>
<p>在某些情况下，梯度会变得非常小，有效地阻止了权重值的变化。在最坏的情况下，这可能会完全停止神经网络的进一步训练。例如，传统的激活函数(如双曲正切函数)具有范围(0,1)内的梯度，反向传播通过链式法则计算梯度。这样做的效果是，用这些小数字的n乘以n来计算n层网络中“前端”层的梯度，这意味着梯度(误差信号)随n呈指数递减，而前端层的训练非常缓慢。</p>
<h2 id="产生原因">产生原因</h2>
<p>主要是采用了不合适的损失函数,
如果我们使用标准化初始w，那么各个层次的相乘都是0-1之间的小数，而激活函数f的导数也是0-1之间的数，其连乘后，结果会变的很小，导致梯度消失。若我们初始化的w是很大的数，w大到乘以激活函数的导数都大于1，那么连乘后，可能会导致求导的结果很大，形成梯度爆炸。</p>
<h2 id="解决方法">解决方法</h2>
<h3 id="预训练并微调">预训练并微调</h3>
<p>基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。</p>
<h3 id="梯度剪切与正则化">梯度剪切与正则化</h3>
<p>梯度剪切这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内。这可以防止梯度爆炸。</p>
<p>另外一种解决梯度爆炸的手段是采用权重正则化（weithts
regularization）比较常见的是L1正则化，和L2正则化，在各个深度框架中都有相应的API可以使用正则化。</p>
<h3
id="使用reluleakreluelu等激活函数">使用relu、leakrelu、elu等激活函数</h3>
<p>Relu:思想也很简单，如果激活函数的导数为1，那么就不存在梯度消失爆炸的问题了，每层的网络都可以得到相同的更新速度，relu就这样应运而生。详见<a
href="#激活函数">激活函数</a>。</p>
<h3 id="批规范化">批规范化</h3>
<p>Batchnorm是深度学习发展以来提出的最重要的成果之一，目前已经被广泛的应用到了各大网络中，具有加速网络收敛速度，提升训练稳定性的效果，Batchnorm本质上是解决反向传播过程中的梯度问题。batchnorm全名是batch
normalization，简称BN，即批规范化，通过规范化操作将输出信号x规范化到均值为0，方差为1保证网络的稳定性。</p>
<h3 id="使用残差结构">使用残差结构</h3>
<p>自从残差提出后，几乎所有的深度网络都离不开残差的身影，相比较之前的几层，几十层的深度网络，在残差网络面前都不值一提，残差可以很轻松的构建几百层，一千多层的网络而不用担心梯度消失过快的问题，原因就在于残差的捷径（shortcut）部分。</p>
<h3 id="lstm长短期记忆网络">LSTM（长短期记忆网络）</h3>
<p>在RNN网络结构中，由于使用Logistic或者Tanh函数，所以很容易导致梯度消失的问题，即在相隔很远的时刻时，前者对后者的影响几乎不存在了，LSTM的机制正是为了解决这种长期依赖问题。</p>
<h1 id="自适应学习率算法">自适应学习率算法</h1>
<p>学习率对模型的性能有显著的影响，是难以设置的超参数之一。损失通常高度敏感于参数空间中的某些方向，而不敏感于其他。动量算法可以在一定程度缓解这些问题，但这样做的代价是引入了另一个超参数。</p>
<p>Delta-bar-delta 算法 (Jacobs, 1988)
是一个早期的在训练时适应模型参数各自学习率的启发式方法。该方法基于一个很简单的想法，如果损失对于某个给定模型参数的偏导保持相同的符号，那么学习率应该增加。如果对于该参数的偏导变化了符号，那么学习率应减小。当然，这种方法只能应用于全批量优化中。最近，提出了一些增量（或者基于小批量）的算法来自适应模型参数的学习率。</p>
<h2 id="adagrad">AdaGrad</h2>
<p>Adagrad方法是在每个时间步中，根据过往已计算的参数梯度，来为每个参数修改对应的学习率。能独立地适应所有模型参数的学习率，当参数损失偏导值比较大时，有一个较大的学习率；当参数的损失偏导值较小时，有一个较小的学习率。</p>
<p>Adagrad方法的主要好处是，不需要手工来调整学习率。大多数参数使用了默认值0.01，且保持不变。</p>
<p>Adagrad方法的主要缺点是，学习率总是在降低和衰减。</p>
<p>因为每个附加项都是正的，在分母中累积了多个平方梯度值，故累积的总和在训练期间保持增长。这反过来又导致学习率下降，变为很小数量级的数字，该模型完全停止学习，停止获取新的额外知识。</p>
<p>因为随着学习速度的越来越小，模型的学习能力迅速降低，而且收敛速度非常慢，需要很长的训练和学习，即学习速度降低。</p>
<!--
![Adagrad算法](/images/body/the-Basics01/Adagrad.png "Adagrad")
-->
<figure>
<img data-src="pics01/Adagrad.png" title="Adagrad" alt="Adagrad算法" />
<figcaption aria-hidden="true">Adagrad算法</figcaption>
</figure>
<h2 id="rmsprop">RMSProp</h2>
<p>RMSProp 算法 (Hinton, 2012) 修改 AdaGrad
以在非凸设定下效果更好，改变梯度积累为指数加权的移动平均。</p>
<p>AdaGrad
旨在应用于凸问题时快速收敛。当应用于非凸函数训练神经网络时，学习轨迹可能穿过了很多不同的结构，最终到达一个局部是凸碗的区域。
AdaGrad
根据平方梯度的整个历史收缩学习率，可能使得学习率在达到这样的凸结构前就变得太小了。</p>
<p>RMSProp
使用指数衰减平均以丢弃遥远过去的历史，使其能够在找到凸碗状结构后快速收敛，它就像一个初始化于该碗状结构的
AdaGrad 算法实例。相比于 AdaGrad，使用移动平均引入了一个新的超参数 <span
class="math inline">\(\rho\)</span>，用来控制移动平均的长度范围。经验上，RMSProp
已被证明是一种有效且实用的深度神经网络优化算法，是深度学习从业者经常采用的优化方法之一。</p>
<!--
![RMSProp算法](/images/body/the-Basics01/RMSProp.png "RMSProp")
-->
<figure>
<img data-src="pics01/RMSProp.png" title="RMSProp" alt="RMSProp算法" />
<figcaption aria-hidden="true">RMSProp算法</figcaption>
</figure>
<!--
![使用Nesterov动量的RMSProp算法](/images/body/the-Basics01/RMSProp-Nesterov.png "RMSProp Nesterov")
-->
<figure>
<img data-src="pics01/RMSProp-Nesterov.png" title="RMSProp Nesterov"
alt="使用Nesterov动量的RMSProp算法" />
<figcaption
aria-hidden="true">使用Nesterov动量的RMSProp算法</figcaption>
</figure>
<h2 id="adam">Adam</h2>
<p>Adam (Kingma and Ba, 2014)
是另一种学习率自适应的优化算法，它可以被看作结合 RMSProp
和具有一些重要区别的动量的变种。</p>
<p>首先，在 Adam
中，动量直接并入了梯度一阶矩（指数加权）的估计。将动量加入 RMSProp
最直观的方法是将动量应用于缩放后的梯度。结合缩放的动量使用没有明确的理论动机。</p>
<p>其次， Adam
包括偏置修正，修正从原点初始化的一阶矩（动量项）和（非中心的）二阶矩的估计。
RMSProp 也采用了（非中心的）二阶矩估计，然而缺失了修正因子。因此，不像
Adam，RMSProp 二阶矩估计可能在训练初期有很高的偏置。</p>
<p>Adam
通常被认为对超参数的选择相当鲁棒，尽管学习率有时需要自行从默认值修改。</p>
<!--
![Adam算法](/images/body/the-Basics01/Adam.png "Adam")
-->
<figure>
<img data-src="pics01/Adam.png" title="Adam" alt="Adam算法" />
<figcaption aria-hidden="true">Adam算法</figcaption>
</figure>
<h1 id="评估指标">评估指标</h1>
<h2 id="分类指标">分类指标</h2>
<p><strong>混淆矩阵（confusion
matrix）</strong>是一个评估分类问题常用的工具，对于 k
元分类，其实它就是一个 k*k
的表格，用来记录分类器的预测结果。对于常见的二分类，它的混淆矩阵是 2*2
的。</p>
<p>在二分类问题中，可以将样例根据其真实类别和预测类别的组合划分为：</p>
<ul>
<li>真正例（true positive）TP</li>
<li>假正例（false positive）FP</li>
<li>真反例（true negative）TN</li>
<li>假反例（false negative）FN</li>
</ul>
<p>显然 TP + FP + TN + FN = 样例总数。分类结果的混淆矩阵如下:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">真实情况</th>
<th style="text-align: center;">预测</th>
<th style="text-align: center;">结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">正例</td>
<td style="text-align: center;">反例</td>
</tr>
<tr class="even">
<td style="text-align: center;">正例</td>
<td style="text-align: center;">TP(真正例)</td>
<td style="text-align: center;">FN(假反例)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">反例</td>
<td style="text-align: center;">FP(假正例)</td>
<td style="text-align: center;">TN(真反例)</td>
</tr>
</tbody>
</table>
<h3 id="准确率精度accuracy">准确率（精度，Accuracy）</h3>
<p>精度Accurac是指模型预测正确（包括真正例TP、真反例TN）的样本数与总体样本数的占比，即：</p>
<p><span class="math display">\[
Accuracy = \frac{Count(correct)}{Count(total)}
\]</span></p>
<p>在二分类问题中：</p>
<p><span class="math display">\[
Accuracy = \frac{TP + TN}{TP + FP + FN + TN}
\]</span></p>
<p>准确率是分类问题中最简单直观的指标，但是在实际中应用不多。原因是：当样本标签分布不均衡时，比如：正样本占比99%，只要模型把所有样本都预测为正样本，则准确率达到99%，但是实际上模型根本没有预测能力。</p>
<h3 id="查准率精确率precision">查准率（精确率，Precision）</h3>
<p>查准率是从预测正例的角度出发（分子分母都是关于Positive）：</p>
<p><span class="math display">\[
Precision = \frac{TP}{TP + FP}
\]</span></p>
<p>假设我们用模型预测了一批西瓜，预测100个瓜为好瓜，其中60个为好瓜，40个坏瓜，则查准率就是60/100=60%.</p>
<p>查准率评估了模型预测的正例中的精度--准确更重要。</p>
<p>假设我们提高阈值，使得预测为正例的数量变少，预测精度更高，那么查准率就变得更高，因此单一查准率指标依然没法对模型性能进行准确评估。因为模型遗漏了大量正例，使得大量正例被误判为负例。</p>
<h3 id="查全率召回率recall">查全率（召回率，Recall）</h3>
<p>召回率从实际正例的角度出发（真正例、假反例）</p>
<p><span class="math display">\[
Recall = \frac{TP}{TP + FN}
\]</span></p>
<p>假设80个好瓜，模型预测出60个好瓜，20个好瓜未被正确预测，则查全率就是60/(60+20)=75%。</p>
<p>召回率评估了针对正例样本，表示样本中的正例有多少被预测正确--少漏更重要，要全。</p>
<p>假设我们降低阈值，就会使得预测为正例的样本数量增多，但查准率会降低。</p>
<p>所以查准率和查全率的矛盾，跟阈值相关。</p>
<h3 id="p-r曲线平衡点和f1衡量">P-R曲线、平衡点和F1衡量</h3>
<h4 id="p-r曲线">P-R曲线</h4>
<p>在上面分析查准率P，查全率R的时候，我们得到了不同阈值下对P、R的影响。那么当我们预测100的样本后（假设样本预测结果以概率形式输出），我们对样本结果进行排序，排在最前面（概率最大）的模型认为“最可能是”正例的样本，排在最后的是模型认为”最不可能“是正例的样本。按此顺序设置不同的阈值（阈值可以是排序后的概率值，或者固定划分点），在不同的阈值下，计算出当前阈值下的查准率P和查全率R。以查准率为纵轴，查全率为横轴作图，就可以得到查准率-查全率曲线，简称P-R曲线，显示改曲线的图称为”P-R图“。</p>
<!--
![P-R曲线与平衡点示意图](/images/body/the-Basics01/P-R-Curve.png "P-R Curve")
-->
<figure>
<img data-src="pics01/P-R-Curve.png" title="P-R Curve"
alt="P-R曲线与平衡点示意图" />
<figcaption aria-hidden="true">P-R曲线与平衡点示意图</figcaption>
</figure>
<p>P-R图直观地显示出学习器在样本总体上的查全率，查准率。在进行比较时，<strong>若一个学习期的P-R曲线被另一个学习器完全”包住“，则可以断言后者的性能优于前者</strong>。例如图中，学习器A的性能优于学习器C；如果两个学习器的P-R曲线发生了交叉，例如图中的A和B，则难以一般性地断言两者优劣，只能在具体地查准率或者查全率条件下进行比较。</p>
<p>然而，在很多情况下，人们往往仍然希望把A和B比出个高低。这时，一个比较合理地判断依据是<strong>比较P-R曲线下面积的大小（Area
under curve
P-R，AUC-PR）</strong>，它在一定程度上表征了学习器在查准率和查全率上取得相对”双高“的比例。但这个值不太容易估算，因此，人们设计了一些综合考虑查准率，查全率的性能度量，比如BEP度量，F1度量。</p>
<h4 id="平衡点break-even-pointbep">平衡点（Break-Even-Point，BEP）</h4>
<p>平衡点（Break-Even-Point），它是”查准率=查全率“时的取值，例如图1中的学习器C的BEP是0.64，基于BEP的比较，可认为A优于B。</p>
<h4 id="f1度量">F1度量</h4>
<p>BEP过于简单，这个平衡点是建立在”查准率=查全率“的前提下，无法满足实际不同场景的应用。我们引入加权调和平均
<span class="math inline">\(F_\beta\)</span> ：</p>
<p><span class="math display">\[
\frac{1}{F_\beta} = \frac{1}{1 + \beta ^2}(\frac{1}{P} + \frac{\beta
^2}{R})
\]</span></p>
<p>当 <span class="math inline">\(\beta = 1\)</span> 时，有 <span
class="math inline">\(\frac{1}{F_1} = \frac{1}{2}(\frac{1}{P} +
\frac{1}{R})\)</span>，即</p>
<p><span class="math display">\[
F_1 = \frac{2 * P * R}{P + R}
\]</span></p>
<p>在一些应用中，对查准率和查全率的重视程度不同。例如在商品推荐中，为了尽可能少打扰用户，更希望推荐的内容确实是用户感兴趣的，此时查准率更重要；而在罪犯信息检索或者病人检查系统中，更希望尽可能少的漏判，此时查全率更重要。F1度量的一般形式是
<span
class="math inline">\(F_\beta\)</span>，能让我们自定义对查准率/查全率的不同偏好：</p>
<p><span class="math display">\[
F_\beta = \frac{(1 + \beta ^2) * P * R}{(\beta ^2 * P) + R}
\]</span></p>
<p>其中，<span class="math inline">\(\beta &gt; 0\)</span>
度量了查全率对查准率的相对重要性，<span class="math inline">\(\beta =
1\)</span> 时退化为标准F1，<span class="math inline">\(\beta &gt;
1\)</span> 时查全率有更大影响；<span class="math inline">\(\beta &lt;
1\)</span> 时，查准率有更大影响。</p>
<h4 id="多分类情况">多分类情况</h4>
<p>很多时候我们有多个二分类混淆矩阵，例如进行多次训练/测试，每次得到一个混淆矩阵；或是在多个数据集上进行训练/测试，希望估计算法的全局性能；或者是执行分类任务，每两两类别的组合都对应一个混淆矩阵；总之是在n个二分类混淆矩阵上综合考察查准率和查全率。</p>
<p>一种直接的做法是现在各个混淆矩阵上分别计算出查准率和查全率，记为(P1,R1)，(P2,R2),...(Pn,Rn)，在计算平均值，这样就得到“宏观查准率”(macro-P)，“宏观查全率”(macro-R)、“宏观F1”(macro-F1)：</p>
<p><span class="math display">\[
macroP = \frac{1}{n}\sum^n_{i = 1} P_i\\
macroR = \frac{1}{n}\sum^n_{i = 1} R_i\\
macroF1 = \frac{2 * macroP * macroR}{macroP + macroR}
\]</span></p>
<p>另一种方法可以将个混淆矩阵对应的元素进行平均，得到TP、FP、TN、FN的平均值，分别记为
<span class="math inline">\(\overline{TP}\)</span>、<span
class="math inline">\(\overline{FP}\)</span>、<span
class="math inline">\(\overline{FN}\)</span>、<span
class="math inline">\(\overline{TN}\)</span>，再基于这些平均值计算出“微观查准率”(micro-P)，“微观查全率”(micro-R)、“微观F1”(micro-F1)：</p>
<p><span class="math display">\[
microP = \frac{\overline{TP}}{\overline{TP} + \overline{FP}}\\
microR = \frac{\overline{TP}}{\overline{TP} + \overline{FN}}\\
microF1 = \frac{2 * microP * microR}{microP + microR}
\]</span></p>
<h3 id="roc与auc">ROC与AUC</h3>
<p>根据上面混淆矩阵的一系列指标计算，可以发现，将样本预测为正例或者负例是与一个分类阈值相关的。若大于阈值则分为正类，否则为反类。</p>
<p>实际上，根据概率预测结果，我们可以将测试样本进行排序，“最可能”是正例的排在最前面，“最不可能”是正例的排在最后面。这样，分类过程就相当于在这个排序中以某个“截断点”(cut
point)将样本分为两部分，前一部分作为正例，后一部分作为反例。</p>
<p>在不同的任务中，我们可以根据任务需求采用不同的阈值，若我们更重视查准率，则选择排序中靠前的位置，若更重视查全率，则可以选择靠后的位置进行截。因此，排序本身的好坏，提现了综合考虑学习器在不同任务下的“期望泛化性能”的好坏。ROC曲线则是从这个角度出发来研究学习器泛化性能的有效工具。</p>
<p>ROC全称是“受试者工作特性”(Receiver Operating
Characteristic)曲线。与上述介绍的P-R曲线相似，我们根据预测结果对样例进行排序，按此顺序逐个将样本预测结果作为阈值进行划分。之后计算两个指标：真正例率（True
Positive Rate，简称TPR），假正例率（False Positive
Rate，简称FPR），公式如下：</p>
<p><span class="math display">\[
TPR = \frac{TP}{TP + FN}\\
FPR = \frac{FP}{FP + TN}
\]</span></p>
<p>以TPR为纵轴，FPR为横轴，得到ROC曲线。在现实任务中通常只有有限个样本来绘制ROC图，此时无法产生图a中光滑的曲线，只能绘制出图b所示的近似曲线。绘制过程如介绍公式时所描述的一样，对样本预测结果进行排序，然后取第一个结果作为阈值，此时所有样本均预测为反例，此时真正例率和假正例率均为0，在坐标(0,0)处标记一个点。随后将第二个样本预测结果作为阈值，得到坐标点，依次类推。</p>
<!--
![ROC曲线与AUC示意图](/images/body/the-Basics01/ROC-AUC.png "ROC AUC")
-->
<figure>
<img data-src="pics01/ROC-AUC.png" title="ROC AUC"
alt="ROC曲线与AUC示意图" />
<figcaption aria-hidden="true">ROC曲线与AUC示意图</figcaption>
</figure>
<p>当要比较两个学习器的性能优劣时，与P-R曲线相似，若一个学习器的ROC曲线被另一个学习器的曲线完全“包住”，则可断言后者的性能优于前者；若两个学习器的ROC曲线发生交叉，则一般难以断言两者优劣。此时可以比较ROC曲线下的面积，即AUC(Area
under ROC Curve)。</p>
<p>很明显，AUC的结果不会超过 1，通常ROC曲线都在 y = x
这条直线上面，所以，AUC的值一般在 0.5 ~ 1 之间。</p>
<p>从定义可知，AUC可以通过对ROC曲线下各部分的面积求和而得。假定ROC曲线是由坐标{(x1,y1),(x2,y2)...}的点连接而成。AUC可估算为</p>
<p><span class="math display">\[
AUC = \frac{1}{2}\sum^{m - 1}_{i = 1}(x_{i + 1} - x_i)(y_i + y_{i + 1})
\]</span></p>
<h3 id="ks图kolomogorov-smirnov-chart">KS图（Kolomogorov Smirnov
chart）</h3>
<p>KS值是在模型中用于<strong>区分预测正负样本分隔程度的评价指标</strong>，一般应用于金融风控领域。如果将人口划分为两个独立的组，其中一组包含所有正例而另一组包含所有负例，则K-S值为100。</p>
<p>与ROC曲线相似，ROC是以FPR作为横坐标，TPR作为纵坐标，通过改变不同阈值，从而得到ROC曲线。而在KS曲线中，则是以阈值作为横坐标，以FPR和TPR作为纵坐标，ks曲线则为TPR-FPR，ks曲线的最大值通常为ks值。</p>
<p>为什么这样求KS值呢？我们知道，当阈值减小时，TPR和FPR会同时减小，当阈值增大时，TPR和FPR会同时增大。而在实际工程中，我们希望TPR更大一些，FPR更小一些，即TPR-FPR越大越好，即ks值越大越好。</p>
<p>可以理解TPR是收益，FPR是代价，ks值是收益最大。图中绿色线是TPR、蓝色线是FPR。</p>
<!--
![KS](/images/body/the-Basics01/KS.jpg "KS")
-->
<figure>
<img data-src="pics01/KS.jpg" title="KS" alt="KS" />
<figcaption aria-hidden="true">KS</figcaption>
</figure>
<p>在实际应用中，比如风控模型中，往往单一指标并不能真正比较两个学习器之间的优劣，比如A学习器KS：40，B学习器KS：39。并不能保证A学习器一定比B学习器表现好，就像考试100的同学一定比99分的同学优秀一样。在实际中，通常结合单一指标（比如KS）和图表，综合判断模型在实际应用中，哪一个模型更加有优势。</p>
<h2 id="回归指标">回归指标</h2>
<h3
id="均方误差mean-squared-errormse与均方根误差root-mean-squared-errorrmse">均方误差（Mean
Squared Error，MSE）与均方根误差（Root Mean Squared Error，RMSE）</h3>
<p>MSE计算的是拟合数据和原始数据对应样本点的误差的平方和的均值，其值越小说明拟合效果越好。</p>
<p><span class="math display">\[
MSE = \frac{1}{N}\sum^N_{i = 1}(y^2_i - \^y^2_i)
\]</span></p>
<p>由于MSE与我们的目标变量的量纲不一致，为了保证量纲一致性，我们需要对MSE进行开方，即均方根误差：</p>
<p><span class="math display">\[
RMSE = \sqrt{\frac{1}{N}\sum^N_{i = 1}(y^2_i - \^y^2_i)}
\]</span></p>
<p>以下是RMSE需要考虑的要点：</p>
<ul>
<li>“平方根”使该指标能够显示大的偏差。</li>
<li>此度量标准的“平方”特性有助于提供更强大的结果，从而防止取消正负误差值。换句话说，该度量恰当地显示了错误的合理幅度。</li>
<li>它避免使用绝对误差值，这在数学计算中是非常不希望的。</li>
<li>当我们有更多样本时，使用RMSE重建误差分布被认为更可靠。</li>
<li>RMSE受到异常值的影响很大。因此，请确保在使用此指标之前已从数据集中删除了异常值。</li>
<li>与平均绝对误差( mean absolute
error)相比，RMSE提供更高的权重并惩罚大的错误。</li>
</ul>
<h3 id="平均绝对误差mean-absolute-errormae">平均绝对误差（Mean Absolute
Error，MAE）</h3>
<p>和 MSE 一样，这种度量方法也是在不考虑方向的情况下衡量误差大小。但和
MSE 的不同之处在于，MAE
需要像线性规划这样更复杂的工具来计算梯度。此外，MAE
对异常值更加稳健，因为它不使用平方。</p>
<p><span class="math display">\[
MAE = \frac{1}{N}\sum^N_{i = 1}\vert y_i - \^y_i\vert
\]</span></p>
<h3 id="决定系数-r方r-squarded">决定系数 R方（R-squarded）</h3>
<p>判定系数，其含义是也是解释回归模型的方差得分，其值取值范围是[0,1]，越接近于1说明自变量越能解释因变量的方差变化，值越小则说明效果越差。又称为the
coefficient of
determination。判断的是预测模型和真实数据的拟合程度，最佳值为1，同时可为负值。如果结果是0，就说明我们的模型跟瞎猜差不多。如果结果是1。就说明我们模型无错误。如果结果是0-1之间的数，就是我们模型的好坏程度。如果结果是负数。说明我们的模型还不如瞎猜。</p>
<p>R方可以理解为因变量y中的变异性能能够被估计的多元回归方程解释的比例，它衡量各个自变量对因变量变动的解释程度，<strong>其取值在0与1之间，其值越接近1，则变量的解释程度就越高，其值越接近0，其解释程度就越弱</strong>。</p>
<p>一般来说，增加自变量的个数，回归平方和会增加，残差平方和会减少，所以R方会增大；反之，减少自变量的个数，回归平方和减少，残差平方和增加。为了消除自变量的数目的影响，引入了调整的R方。</p>
<p><span class="math display">\[
\begin{aligned}
R^2 &amp; = 1- \frac{\sum^m_{i = 1}(f_i - y_i)^2}{\sum^m_{i =
1}(\overline{y_i} - y_i)^2}\\
&amp; = \frac{\frac{1}{m}\sum^m_{i = 1}(f_i -
y_i)^2}{\frac{1}{m}\sum^m_{i = 1}(\overline{y_i} - y_i)^2}\\
&amp; = 1 - \frac{MSE(f, y)}{Var(y)}
\end{aligned}
\]</span></p>
<h3 id="对百分比误差mape">对百分比误差（MAPE）</h3>
<p>MAPE（平均绝对百分比误差）MAPE 为0%表示完美模型，MAPE 大于 100
%则表示劣质模型。</p>
<p>MAPE是衡量预测准确性的统计指标，是百分比值，一般认为MAPE小于10时，预测精度较高</p>
<p>如果存在某个实际值At为0，那么MAPE则无法进行计算；</p>
<p><span class="math display">\[
MAPE = \frac{100\sum^n_{i = 1}\vert\frac{y_i - y&#39;_i}{y_i}\vert}{n}
\]</span></p>
<h1 id="归一化">归一化</h1>
<p>不同评价指标（即特征向量中的不同特征就是所述的不同评价指标）往往具有不同的量纲和量纲单位，这样的情况会影响到数据分析的结果，</p>
<p>为了消除指标之间的量纲影响，需要进行数据标准化处理，以解决数据指标之间的可比性。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。其中，最典型的就是数据的归一化处理。</p>
<p>简而言之，归一化的目的就是使得预处理的数据被限定在一定的范围内（比如[0,1]或者[-1,1]），从而消除奇异样本数据导致的不良影响。</p>
<blockquote>
<p>奇异样本数据是指相对于其他输入样本特别大或特别小的样本矢量（即特征向量）</p>
</blockquote>
<p>奇异样本数据的存在会引起训练时间增大，同时也可能导致无法收敛，因此，当存在奇异样本数据时，在进行训练之前需要对预处理数据进行归一化；反之，不存在奇异样本数据时，则可以不进行归一化。</p>
<h2 id="归一化的好处">归一化的好处</h2>
<ol type="1">
<li>归一化后加快了梯度下降求最优解的速度，也即加快训练网络的收敛性；</li>
<li>归一化有可能提高精度</li>
</ol>
<h2 id="归一化的方法">归一化的方法</h2>
<h3 id="最大最小标准化min-max-normalization">最大最小标准化（Min-Max
Normalization）</h3>
<p><span class="math display">\[
x&#39; = \frac{x - \min{(x)}}{\max{(x)} - \min{(x)}}
\]</span></p>
<ol type="1">
<li><p>线性函数将原始数据线性化的方法转换到[0 1]的范围,
计算结果为归一化后的数据，X为原始数据；</p></li>
<li><p>本归一化方法比较适用在数值比较集中的情况；</p></li>
<li><p>缺陷：如果max和min不稳定，很容易使得归一化结果不稳定，使得后续使用效果也不稳定。实际使用中可以用经验常量来替代max和min。</p></li>
</ol>
<p><strong>应用场景</strong>：在不涉及距离度量、协方差计算、数据不符合正态分布的时候，如图像处理中，将RGB图像转换为灰度图像后将其值限定在[0
255]的范围。</p>
<h3 id="z-score标准化">z-score标准化</h3>
<p><span class="math display">\[
x^* = \frac{x - \mu}{\sigma}
\]</span></p>
<p>其中，<span class="math inline">\(\mu\)</span>、<span
class="math inline">\(\sigma\)</span> 分别为原始数据集的均值和方差。</p>
<ol type="1">
<li><p>将原始数据集归一化为均值为0、方差1的数据集。</p></li>
<li><p>该种归一化方式要求原始数据的分布可以近似为高斯分布，否则归一化的效果会变得很糟糕。</p></li>
</ol>
<p>应用场景：在分类、聚类算法中，需要使用距离来度量相似性的时候、或者使用PCA技术进行降维的时候，Z-score
standardization表现更好。</p>
<h3 id="神经网络归一化">神经网络归一化</h3>
<p>本归一化方法经常用在数据分化比较大的场景，有些数值很大，有些很小。通过一些数学函数，将原始值进行映射。</p>
<p>该方法包括对数、正切等，需要根据数据分布的情况，决定非线性函数的曲线：</p>
<h4 id="对数函数归一化">对数函数归一化</h4>
<p><span class="math display">\[
y = \log_{10}(x)
\]</span></p>
<p>以10为底的对数转换函数，对应的归一化方法为：</p>
<p><span class="math display">\[
x&#39; = \frac{\log_{10}(x)}{\log_{10}(max)}
\]</span></p>
<p>其中max表示样本数据的最大值，并且所有样本数据均要大于等于1.</p>
<h4 id="反正切函数归一化">反正切函数归一化</h4>
<p><span class="math display">\[
x&#39; = \frac{2}{\pi}\arctan(x)
\]</span></p>
<p>使用这个方法需要注意的是如果想映射的区间为[0，1]，则数据都应该大于等于0，小于0的数据将被映射到[－1，0]区间上.</p>
<h3 id="l2范数归一化">L2范数归一化</h3>
<p>特征向量中每个元素均除以向量的L2范数：</p>
<p><span class="math display">\[
x&#39;_i = \frac{x_i}{norm(x)}
\]</span></p>
<h2 id="什么时候使用归一化">什么时候使用归一化</h2>
<ol type="1">
<li><p>如果对输出结果范围有要求，用归一化。</p></li>
<li><p>如果数据较为稳定，不存在极端的最大最小值，用归一化。</p></li>
<li><p>如果数据存在异常值和较多噪音，用标准化，可以间接通过中心化避免异常值和极端值的影响。</p></li>
</ol>
<blockquote>
<p><strong>归一化与标准化不同</strong></p>
</blockquote>
<h3 id="标准化归一化的对比分析">标准化/归一化的对比分析</h3>
<p>首先明确，在机器学习中，标准化是更常用的手段，归一化的应用场景是有限的。原因有两点：</p>
<ol type="1">
<li>标准化更好保持了样本间距。当样本中有异常点时，归一化有可能将正常的样本“挤”到一起去。比如三个样本，某个特征的值为1,2,10000，假设10000这个值是异常值，用归一化的方法后，正常的1,2就会被“挤”到一起去。如果不幸的是1和2的分类标签还是相反的，那么，当我们用梯度下降来做分类模型训练时，模型会需要更长的时间收敛，因为将样本分开需要更大的努力！而标准化在这方面就做得很好，至少它不会将样本“挤到一起”。</li>
<li>标准化更符合统计学假设对一个数值特征来说，很大可能它是服从正态分布的。标准化其实是基于这个隐含假设，只不过是略施小技，将这个正态分布调整为均值为0，方差为1的标准正态分布而已。</li>
</ol>
<h1 id="dropout">Dropout</h1>
<p>想要提高CNN的表达或分类能力，最直接的方法就是采用更深的网络和更多的神经元，即deeper
and
wider。但是，复杂的网络也意味着更加容易过拟合。于是就有了Dropout，大部分实验表明其具有一定的防止过拟合的能力。</p>
<h2 id="最初的dropout">最初的Dropout</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzEyMDcuMDU4MC5wZGY=">Improving neural
networks by preventing co-adaptation of feature Detectors<i class="fa fa-external-link-alt"></i></span></p>
<!--
![Dropout](/images/body/the-Basics01/Dropout.jpg "Dropout")
-->
<figure>
<img data-src="pics01/Dropout.jpg" title="Dropout" alt="Dropout" />
<figcaption aria-hidden="true">Dropout</figcaption>
</figure>
<p>如上图左，为没有Dropout的普通2层全连接结构，记为 <span
class="math inline">\(r = a(Wv)\)</span> ，其中 <span
class="math inline">\(a\)</span> 为激活函数。</p>
<p>如上图右，为在第2层全连接后添加Dropout层的示意图。即在模型训练时，随机让网络的某些节点不工作（输出置0），其它过程不变。</p>
<p>由于随机的让一些节点不工作了，因此可以避免某些特征只在固定组合下才生效，有意识地让网络去学习一些普遍的共性（而不是某些训练样本的一些特性）。</p>
<p>Bagging方法通过对训练数据有放回的采样来训练多个模型。而Dropout的随机意味着每次训练时只训练了一部分，而且其中大部分参数还是共享的，因此和Bagging有点相似。因此，Dropout可以看做训练了多个模型，实际使用时采用了模型平均作为输出。</p>
<p>训练时，我们通常设定一个dropout ratio <span
class="math inline">\(p\)</span>，即每一个输出节点以概率 <span
class="math inline">\(p\)</span>
置0(不工作)。假设每一个输出都是相互独立的，每个输出都服从二项伯努利分布
<span class="math inline">\(B(1 - p)\)</span>，则大约认为训练时只使用了
<span class="math inline">\((1-p)\)</span> 比例的输出。</p>
<p>测试时，最直接的方法就是保留Dropout层的同时，将一张图片重复测试 M
次，取 M 次结果的平均作为最终结果。假如有 N 个节点，则可能的情况为 <span
class="math inline">\(R = 2^N\)</span>，如果 M 远小于
R，则显然平均效果不好；如果M ≈
N，那么计算量就太大了。因此作者做了一个近似：可以直接去掉Dropout层，将所有输出都使用起来，为此需要将尺度对齐，即比例缩小输出
$ r = r * (1 - p)$。即如下公式：</p>
<p><span class="math display">\[
E_M[a(M * W)v] \approx a(E_M[(M * W)v]) = a((1 - p)Wv)
\]</span></p>
<p>特别的，
为了使用方便，我们不在测试时再缩小输出，而在训练时直接将输出放大1/(1-p)倍。</p>
<p>Dropout得到了广泛的使用，但具体用到哪里、训练一开始就用还是后面才用、dropout_ratio取多大，还要自己多多尝试。有时添加Dropout反而会降低性能。</p>
<h2 id="dropconnect">DropConnect</h2>
<p><span class="exturl" data-url="aHR0cDovL2NzLm55dS5lZHUvfndhbmxpL2Ryb3BjLw==">Regularization of Neural
Networks using DropConnect<i class="fa fa-external-link-alt"></i></span></p>
<!--
![Dropout-DropConnect](/images/body/the-Basics01/Dropout-DropConnect.jpg "Dropout-DropConnect")
-->
<figure>
<img data-src="pics01/Dropout-DropConnect.jpg" title="Dropout-DropConnect"
alt="Dropout-DropConnect" />
<figcaption aria-hidden="true">Dropout-DropConnect</figcaption>
</figure>
<p>由图可知，DropConnect与Dropout的区别很明显：Dropout是将输出随机置0，而DropConnect是将权重随机置0。
文章说之所以这么干是因为原来的Dropout进行的不够充分，随机采样不够合理。这可以从下图进行理
解：</p>
<!--
![DropConnect](/images/body/the-Basics01/DropConnect.jpg "DropConnect")
-->
<figure>
<img data-src="pics01/DropConnect.jpg" title="DropConnect"
alt="DropConnect" />
<figcaption aria-hidden="true">DropConnect</figcaption>
</figure>
<p>如上图所示，a表示不加任何Drop时的一层网络模型。添加Drop相当于给权重再乘以一个随机掩膜矩阵
<span class="math inline">\(M\)</span>。</p>
<p><span class="math display">\[
r = a(Wv)\ \ \ No-Drop\\
r = a((M\ldotp\times W)v)\ \ \ Drop\\
M_{ij}\sim Bernoulli(p)
\]</span></p>
<p>不同的是，DropConnect由于直接对权重随机置0，因此其掩膜显得更加具有随机性，如b所示。而Dropout仅对输出进行随机置0,因此其掩膜相当于是对随机的行和列进行置0，如c所示。</p>
<p>训练的时候，训练过程与Dropout基本相同。测试的时候，我们同样需要一种近似的方法。</p>
<p><span class="math display">\[
r = a((M\ldotp\times W)v)\\
r_i = a(u_i)\\
u_i = \sum_j(W_{ij}v_j)M_{ij} \sim \mathcal{N}(\mu, \sigma^2)\\
\mu = pWv\\
\sigma = p(1 - p)(W \ast W)(v \ast v)
\]</span></p>
<p>注意： 掩膜矩阵M的每一个元素都满足二项伯努利分布。假如M的维度为 <span
class="math inline">\(m\ast n\)</span>，则可能的掩膜有 <span
class="math inline">\(2^{m + n}\)</span>
种，之前提到过我们可以粗暴的遍历所有的掩膜然后计算结果最后求平均。中心极限定理：和分布渐进于正态分布。
于是，我们可以不去遍历，而是通过计算每一维的均值与方差，确定每一维的正态分布，最后在此正态分布上做多次采样后求平均即可获得最终的近似结果。</p>
<p>具体测试时的算法流程如下：</p>
<!--
![DropConnect算法](/images/body/the-Basics01/DropConnect-A.jpg "DropConnect Algorithm")
-->
<figure>
<img data-src="pics01/DropConnect-A.jpg" title="DropConnect Algorithm"
alt="DropConnect算法" />
<figcaption aria-hidden="true">DropConnect算法</figcaption>
</figure>
<p>其中，Z是在正态分布上的采样次数，一般来说越大越好，但会使得计算变慢。</p>
<p>实验：
作者当然要做很多对比试验，但其实发现效果并不比Dropout优秀太多，反而计算量要大很多，因此到目前DropConnect并没有得到广泛的应用。具体的对比，可以参看原文，这里贴一张图来说明对于Drop
ratio的看法：</p>
<!--
![DropConnect实验结果](/images/body/the-Basics01/DropConnect-figure.jpg "DropConnect figure")
-->
<figure>
<img data-src="pics01/DropConnect-figure.jpg" title="DropConnect figure"
alt="DropConnect实验结果" />
<figcaption aria-hidden="true">DropConnect实验结果</figcaption>
</figure>
<p>由此可以看出，drop ratio并不是越大越好，具体需要多做实验体会。</p>
<h1 id="激活函数">激活函数</h1>
<p>神经网络中的每个神经元节点接受上一层神经元的输出值作为本神经元的输入值，并将输入值传递给下一层，输入层神经元节点会将输入属性值直接传递给下一层（隐层或输出层）。在多层神经网络中，上层节点的输出和下层节点的输入之间具有一个函数关系，这个函数称为激活函数。</p>
<p>不使用激活函数的话，神经网络的每层都只是做线性变换，多层输入叠加后也还是线性变换。因为线性模型的表达能力通常不够，所以这时候就体现了激活函数的作用了，<strong>激活函数可以引入非线性因素</strong>。</p>
<!--
![不使用激活函数的神经网络](/images/body/the-Basics01/NN-no-activation-function.png "NN without activation function")
-->
<figure>
<img data-src="pics01/NN-no-activation-function.png"
title="NN without activation function" alt="不使用激活函数的神经网络" />
<figcaption aria-hidden="true">不使用激活函数的神经网络</figcaption>
</figure>
<!--
![使用激活函数的神经网络](/images/body/the-Basics01/NN-with-activation-function.png "NN with activation function")
-->
<figure>
<img data-src="pics01/NN-with-activation-function.png"
title="NN with activation function" alt="使用激活函数的神经网络" />
<figcaption aria-hidden="true">使用激活函数的神经网络</figcaption>
</figure>
<p>加入非线性激励函数后，神经网络就有可能学习到滑的曲线来分割面，而不是用复杂的线性组合逼滑曲线来分割面，使神经网络的表示能力更强了，能够更好的拟合目标函数。</p>
<p>sigmoid和tanh是“饱和激活函数”，而ReLU及其变体则是“非饱和激活函数”。使用“非饱和激活函数”的优势在于两点：</p>
<ol type="1">
<li>"非饱和激活函数”能解决所谓的“梯度消失”问题。</li>
<li>它能加快收敛速度。</li>
</ol>
<h2 id="饱和激活函数">饱和激活函数</h2>
<p>假设 <span class="math inline">\(h(x)\)</span> 是一个激活函数， -
若当n趋向于正无穷，激活函数的导数趋近于0，那么我们称之为<strong>右饱和</strong></p>
<p><span class="math display">\[
\lim\limits_{n\to + \infty}h&#39;(x) = 0
\]</span></p>
<ul>
<li>若当n趋向于负无穷，激活函数的导数趋近于0，那么我们称之为<strong>左饱和</strong></li>
</ul>
<p><span class="math display">\[
\lim\limits_{n\to - \infty}h&#39;(x) = 0
\]</span></p>
<p>当函数既满足左饱和也满足右饱和时，我们称之为饱和。典型的函数有Sigmoid、Tanh函数。</p>
<h3 id="sigmoid">Sigmoid</h3>
<p><span class="math display">\[
Sigmoid(x) = \frac{1}{1 + e^{- x}}
\]</span></p>
<!--
![Sigmoid函数图像](/images/body/the-Basics01/Sigmoid.png "Sigmoid")
-->
<figure>
<img data-src="pics01/Sigmoid.png" title="Sigmoid" alt="Sigmoid函数图像" />
<figcaption aria-hidden="true">Sigmoid函数图像</figcaption>
</figure>
<!--
![Sigmoid导函数图像](/images/body/the-Basics01/dSigmoid.png "dSigmoid")
-->
<figure>
<img data-src="pics01/dSigmoid.png" title="dSigmoid"
alt="Sigmoid导函数图像" />
<figcaption aria-hidden="true">Sigmoid导函数图像</figcaption>
</figure>
<p>Sigmoid函数在历史上曾经非常的常用，输出值范围为[0,1]之间的实数。但是现在它已经不太受欢迎，实际中很少使用。原因是sigmoid存在3个问题：</p>
<ol type="1">
<li>sigmoid函数饱和使梯度消失(Sigmoidsaturate and kill
gradients)。我们从导函数图像中可以看出sigmoid的导数都是小于0.25的，那么在进行反向传播的时候，梯度相乘结果会慢慢的趋于0导致梯度消失。除此之外，为了防止饱和，必须对于权重矩阵的初始化特别留意。如果初始化权重过大，可能很多神经元得到一个比较小的梯度，致使神经元不能很好的更新权重提前饱和，神经网络就几乎不学习。</li>
<li>sigmoid函数输出不是“零为中心”(zero-centered)。一个多层的sigmoid神经网络，如果你的输入x都是正数，那么在反向传播中w的梯度传播到网络的某一处时，权值的变化是要么全正要么全负。</li>
<li>指数函数的计算是比较消耗计算资源的。</li>
</ol>
<h3 id="tanh">Tanh</h3>
<p>实际上，tanh是sigmoid的变形。</p>
<p><span class="math display">\[
\begin{aligned}
Tanh(x) &amp; = 2 Sigmoid(2x) - 1\\
&amp; = \frac{1 - e^{-2x}}{1 + e^{-2x}}
\end{aligned}
\]</span></p>
<!--
![Tanh函数图像](/images/body/the-Basics01/Tanh.png "Tanh")
-->
<figure>
<img data-src="pics01/Tanh.png" title="Tanh" alt="Tanh函数图像" />
<figcaption aria-hidden="true">Tanh函数图像</figcaption>
</figure>
<p>tanh与sigmoid不同的是，tanh是“零为中心”的。因此，实际应用中，tanh会比sigmoid更好一些。但是在饱和神经元的情况下，tanh还是没有解决梯度消失问题。</p>
<p>优点：tanh解决了sigmoid的输出非“零为中心”的问题</p>
<p>缺点：依然有sigmoid函数过饱和的问题，且依然进行的是指数运算</p>
<h2 id="非饱和激活函数">非饱和激活函数</h2>
<h3 id="relu">ReLU</h3>
<p>近年来，ReLU函数变得越来越受欢迎。全称是Rectified Linear
Unit，修正线性单元。ReLU是Krizhevsky、Hinton等人在2012年《ImageNet
Classification with Deep Convolutional Neural
Networks》论文中提出的一种线性且不饱和的激活函数。</p>
<p><span class="math display">\[
ReLU(x) = \max(0, x)
\]</span></p>
<!--
![ReLU函数图像](/images/body/the-Basics01/ReLU.png "ReLU")
-->
<figure>
<img data-src="pics01/ReLU.png" title="ReLU" alt="ReLU函数图像" />
<figcaption aria-hidden="true">ReLU函数图像</figcaption>
</figure>
<p>优点：</p>
<ol type="1">
<li>ReLU解决了梯度消失的问题，至少x在正区间内，神经元不会饱和；</li>
<li>由于ReLU线性、非饱和的形式，在SGD中能够快速收敛；</li>
<li>运算速度要快很多。ReLU函数只有线性关系，不需要指数计算，不管在前向传播还是反向传播，计算速度都比sigmoid和tanh快</li>
</ol>
<p>缺点：</p>
<ol type="1">
<li>ReLU的输出不是“零为中心”(Notzero-centered output)。</li>
<li>随着训练的进行，可能会出现神经元死亡，权重无法更新的情况。这种神经元的死亡是不可逆转的死亡</li>
</ol>
<p>训练神经网络的时候，一旦学习率没有设置好，第一次更新权重的时候，输入是负值，那么这个含有ReLU的神经节点就会死亡，再也不会被激活。设置一个合适的较小的学习率，会降低这种情况的发生。</p>
<p>为了解决神经元节点死亡的情况，有人提出了Leaky
ReLU、P-ReLu、R-ReLU、ELU等激活函数。</p>
<h3 id="leaky-relu">Leaky ReLU</h3>
<p>ReLU是将所有的负值设置为0，造成神经元节点死亡情况。相反，Leaky
ReLU是给所有负值赋予一个非零的斜率。Leaky
ReLU激活函数是在声学模型(2013)中首次提出来的。</p>
<p><span class="math display">\[
LeakyReLU(x) = \begin{cases}x,\ if\ x \geq 0\\
                            \alpha x,\ if\ x &lt; 0
               \end{cases}
\]</span></p>
<!--
![Leaky ReLU函数图像](/images/body/the-Basics01/Leaky-ReLU.png "Leaky ReLU")
-->
<figure>
<img data-src="pics01/Leaky-ReLU.png" title="Leaky ReLU"
alt="Leaky ReLU函数图像" />
<figcaption aria-hidden="true">Leaky ReLU函数图像</figcaption>
</figure>
<p>优点：</p>
<ol type="1">
<li>神经元不会出现死亡的情况。</li>
<li>对于所有的输入，不管是大于等于0还是小于0，神经元不会饱和。</li>
<li>由于Leaky ReLU线性、非饱和的形式，在SGD中能够快速收敛。</li>
<li>计算速度要快很多。Leaky
ReLU函数只有线性关系，不需要指数计算，不管在前向传播还是反向传播，计算速度都比sigmoid和tanh快。</li>
</ol>
<p>缺点：Leaky ReLU函数中的参数 <span
class="math inline">\(\alpha\)</span>，需要通过先验知识人工赋值。</p>
<p>Leaky ReLU很好地解决了“dead ReLU”的问题。因为Leaky
ReLU保留了x小于0时的梯度，在x小于0时，不会出现神经元死亡的问题。对于Leaky
ReLU给出了一个很小的负数梯度值α，这个值是很小的常数。比如：0.01。这样即修正了数据分布，又保留了一些负轴的值，使得负轴信息不会全部丢失。</p>
<h3 id="rrelu">RReLU</h3>
<p>RReLU的英文全称是“Randomized Leaky
ReLU”，中文名字叫“随机修正线性单元”。RReLU是Leaky ReLU的随机版本。</p>
<p><span class="math display">\[
y_{ji} = \begin{cases}x_{ji},\ if\ x_{ji} \geq 0\\
                            \alpha_{ji} x_{ji},\ if\ x_{ji} &lt; 0
               \end{cases}
\]</span></p>
<p>where</p>
<p><span class="math display">\[
\alpha_{ji} \sim U(l, u),\ l &lt; u\ and\ l,\ u \in [0, 1)
\]</span></p>
<p><!--
![RReLU函数图像](/images/body/the-Basics01/RReLU.png "RReLU")
--></p>
<figure>
<img data-src="pics01/RReLU.png" title="RReLU" alt="RReLU函数图像" />
<figcaption aria-hidden="true">RReLU函数图像</figcaption>
</figure>
<p>RReLU的核心思想是，在训练过程中，<span
class="math inline">\(\alpha\)</span> 是从一个高斯分布 <span
class="math inline">\(U(l, u)\)</span>
中随机出来的值，然后再在测试过程中进行修正。在测试阶段，把训练过程中所有的
<span class="math inline">\(\alpha_{ij}\)</span> 取个平均值。</p>
<ol type="1">
<li><p>RReLU是Leaky
ReLU的random版本，在训练过程中，α是从一个高斯分布中随机出来的，然后再测试过程中进行修正。</p></li>
<li><p>数学形式与PReLU类似，但RReLU是一种非确定性激活函数，其参数是随机的</p></li>
</ol>
<h3 id="elu">ELU</h3>
<p>ELU的英文全称是“Exponential Linear
Units”，中文全称是“指数线性单元”。它试图将激活函数的输出<em>均值接</em>零，从而加快学习速度。同时，它还能通过正值的标识来避免梯度消失的问题。根据一些研究显示，ELU分类精确度是高于ReLU的。</p>
<p><span class="math display">\[
ELU(x) = \begin{cases}x,\ if\ x &gt; 0\\
                \alpha(e^x - 1),\ if\ x \leq 0
               \end{cases}
\]</span></p>
<p><!--
![ReLU及其变种对比](/images/body/the-Basics01/contrast.png "contrast")
--></p>
<figure>
<img data-src="pics01/contrast.png" title="contrast"
alt="ReLU及其变种对比" />
<figcaption aria-hidden="true">ReLU及其变种对比</figcaption>
</figure>
<p>优点：</p>
<ol type="1">
<li>ELU包含了ReLU的所有优点。</li>
<li>神经元不会出现死亡的情况。</li>
<li>ELU激活函数的输出均值是接*于零的。</li>
</ol>
<p>缺点：计算的时候是需要计算指数的，存在计算效率低的问题。</p>
<h3 id="maxout">Maxout</h3>
<p>Maxout “Neuron”
是由Goodfellow等人在2013年提出的一种很有特点的神经元，它的激活函数、计算的变量、计算方式和普通的神经元完全不同，并有两组权重。先得到两个超平面，再进行最大值计算。激活函数是对ReLU和Leaky
ReLU的一般化归纳，没有ReLU函数的缺点，不会出现激活函数饱和神经元死亡的情况。Maxout出现在ICML2013上，作者Goodfellow将maxout和dropout结合，称在MNIST，CIFAR-10，CIFAR-100，SVHN这4个数据集上都取得了start-of-art的识别率。</p>
<p><span class="math display">\[
f_i(x) = \max_{j\in [1, k]}z_{ij}
\]</span></p>
<p>其中，<span class="math inline">\(z_{ij} = x^TW_{\ldots ij} +
b_{ij}\)</span>，假设 <span class="math inline">\(W\)</span>
是二维的，那么我们有</p>
<p><span class="math display">\[
f(x) = \max(w^T_1x + b_1, w^T_2x + b_2)
\]</span></p>
<p>Maxout的拟合能力非常强，它可以拟合任意的凸函数。Goodfellow在论文中从数学的角度上也证明了这个结论，只需要2个Maxout节点就可以拟合任意的凸函数，前提是“隐含层”节点的个数足够多。</p>
<p>优点：</p>
<ol type="1">
<li>Maxout具有ReLU的所有优点，线性、不饱和性。</li>
<li>同时没有ReLU的一些缺点。如：神经元的死亡。</li>
</ol>
<p>缺点：从这个激活函数的公式中可以看出，每个neuron将有两组 <span
class="math inline">\(w\)</span>，那么参数就增加了一倍。这就导致了整体参数的数量激增。</p>
<h2 id="如何选择合适的激活函数">如何选择合适的激活函数?</h2>
<p>在实践过程中更多还是需要结合实际情况，考虑不同激活函数的优缺点综合使用。</p>
<ol type="1">
<li><p>通常来说，不能把各种激活函数串起来在一个网络中使用。</p></li>
<li><p>如果使用ReLU，那么一定要小心设置学习率(learning
rate)，并且要注意不要让网络中出现很多死亡神经元。如果死亡神经元过多的问题不好解决，可以试试Leaky
ReLU、PReLU、或者Maxout。</p></li>
<li><p>尽量不要使用sigmoid激活函数，可以试试tanh，不过还是建议非饱和激活函数。</p></li>
</ol>
<h1 id="损失函数">损失函数</h1>
<p>损失函数使用主要是在模型的训练阶段，每个批次的训练数据送入模型后，通过前向传播输出预测值，然后损失函数会计算出预测值和真实值之间的差异值，也就是损失值。得到损失值之后，模型通过反向传播去更新各个参数，来降低真实值与预测值之间的损失，使得模型生成的预测值往真实值方向靠拢，从而达到学习的目的。</p>
<h2 id="基于距离度量的损失函数">基于距离度量的损失函数</h2>
<h3 id="msel1l2">MSE、L1、L2</h3>
<p>见<a href="#mse">相应部分</a>。</p>
<h3 id="smooth-l1损失函数">Smooth L1损失函数</h3>
<p>Smooth L1损失是由Girshick R在Fast
R-CNN中提出的，主要用在目标检测中防止梯度爆炸。</p>
<p><span class="math display">\[
L(Y|f(x)) = \begin{cases}\frac{1}{2}(Y - f(x))^2,\ if\ \vert Y -
f(x)\vert &lt; 1\\
                \vert Y - f(x)\vert - \frac{1}{2},\ if\ x\vert Y -
f(x)\vert \geq 1
               \end{cases}
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Smooth_L1(x,y):</span><br><span class="line">    assert len(x)==len(y)</span><br><span class="line">    loss=0</span><br><span class="line">    for i_x,i_y in zip(x,y):</span><br><span class="line">        tmp = abs(i_y-i_x)</span><br><span class="line">        if tmp&lt;1:</span><br><span class="line">            loss+=0.5*(tmp**2)</span><br><span class="line">        else:</span><br><span class="line">            loss+=tmp-0.5</span><br><span class="line">    return loss</span><br></pre></td></tr></table></figure>
<h3 id="huber损失函数">Huber损失函数</h3>
<p>huber损失是平方损失和绝对损失的综合，它克服了平方损失和绝对损失的缺点，不仅使损失函数具有连续的导数，而且利用MSE梯度随误差减小的特性，可取得更精确的最小值。尽管huber损失对异常点具有更好的鲁棒性，但是，它不仅引入了额外的参数，而且选择合适的参数比较困难，这也增加了训练和调试的工作量。</p>
<p><span class="math display">\[
L(Y|f(x)) = \begin{cases}\frac{1}{2}(Y - f(x))^2,\ if\ \vert Y -
f(x)\vert \leq \delta\\
                \delta\vert Y - f(x)\vert - \frac{1}{2}\delta^2,\ if\
x\vert Y - f(x)\vert &gt; \delta
               \end{cases}
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delta=1.0  # 先定义超参数</span><br><span class="line"></span><br><span class="line">def huber_loss(x,y):</span><br><span class="line">    assert len(x)==len(y)</span><br><span class="line">    loss=0</span><br><span class="line">    for i_x,i_y in zip(x,y):</span><br><span class="line">        tmp = abs(i_y-i_x)</span><br><span class="line">        if tmp&lt;=delta:</span><br><span class="line">            loss+=0.5*(tmp**2)</span><br><span class="line">        else:</span><br><span class="line">            loss+=tmp*delta-0.5*delta**2</span><br><span class="line">    return loss</span><br></pre></td></tr></table></figure>
<h3 id="log-cosh损失函数">Log-Cosh损失函数</h3>
<p>Log-Cosh是应用于回归任务中的另一种损失函数，它比L2损失更平滑。Log-cosh是预测误差的双曲余弦的对数。</p>
<p>log-cosh损失函数比均方损失函数更加光滑，具有huber损失函数的所有优点，且二阶可导。因此可以使用牛顿法来优化计算，但是在误差很大情况下，一阶梯度和Hessian会变成定值，导致牛顿法失效。</p>
<p><span class="math display">\[
L(y, y^p) = \sum^n_{i = 1}\log(\cosh(y^p_i - y_i))
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># log cosh 损失</span><br><span class="line">def logcosh(true, pred):</span><br><span class="line">    loss = np.log(np.cosh(pred - true))return np.sum(loss)</span><br></pre></td></tr></table></figure>
<h3 id="分位数损失函数">分位数损失函数</h3>
<p>预测的是目标的取值范围而不是值。<span
class="math inline">\(\gamma\)</span>
是所需的分位数，其值介于0和1之间，<span
class="math inline">\(\gamma\)</span> 等于0.5时，相当于MAE。 设置多个
<span class="math inline">\(\gamma\)</span>
值，得到多个预测模型，然后绘制成图表，即可知道预测范围及对应概率(两个
<span class="math inline">\(\gamma\)</span> 值相减)</p>
<p><span class="math display">\[
L_\gamma(y, y^p) = \sum_{i = y_i &lt; y^p_i}(\gamma - 1)\ldotp\vert y_i
- y^p_i\vert + \sum_{i = y_i\geq y^p_i}(\gamma)\ldotp\vert y_i -
y^p_i\vert
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def quantile_loss(y_pred, y_true, r=0.5):</span><br><span class="line">    greater_mask = K.cast((y_true &lt;= y_pred), &#x27;float32&#x27;)</span><br><span class="line">    smaller_mask = K.cast((y_true &gt; y_pred), &#x27;float32&#x27;)</span><br><span class="line">    loss = K.sum((r-1)*K.abs(smaller_mask*(y_true-y_pred)), -1) +\</span><br><span class="line">           K.sum(r*K.abs(greater_mask*(y_true-y_pred)), -1)</span><br><span class="line">    return loss</span><br></pre></td></tr></table></figure>
<h2 id="基于概率分布度量的损失函数">基于概率分布度量的损失函数</h2>
<p>基于概率分布度量的损失函数是将样本间的相似性转化为随机事件出现的可能性，即通过度量样本的真实分布与它估计的分布之间的距离，判断两者的相似度，一般用于涉及概率分布或预测类别出现的概率的应用问题中，在分类问题中尤为常用。</p>
<h3 id="kl散度函数相对熵">KL散度函数（相对熵）</h3>
<p>KL散度（ Kullback-Leibler
divergence）也被称为相对熵，是一种非对称度量方法，常用于度量两个概率分布之间的距离。KL散度也可以衡量两个随机分布之间的距离，两个随机分布的相似度越高的，它们的KL散度越小，当两个随机分布的差别增大时，它们的KL散度也会增大，因此KL散度可以用于比较文本标签或图像的相似性。基于KL散度的演化损失函数有JS散度函数。JS散度也称JS距离，用于衡量两个概率分布之间的相似度，它是基于KL散度的一种变形，消除了KL散度非对称的问题，与KL散度相比，它使得相似度判别更加准确。</p>
<p>相对熵是恒大于等于0的。当且仅当两分布相同时，相对熵等于0。</p>
<p><span class="math display">\[
L(Y|f(x)) = \sum^n_{i = 1}Y_i \times \log(\frac{Y_i}{f(x_i)})
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def kl_loss(y_true:list,y_pred:list):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    y_true,y_pred，分别是两个概率分布</span><br><span class="line">    比如：px=[0.1,0.2,0.8]</span><br><span class="line">          py=[0.3,0.3,0.4]</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    assert len(y_true)==len(y_pred)</span><br><span class="line">    KL=0</span><br><span class="line">    for y,fx in zip(y_true,y_pred):</span><br><span class="line">        KL+=y*np.log(y/fx)</span><br><span class="line">    return KL</span><br></pre></td></tr></table></figure>
<h3 id="交叉熵损失">交叉熵损失</h3>
<p>交叉熵是信息论中的一个概念，最初用于估算平均编码长度，引入机器学习后，用于评估当前训练得到的概率分布与真实分布的差异情况。为了使神经网络的每一层输出从线性组合转为非线性逼近，以提高模型的预测精度，在以交叉熵为损失函数的神经网络模型中一般选用tanh、sigmoid、softmax或ReLU作为激活函数。</p>
<p>交叉熵损失函数刻画了实际输出概率与期望输出概率之间的相似度，也就是交叉熵的值越小，两个概率分布就越接近，特别是在正负样本不均衡的分类问题中，常用交叉熵作为损失函数。目前，交叉熵损失函数是卷积神经网络中最常使用的分类损失函数，它可以有效避免梯度消散。在二分类情况下也叫做<strong>对数损失函数</strong>。</p>
<p><span class="math display">\[
L(Y|f(x)) = - \sum^n_{i = 1}Y_i\log f(x_i)
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def CrossEntropy_loss(y_true:list,y_pred:list):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    y_true,y_pred，分别是两个概率分布</span><br><span class="line">    比如：px=[0.1,0.2,0.8]</span><br><span class="line">          py=[0.3,0.3,0.4]</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    assert len(y_true)==len(y_pred)</span><br><span class="line">    loss=0</span><br><span class="line">    for y,fx in zip(y_true,y_pred):</span><br><span class="line">        loss+=-y * np.log(fx)</span><br><span class="line">    return loss</span><br></pre></td></tr></table></figure>
<p>当正负样本不均衡的时候，通常会在交叉熵损失函数类别前面加个参数α</p>
<p><span class="math display">\[
CE = \begin{cases} -\alpha\log(p),\ y = 1\\
                   -(1 - \alpha)\log(1 - p),\ y = 0
     \end{cases}
\]</span></p>
<h3 id="softmax损失函数">Softmax损失函数</h3>
<p>从标准形式上看，softmax损失函数应归到对数损失的范畴，在监督学习中，由于它被广泛使用，所以单独形成一个类别。softmax损失函数本质上是逻辑回归模型在多分类任务上的一种延伸，常作为CNN模型的损失函数。softmax损失函数的本质是将一个k维的任意实数向量x映射成另一个k维的实数向量，其中，输出向量中的每个元素的取值范围都是(0,1)，即softmax损失函数输出每个类别的预测概率。由于softmax损失函数具有类间可分性，被广泛用于分类、分割、人脸识别、图像自动标注和人脸验证等问题中，其特点是类间距离的优化效果非常好，但类内距离的优化效果比较差。</p>
<p>softmax损失函数具有类间可分性，在多分类和图像标注问题中，常用它解决特征分离问题。在基于卷积神经网络的分类问题中，一般使用softmax损失函数作为损失函数，但是softmax损失函数学习到的特征不具有足够的区分性，因此它常与对比损失或中心损失组合使用，以增强区分能力。</p>
<p><span class="math display">\[
L(Y|f(x)) = - \frac{1}{n}\sum^n_{i = 1}\log\frac{e^{f_{Y_i}}}{\sum^c_{j
= 1}e^{f_j}}
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def softmax(x):</span><br><span class="line">    x_exp = np.exp(x)</span><br><span class="line">    x_sum = np.sum(x_exp, axis=1, keepdims=True)</span><br><span class="line">    s = x_exp / x_sum</span><br><span class="line">    return s</span><br><span class="line"></span><br><span class="line"># Tensorflow2.0版</span><br><span class="line">softmax_fc = tf.keras.activations.softmax(x)</span><br><span class="line"># pytorch版</span><br><span class="line">softmax_fc = torch.nn.Softmax()</span><br><span class="line">output = softmax_fc(x)</span><br></pre></td></tr></table></figure>
<h3 id="focal-loss">Focal loss</h3>
<p>focal
loss的引入主要是为了解决难易样本不均衡的问题，注意有区别于正负样本不均衡的问题。难易样本分为四个类型：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">难</th>
<th style="text-align: center;">易</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">正</td>
<td style="text-align: center;">正难</td>
<td style="text-align: center;">正易</td>
</tr>
<tr class="even">
<td style="text-align: center;">负</td>
<td style="text-align: center;">负难</td>
<td style="text-align: center;">负易</td>
</tr>
</tbody>
</table>
<p>易分样本虽然损失很低，但是数量太多，对模型的效果提升贡献很小，模型应该重点关注那些难分样本，因此需要把置信度高的损失再降低一些。</p>
<p><span class="math display">\[
FE = \begin{cases}-\alpha(1 - p)^\gamma\log(p),\ y = 1\\
                  -(1 - \alpha)p^\gamma\log(1 - p),\ y = 0
     \end{cases}
\]</span></p>
<h2 id="如何选择损失函数">如何选择损失函数</h2>
<p>通常情况下，损失函数的选取应从以下方面考虑：</p>
<ol type="1">
<li>选择最能表达数据的主要特征来构建基于距离或基于概率分布度量的特征空间。</li>
<li>选择合理的特征归一化方法，使特征向量转换后仍能保持原来数据的核心内容。</li>
<li>选取合理的损失函数，在实验的基础上，依据损失不断调整模型的参数，使其尽可能实现类别区分。</li>
<li>合理组合不同的损失函数，发挥每个损失函数的优点，使它们能更好地度量样本间的相似性。</li>
<li>将数据的主要特征嵌入损失函数，提升基于特定任务的模型预测精确度。</li>
</ol>
<h1 id="反向传播算法公式推导">反向传播算法（公式推导）</h1>
<p>反向传播算法（Backpropagation）是目前用来训练人工神经网络（Artificial
Neural Network，ANN）的最常用且最有效的算法。其主要思想是：</p>
<ol type="1">
<li>将训练集数据输入到ANN的输入层，经过隐藏层，最后达到输出层并输出结果，这是ANN的前向传播过程；</li>
<li>由于ANN的输出结果与实际结果有误差，则计算估计值与实际值之间的误差，并将该误差从输出层向隐藏层反向传播，直至传播到输入层；</li>
<li>在反向传播的过程中，根据误差调整各种参数的值；不断迭代上述过程，直至收敛。</li>
</ol>
<h2 id="变量定义">变量定义</h2>
<p><!--
![神经网络](/images/body/the-Basics01/NN.png "NN")
--></p>
<figure>
<img data-src="pics01/NN.png" title="NN" alt="神经网络" />
<figcaption aria-hidden="true">神经网络</figcaption>
</figure>
<p>上图是一个三层人工神经网络，layer1至layer3分别是输入层、隐藏层和输出层。</p>
<p>定义变量：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">变量</th>
<th style="text-align: center;">表示</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(w^l_{jk}\)</span></td>
<td style="text-align: center;">第 <span class="math inline">\((l -
1)\)</span> 层的第 <span class="math inline">\(k\)</span>
个神经元连接到第 <span class="math inline">\(l\)</span> 层的第 <span
class="math inline">\(j\)</span> 个神经元的权重</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(b^l_j\)</span></td>
<td style="text-align: center;">第 <span
class="math inline">\(l\)</span> 层的第 <span
class="math inline">\(j\)</span> 个神经元的偏置</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(z^l_j\)</span></td>
<td style="text-align: center;">第 <span
class="math inline">\(l\)</span> 层的第 <span
class="math inline">\(j\)</span> 个神经元的输入，即：<span
class="math inline">\(z^l_j = \sum_kw^l_{jk}a^{l - 1}_k +
b^l_j\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(a^l_j\)</span></td>
<td style="text-align: center;">第 <span
class="math inline">\(l\)</span> 层的第 <span
class="math inline">\(j\)</span> 个神经元的输出，即：<span
class="math inline">\(a^l_j = \sigma(z^l_j)\)</span>，其中 <span
class="math inline">\(\sigma\)</span> 表示激活函数</td>
</tr>
</tbody>
</table>
<h2 id="代价函数">代价函数</h2>
<p>代价函数被用来计算ANN输出值与实际值之间的误差。常用的代价函数是二次代价函数（Quadratic
cost function）：</p>
<p><span class="math display">\[
C = \frac{1}{2n}\sum_x\Vert y(x) - a^L(x)\Vert^2
\]</span></p>
<p>其中，<span class="math inline">\(x\)</span> 表示输入的样本，<span
class="math inline">\(y\)</span> 表示实际的分类，<span
class="math inline">\(a^L\)</span> 表示预测的输出，<span
class="math inline">\(L\)</span>表示神经网络的最大层数。</p>
<h2 id="公式及其推导">公式及其推导</h2>
<p>首先，将第 <span class="math inline">\(l\)</span> 层第 <span
class="math inline">\(j\)</span>
个神经元中产生的错误(即实际值与预测值之间的误差)定义为:</p>
<p><span class="math display">\[
\delta^l_j = \frac{\partial C}{\partial z^l_j}
\]</span></p>
<p>以一个输入样本为例,此时代价函数为：</p>
<p><span class="math display">\[
C = \frac{1}{2}\Vert y - a^L\Vert^2 = \frac{1}{2}\sum_j(y_j - a^L_j)^2
\]</span></p>
<h3
id="计算最后一次神经网络产生的错误">计算最后一次神经网络产生的错误：</h3>
<p><span class="math display">\[
\delta^L = \nabla_a C \odot \sigma&#39;(z^L)
\]</span></p>
<p>其中，<span class="math inline">\(\cdot\)</span>
表示Hadamard乘积，用于矩阵或向量之间点对点的乘法运算。推导过程如下：</p>
<p><span class="math display">\[
\because \delta^L_j = \frac{\partial C}{\partial z^L_j} = \frac{\partial
C}{\partial a^L_j}\cdot\frac{\partial a^L_j}{\partial z^L_j}\\
\therefore \delta^L = \frac{\partial C}{\partial a^L}\odot\frac{\partial
a^L}{\partial z^L} = \nabla_a C \odot \sigma&#39;(z^L)\\
\]</span></p>
<h3
id="从后向前计算每一层神经网络产生的错误">从后向前，计算每一层神经网络产生的错误</h3>
<p><span class="math display">\[
\delta^l = ((w^{l + 1})^T\delta^{l+1})\odot\sigma&#39;(z^l)
\]</span></p>
<p>推导过程：</p>
<p><span class="math display">\[
\begin{aligned}
\because \delta^l_j = \frac{\partial C}{\partial z^l_j} &amp; =
\sum_k\frac{\partial C}{\partial z^{l+1}_k}\cdot\frac{\partial
z^{l+1}_k}{\partial a^l_j}\cdot\frac{\partial a^l_j}{\partial z^l_j}\\
&amp; = \sum_k\delta^{l+1}_k\cdot\frac{\partial(w^(l+1)_{kj}a^l_j +
b^{l+1}_k)}{\partial a^l_j}\cdot\sigma&#39;(z^l_j)\\
&amp; = \sum_k\delta^{l+1}_k\cdot w^{l+1}_{kj}\cdot\sigma&#39;(z^l_j)\\
\therefore \delta^l = ((w^{l + 1})^T\delta^{l+1})\odot\sigma&#39;(z^l)
\end{aligned}
\]</span></p>
<h3 id="计算权重的梯度">计算权重的梯度</h3>
<p><span class="math display">\[
\frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k\delta^l_j
\]</span></p>
<p>推导过程：</p>
<p><span class="math display">\[
\frac{\partial C}{\partial w^l_{jk}} = \frac{\partial C}{\partial
z^l_j}\cdot\frac{\partial z^l_j}{\partial w^l_{jk}} =
\delta^l_j\cdot\frac{\partial(w^l_{jk}a^{l-1}_k + b^l_j)}{\partial
w^l_{jk}} = a^{l-1}_k\delta^l_j
\]</span></p>
<h3 id="计算偏置的梯度">计算偏置的梯度</h3>
<p><span class="math display">\[
\frac{\partial C}{\partial b^l_j} = \delta^l_j
\]</span></p>
<p>推导过程：</p>
<p><span class="math display">\[
\frac{\partial C}{\partial b^l_j} = \frac{\partial C}{\partial
z^l_j}\cdot\frac{\partial z^l_j}{\partial b^l_j} =
\delta^l_j\cdot\frac{\partial(w^l_{jk}a^{l-1}_k + b^l_j)}{\partial
b^l_j} = \delta^l_j
\]</span></p>
<h1 id="过拟合与欠拟合">过拟合与欠拟合</h1>
<h2 id="过拟合">过拟合</h2>
<p>定义1（摘自周志华机器学习）：当学习器把训练样本学的“太好”了的时候，很可能已经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降，这种现象称为过拟合。</p>
<p>定义2：具体表现就是最终模型在训练集上效果好；在测试集上效果差。模型泛化能力弱。</p>
<p>具体表现就是最终模型在训练集上效果好；在测试集上效果差。模型泛化能力弱。</p>
<h3 id="产生过拟合的原因">产生过拟合的原因</h3>
<ol type="1">
<li>训练数据中噪音干扰过大，使得学习器认为部分噪音是特征从而扰乱学习规则。</li>
<li>建模样本选取有误，例如训练数据太少，抽样方法错误，样本label错误等，导致样本不能代表整体。</li>
<li>模型不合理，或假设成立的条件与实际不符。</li>
<li>特征维度/参数太多，导致模型复杂度太高。</li>
<li>对于决策树模型，如果我们对于其生长没有合理的限制，其自由生长有可能使节点只包含单纯的事件数据(event)或非事件数据(no
event)，使其虽然可以完美匹配（拟合）训练数据，但是无法适应其他数据集。</li>
<li>对于神经网络模型：a)对样本数据可能存在分类决策面不唯一，随着学习的进行,，BP算法使权值可能收敛过于复杂的决策面；b)权值学习迭代次数足够多(Overtraining)，拟合了训练数据中的噪声和训练样例中没有代表性的特征。</li>
</ol>
<h3 id="过拟合的解决办法">过拟合的解决办法</h3>
<p>过拟合无法彻底避免，只能缓解。</p>
<h4 id="数据角度">数据角度</h4>
<ul>
<li>从数据源头获取更多数据</li>
<li>数据增强（Data
Augmentation）:通过一定规则扩充数据。如物体在图像中的位置、姿态、尺度、整体图片明暗度等都不会影响分类结果。我们可以通过图像平移、反转、缩放、切割等手段将数据库成倍扩充。</li>
<li>保留验证集</li>
<li>获取额外数据进行交叉验证</li>
</ul>
<h4 id="模型角度">模型角度</h4>
<ul>
<li>降低模型复杂度：
<ul>
<li>对于神经网络：减少网络的层数、神经元个数等均可以限制网络的拟合能力。dropout，在向前传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型的泛化性更强，因为它不会太依赖某些局部的特征。</li>
<li>对于决策树：限制树深，剪枝，限制叶节点数量。</li>
<li>增大分割平面间隔</li>
</ul></li>
<li>特征选择、特征降维</li>
<li>early stopping、Dropout</li>
<li>正则化（限制权值weight-decay）：将权值的大小作为惩罚项加入到损失函数里。</li>
<li>增加噪声：
<ul>
<li>在输入中加噪声。噪声会随着网络传播，按照权值的平方放大，并传播到输出层，会在输出中生成
<span class="math inline">\(\sum_iw^2_i\cdot\sigma^2_i\)</span>
的干扰项。训练时减小损失函数时也会减小权值，与L2正则化有类似效果。</li>
<li>在权值上加噪声。在初始化网络的时候，用0均值的高斯分布作为初始化。</li>
<li>对网络等响应加噪声。在前向传播的过程中，让某些神经元的输出变为random，从而打乱网络的训练过程，让训练更慢。</li>
</ul></li>
</ul>
<h4 id="ensemble">ensemble：</h4>
<ul>
<li>Bagging:从训练集中自助采样，训练多个相互独立的弱学习器，通过一定结合策略形成一个强学习器。</li>
<li>Boosting:
初始化训练一个基学习器→根据表现调整样本分布（预测错误的样本在后续收到更多关注）→训练下一个基学习器→多个学习器加权结合。</li>
</ul>
<h2 id="欠拟合">欠拟合</h2>
<p>定义：欠拟合是指对训练样本的一般性质尚未学好。在训练集及测试集上的表现都不好。</p>
<h3 id="产生欠拟合的原因">产生欠拟合的原因</h3>
<ol type="1">
<li>模型复杂度过低</li>
<li>特征量过少</li>
</ol>
<h3 id="欠拟合的解决办法">欠拟合的解决办法</h3>
<ul>
<li>增加特征数；当特征不足或者现有特征与样本标签的相关性不强时，模型易出现欠拟合。可以通过挖掘上下文特征，ID类特征，组合特征等新的特征，可以取得较好的效果。这属于特征工程相关的内容，如因子分解机，梯度提升决策树，deep_crossing都可以丰富特征。</li>
<li>增加模型复杂度；模型简单时其表达能力较差，容易导致欠拟合，因此可以适当地增加模型复杂度，使模型拥有更强的拟合能力。如线性模型中添加高次项，神经网络中增加网络层数或神经元个数。尝试非线性模型，比如核SVM
、决策树、DNN等模型。</li>
<li>减小正则化系数。正则化是用于防止过拟合的，但是当出现欠拟合时，就有必要针对性地减小正则化系数。</li>
<li>Boosting，Boosting 往往会有较小的 Bias。</li>
<li>调整参数和超参数</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Zheng. w/ his five DADs</title>
    <url>/Life/Zheng-with-his-five-dads/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Invalid Password. Check And Try Again! (♯｀∧´)" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="829dc106f00c1fccc50f3c3896421b07f1d55067ab91d6cf050486eb3e50c8a5">0009b526956f94ef03d39ae6245de4b0df62b63f810ef18ffb43c6d81bdca6991be1f6e0866728f514015e28f5044dd4ac2f1795ab3bd0116158934acf82b72bd25dcda50818f8d4cf33a37357c9374c723876b61a498860ee8fdf1b12077043fcd6b404272af65618fedf26cd30b6a69779d185c4384f8ae27aded4c0256986c9ef47dbab462ee421a50e8d638bd825692ca8c88398e10aec78ad2760785fe0c0456d699da3235a3fa08cab02bf249d233ffa3f5fa3020663eacb74c4d20c242cc5ba696dec7c3cd0b1d20dc794e17b85767b027f33d8cca1f58dbbbf9e2e29cda4ba686efed03445c5e350787d813fee5a587572d1ef414dbcac1d6281fcd49b1504cd7be104b854274c578f010bb957d830841333a1504ff8eb82147a071a4a898d366e0c86d32d191b74ec2ab4d8b274289945603309db9e952a7cc58b5c900b5bd83a758db3790f329379a536ed295ff04a16c4ec327e21081a88fd0bb73a639445e25a01a52fe83a52d34bacc5c1b9389c4a30e42736516c0702eba18cdda59b840d7b3749301e382d09f130db66ec9934d2dd1d3afa1c3416627e2c31031aa1e438f71b11a3c36beed4e3c1f8238cfc4190cefeebd4100b51ad179226e544295c1518d69a2a1fae2da133c5b3babeb3712fb8234c1ce2a2450656b38f8e5b9eeb5b59303aebdcdc974180ace91f30d0cde5c343cb57ee780692fc76982432686cc0e485c5685f268e262c085b79e44af526317f2dbd98134dddd15e31d7588d1e91ad0ed1862f2edcbbe639207e5a3866544e6df0dd1ca61dfe4ab17985b61e5c1ab88c0744dd7dba3d4a72dd05e9380a0f19de47f2e82c5c16e6db31a28132b44e39fa3ed4b752d87eb86ad94192e75056a40c2fb76f0acf409fb3ca569a2c760565c01ddc59c035c4f9ef7f019f311439047de63e96d971b86548cb7e1f18503de2de073e330abeac6b5f67e8dfab3495d842388d560bf8cf5e2cc488609444d9f87813c3faa1067c0ea09a257b89626c9180613a2e7d20658647408b19b72df90f4a79668966890e35371e78f1ef0927db62d8db5fe7ba629dd3f405c0e405a2391728dd5a7a8840b324d65b3e9ab135f50844dc38e5cc5ea5a9729d2b4d53174cdca391bd5bf684adbe089f4ab6a50a505d30c6e0618134ac56ea47cf6b600bf8507180f656cce16c6dc538dc6778f9f20901c50a6a9b14cb695d1fe5a8ff5987594c435274bc163129c321476c6b6c8c9257b06e14eb4f159fa5dbf070fede9d71bf7ebe417a6236518a44c39f9e2389591a333442ef7173160cc54944bc1597cff439278db5054dbc9770a7f806131d8cde31607157e2550a7082570fd1190a39547506c36b44b47095eb24459419bf2a0fe879553407117d1f727f1d504cfe48b2aaa7d5d9b808884c79ed34992ae5931f8f039267790efe2a8405151ba0f4840b2d9add8dffb99c94a255648e193eba7774ff845891533ec64bb2c7af32a71ab1a97c81d8ff5ae5839f04029da00ea0ba8c510ea52807c30b3abd4101da2cf6b11a433a9e8b1809ac2108aa433ecebb0707c02eb4a3978867f9fdcab4f66415b6c9a386a9cd795cfd5e867463f683419f0e6724a9949e100a846ecd70472642635eb6095b5efaebb91a840e9d5e62e26342101c80bcc21f57fde6916edba81156df70c9a10374083eb0c0ecb9003392536b5f5fbfde9e1634d738d9416a3bfb781f624ed5da7594d818c1b98d8c4771d6cf0b6c2c0c7580d78490e3dea05419061289ebe8d8a53d7421fa29a65b070b43d120c41295e7ad1342763ba435e73d276e20a4a4c3bbb1541c2aedbdaa3631d65a7c643514af1e534577c635d5983e253a53c81edfd41a2c84a57be2b40aafa071f45b5f66eef3f1729482eb882f7f332f3eb4cf4e4e1e61655e14896745d50d5e6cacdaf7441e3b93a8f532eb1836705b8050b2d694a3cc28580da4e606f1acddb69f593aa9b614c6e394bdf14d39194527c23f44a9fec05b4c0b8eb13200b91a456e1d5382d79837306ad8f4a6ced669f16a5248e71ec5d967235ea11d4fa292dec74c6be65e98e054ce3648b8b51a2414567cdcebd87d845c12aa8fc62d8d30c27b2b589ebf5bacc21d6cba77efbe8e060f64ea3aa36caecdd7e967794dd70c559c2760f1105380d9cd7a5a4b3bab2806e9a65d01be4332375240a136c4012d4e01a08baca807201b345cdcea61758c546ef1c01be0030c76ef728eacb1d8766bef9b0e74c4f4a86f5b9674756b1bf4e0f47977b8f9386d07b3650bc98c1ecb4854459bdb4236c8e649b8ce78bb5d78c6b2f1ba817d21a7ce6e69636947ac6630ced3301a775b057fde8e523ac09fd4f42ba77351246df76b900a2c0a5c68f6f657bb4426f23f704bdc9be2b259677e9c935bcfaf6065534d154cf28af0b64ce8eb5d76b85e31</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
        <tag>529</tag>
        <tag>Suda</tag>
      </tags>
  </entry>
  <entry>
    <title>Nintendo Memo</title>
    <url>/Game/Nintendo_Memo/</url>
    <content><![CDATA[<p>来这里加任天堂系列掌机好友！</p>
<span id="more"></span>
<h1 id="switch-pro-.jpn">Switch pro .jpn</h1>
<ul>
<li>SW <kbd>6096-3331-7333</kbd></li>
</ul>
<h1 id="clear-black-2ds-.jpn">Clear Black 2DS .jpn</h1>
<ul>
<li>FC <kbd>2638-6497-9254</kbd></li>
<li>NNID zx-will</li>
<li>E-mail <span class="exturl" data-url="bWFpbHRvOno0OTYzNzMxNThAMTYzLmNvbQ==">z496373158@163.com<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="pikachu-new-3ds-xl-.usa">Pikachu New 3DS xl .usa</h1>
<ul>
<li>FC <kbd>1221-3439-8867</kbd></li>
<li>NNID willkyu</li>
<li>E-mail <span class="exturl" data-url="bWFpbHRvOjQ5NjM3MzE1OEBxcS5jb20=">496373158@qq.com<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="colourful-star-new-3ds-.jpn">Colourful Star New 3DS .jpn</h1>
<ul>
<li>FC <kbd>1049-5610-3284</kbd></li>
<li>NNID willQkyu</li>
<li>E-mail <span class="exturl" data-url="bWFpbHRvOndpbGwxMjMzMjEwQDE2My5jb20=">will1233210@163.com<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="ambassador-new-3ds-.eur">Ambassador New 3DS .eur</h1>
<ul>
<li>FC <kbd>1264-3252-0970</kbd></li>
<li>NNID willkyu13</li>
<li>E-mail <span class="exturl" data-url="bWFpbHRvOndpbGxxa3l1QGdtYWlsLmNvbQ==">willqkyu@gmail.com<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="pearl-white-new-3ds-ll-.jpn">Pearl White New 3DS ll .jpn</h1>
<ul>
<li>FC <kbd>1135-2937-9812</kbd></li>
<li>NNID willQQ</li>
<li>E-mail <span class="exturl" data-url="bWFpbHRvOjIxMzY3MDc2NjJAcXEuY29t">2136707662@qq.com<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Memo</category>
      </categories>
      <tags>
        <tag>Game</tag>
        <tag>Memo</tag>
        <tag>Nintendo</tag>
      </tags>
  </entry>
  <entry>
    <title>锁闪宝可梦汇总</title>
    <url>/Pokemon/Shiny-Lock/</url>
    <content><![CDATA[<p>游戏内锁闪宝可梦汇总.
不包含配信的闪光宝可梦与联动的宝可梦(如SwSh伙伴皮卡丘伊布、BdSp首发特典等).</p>
<p>如有纰漏请在下方留言或<a href="/about/">与我联系</a>.</p>
<p>封面 [ID:57993916].</p>
<span id="more"></span>
<h1 id="shiny-lock">Shiny-Lock</h1>
<p>若想要直接查看所有能够闪光的定点宝可梦，点击<a
href="https://aminoapps.com/c/pokemon/page/item/gen-1-7-shiny-locked/28hw_ImqqrQ6q8LKZodjqnv7exBnle">这里</a>查看英文版本（不全）.</p>
<p><strong>几乎所有与游戏内NPC交换的宝可梦均无法闪光</strong>，参见神百<a
href="https://wiki.52poke.com/wiki/%E6%B8%B8%E6%88%8F%E5%86%85%E8%BF%9E%E6%8E%A5%E4%BA%A4%E6%8D%A2%E5%88%97%E8%A1%A8">游戏内连接交换列表</a>.
<strong><em>除了第一世代与NPC的交换、LpLe与NPC的交换、SwSh铠之孤岛中与易蒂的交换、XD中与NPC的交换</em></strong>.</p>
<h2 id="第一世代与第二世代">第一世代与第二世代</h2>
<ul>
<li><strong>梦幻</strong>（存在争议）</li>
<li><strong>所有性别比7：1中，性别为母的宝可梦</strong></li>
<li>第一世代<strong>所有路闪</strong></li>
</ul>
<h2 id="第三世代">第三世代</h2>
<ul>
<li>日版Co特典盘的<strong>时拉比</strong>与<strong>皮卡丘</strong></li>
<li>Co黄铁镇赠送的<strong>正电拍拍</strong></li>
<li>XD所有黑暗宝可梦</li>
</ul>
<h2 id="第四世代">第四世代</h2>
<ul>
<li><strong>刺刺耳皮丘</strong></li>
<li><strong>玛纳霏的蛋</strong>（可以通过游戏漏洞刷闪）</li>
<li>HgSs湛蓝市NPC赠送的<strong>壶壶</strong>（原版金银不锁）</li>
<li>HgSs满金市闸口裕司赠送的<strong>烈雀</strong>（原版金银不锁）</li>
</ul>
<h2 id="第五世代">第五世代</h2>
<ul>
<li>自由庭园岛的<strong>比克提尼</strong></li>
<li>BW飞云市赠送的<strong>索罗亚</strong>（需要四代配信的时拉比触发剧情）</li>
<li>BW迷幻森林的<strong>索罗亚克</strong>（需要四代配信的闪光凤王卫队之一触发剧情）</li>
<li>BW与BW2的<strong>雷希拉姆</strong>与<strong>捷克罗姆</strong></li>
<li>BW2的所有<strong>隐藏洞穴宝可梦</strong></li>
<li>BW2的所有<strong>N的宝可梦</strong></li>
<li>BW2的所有<strong>赠送宝可梦</strong>（如松露赠送的隐藏特性伊布）</li>
</ul>
<h2 id="第六世代">第六世代</h2>
<ul>
<li>XY７号道路拦路的<strong>卡比兽</strong></li>
<li>XY的<strong>哲尔尼亚斯</strong>与<strong>伊裴尔塔尔</strong></li>
<li>XY游走的<strong>急冻鸟</strong>、<strong>闪电鸟</strong>与<strong>火焰鸟</strong></li>
<li>XY无名洞窟的<strong>超梦</strong></li>
<li>XY剧情赠送的<strong>路卡利欧</strong></li>
<li>XY终结洞窟50%的<strong>基格尔德</strong></li>
<li>XY密阿雷市旭日咖啡馆卡露妮赠送的<strong>拉鲁拉丝</strong></li>
<li>OrAs初始<strong>土狼犬</strong></li>
<li>OrAs<strong>换装皮卡丘</strong></li>
<li>OrAs的<strong>古拉顿</strong>、<strong>盖欧卡</strong>与<strong>裂空座</strong></li>
<li>OrAs的<strong>代欧奇希斯</strong></li>
</ul>
<h2 id="第七世代">第七世代</h2>
<ul>
<li>SM与UsUm的守护神<strong>卡璞・鸣鸣</strong>、<strong>卡璞・蝶蝶</strong>、<strong>卡璞・哞哞</strong>与<strong>卡璞・鳍鳍</strong></li>
<li>日轮湖月轮湖进入另一个世界的<strong>科斯莫古</strong></li>
<li>SM与UsUm的<strong>索尔迦雷欧</strong>、<strong>露奈雅拉</strong>与<strong>奈克洛兹玛</strong></li>
<li>SM与UsUm的<strong>基格尔德</strong></li>
<li>SM与UsUm购物广场古董精品店赠送的<strong>玛机雅娜</strong></li>
<li>SM的所有<strong>究极异兽</strong></li>
<li>UsUm火箭队城堡的<strong>顽皮雷弹</strong></li>
<li>UsUm的所有<strong>霸主宝可梦</strong></li>
<li>帽子皮卡丘（没有闪光形态但可以闪光）</li>
<li>LpLe初始搭档<strong>皮卡丘</strong>与<strong>伊布</strong></li>
</ul>
<h2 id="第八世代">第八世代</h2>
<ul>
<li>SwSh初始御三家<strong>敲音猴</strong>、<strong>炎兔儿</strong>与<strong>泪眼蜥</strong></li>
<li>SwSh５号道路寄放屋赠送的<strong>毒电婴</strong></li>
<li>SwSh３号道路工厂禁区附近岩石上的<strong>蓝鸦</strong></li>
<li>SwSh对战塔的<strong>属性：空</strong></li>
<li>SwSh的<strong>苍响</strong>、<strong>藏玛然特</strong>与<strong>无极汰那</strong></li>
<li>SwSh木杆镇的伽勒尔<strong>呆呆兽</strong></li>
<li>SwSh丹帝赠送的<strong>小火龙</strong></li>
<li>SwSh铠之孤岛地鼠训练家赠送的所有<strong>阿罗拉宝可梦</strong></li>
<li>SwSh冠之雪原球湖湖畔的<strong>凯路迪欧</strong></li>
<li>SwSh冠之雪原冻凝村赠送的<strong>科斯莫古</strong></li>
<li>SwSh冠之雪原极巨巢穴赠送的<strong>毒贝比</strong></li>
<li>SwSh铠之孤岛马师傅武馆赠送的<strong>熊徒弟</strong>、<strong>妙蛙种子</strong>、<strong>杰尼龟</strong>与<strong>多边兽</strong></li>
<li>SwSh冠之雪原王冠神殿的<strong>雪暴马</strong>、<strong>灵幽马</strong>与<strong>蕾冠王</strong></li>
<li>SwSh冠之雪原伽勒尔形态的<strong>急冻鸟</strong>、<strong>闪电鸟</strong>与<strong>火焰鸟</strong></li>
<li>BdSp狗都不玩（口嗨）</li>
<li>La初始御三家<strong>木木枭</strong>、<strong>火球鼠</strong>与<strong>水水獭</strong></li>
<li>La纯白冻土副任务83赠送的<strong>阿罗拉六尾</strong></li>
<li>La湖之传说的宝可梦<strong>由克希</strong>、<strong>艾姆利多</strong>与<strong>亚克诺姆</strong></li>
<li>La神话的宝可梦<strong>帝牙卢卡</strong>、<strong>帕路奇亚</strong>与<strong>骑拉帝纳</strong></li>
<li>La的<strong>席多蓝恩</strong>、<strong>克雷色利亚</strong>与<strong>雷吉奇卡斯</strong></li>
<li>La海边小洞副任务66的<strong>霏欧纳</strong>与<strong>玛纳霏</strong>，以及之后刷新的<strong>霏欧纳</strong></li>
<li>La的化身宝可梦<strong>龙卷云</strong>、<strong>雷电云</strong>、<strong>土地云</strong>和<strong>眷恋云</strong></li>
<li>La的<strong>阿尔宙斯</strong></li>
</ul>
]]></content>
      <categories>
        <category>Pokemon</category>
      </categories>
      <tags>
        <tag>Pokemon</tag>
        <tag>Shiny</tag>
      </tags>
  </entry>
  <entry>
    <title>LATEX笔记</title>
    <url>/Learning/Notes/LATEX/</url>
    <content><![CDATA[<p>记录LATEX的一些知识点.</p>
<p>大部分内容来自中国 CTEX 用户小组译制的<em>一份不太简短的 LATEX 2ε
介绍</em>.</p>
<p>未完待续.</p>
<span id="more"></span>
<h1 id="基本知识">基本知识</h1>
<h2 id="latex源文件">LATEX源文件</h2>
<p>LATEX 源文件的格式为普通的 ASCII
文件，你可以使用任何文本编辑器来创建。</p>
<h3 id="空白距离">空白距离</h3>
<p>LATEX
将空格和制表符等空白字符视为相同的空白距离（space）。<strong>多个连续的空白字符等同为一个空白字符。</strong>在
LATEX
文件中，每行开始的空白字符将被忽略，而单个的回车符被视为一空格。</p>
<p>LATEX
使用空行来结束段落，两行文本中的空行标志上一段落的结束和新段落的开始。如同空格一样，多个空行所起的作用和一个空行的作用是相同的。</p>
<h3 id="特殊字符">特殊字符</h3>
<p>下面的这些字符是 LATEX 的保留字符:</p>
<p># $ % ^ &amp; _ { } ~ \</p>
<p>在这些字符（除' \ '）前加上' \ '就可以在文本中得到，而'
\ '为断行命令.</p>
<p>命令<code>$\backslash$</code>将生成 ' \ '。</p>
<h3 id="latex命令">LATEX命令</h3>
<p>LATEX 命令（commands）是大小写敏感的并有下面两种格式：</p>
<ul>
<li>以一反斜线' \
'开始，加上只包含字母字符命令名组成。命令名后的空格符、数字或其它非字母字符标志该命令的结束。</li>
<li>由一反斜线和一特殊字符组成。</li>
</ul>
<p>LATEX
忽略命令后面的空格。如果你希望在命令后面得到一空格，可以在命令后面加上
{} 和一个空格，或者加上一个特殊的空白距离命令。{} 将阻止 LATEX
吞噬掉命令后面的空格。例如: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I read that Knuth divides the people working with \TeX&#123;&#125; into \TeX&#123;&#125;nicians and \TeX perts.\\ Today is \today.</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I read that Knuth divides the people working with TEX into TEXnicians and EXperts. </span><br><span class="line">Today is 8th March 2003.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>许多命令需要一个参数（parameter）并用一对大括号（curly braces）{
}将其括起来置于命令名称的后面。也有一些命令支持用方括号（square
brace）括起来的可选参数。</p>
<h3 id="注释">注释</h3>
<p>当 LATEX 在处理源文件时，如果遇到一个百分号字符 %，那么 LATEX将忽略 %
后的该行文本，分行符以及下一行开始的空白字符。这样，我们就可以在源文件中写一些注释，而不会担心他们会出现在最后的排版结果中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is an % stupid</span><br><span class="line">% Better: instructive &lt;----</span><br><span class="line">example: Supercal%</span><br><span class="line">             ifragilist%</span><br><span class="line">      icexpialidocious</span><br></pre></td></tr></table></figure>
<p>得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is an example: Supercalifragilisticexpialidocious</span><br></pre></td></tr></table></figure>
<p>% 也可以用来分割不允许有空格或分行的较长输入文本。</p>
<h2 id="源文件的结构">源文件的结构</h2>
<p>LATEX 需要所处理的源文件遵从一定的结构，每个 LATEX
文档必须以如下的命令开始： <code>\documentclass&#123;...&#125;</code></p>
<p>这个命令指定了你所写的文档的类别。在此之后，你可以加入控制文档式
样的命令，或者使用命令 <code>\usepackage&#123;...&#125;</code>
来调入一些宏集，进而为 LATEX 系统增添 一些新的功能。</p>
<p>当完成所有的设置后，你可利用命令<code>\begin&#123;document&#125;</code>来开始你的文档.<code>\documentclass</code>
和 <code>\begin&#123;document&#125;</code> 之间的区域称作导言区。</p>
<p>现在你可以输入你所希望排版的文本和所使用的一些 LATEX
命令。在文档的最后键入命令<code>\end&#123;document&#125;</code>来告诉 LATEX
你的文档到此结束，从而使 LATEX忽略文档在此命令之后的部分。</p>
<h2 id="文档布局">文档布局</h2>
<h3 id="文档类">文档类</h3>
<p>当 LATEX
处理源文件时，首先需要知道的是作者所要创建的文档类型。该信息可以通过命令<code>\documentclass[options]&#123;class&#125;</code>来提供给
LATEX。例如，一个 LATEX 源文件以下面一行开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass[11pt,twoside,a4paper]&#123;article&#125;</span><br></pre></td></tr></table></figure>
<p><code>&#123;class&#125;</code>可以是： - article
排版科技期刊、短报告、程序文档、邀请函等。 - report
排版多章节的长报告、短篇的书籍、博士论文等。 - book 排版书籍。 - slides
排版幻灯片。其中使用了较大的 sans serif 字体。也可以考虑使用 FoilTEX
来得到相同的效果。</p>
<p><code>options</code>可以包含： - 10pt, 11pt, 12pt
设置文档所使用的字体的大小。如果没有声明任何选项，缺省将使用 10pt 字体。
- a4paper, letterpaper, . . .
定义纸张的大小，缺省的设置为letterpaper。此外，还可以使用a5paper，b5paper，executivepaper
和 legalpaper。 - fleqn 设置该选项将使数学公式左对齐，而不是中间对齐。 -
leqno 设置该选项将使数学公式的编号放置于左侧。 - titlepage, notitlepage
指定是否在文档标题（document title）后开始一新页。article
文档类缺省不开始新页，而 book 文档类则相反。 - onecolumn, twocolumn 指定
LATEX 以单列（one column）或双列（two column）方式排版文档。 - twoside,
oneside 指定 LATEX 排版的文档为双面或单面格式。article 和 report
缺省使用单面格式，而 book
则缺省使用双面格式。需要注意的是该选项仅作用于文档的式样。twoside选项不会通知你的打印机让以得到双面的打印输出。
- openright, openany
此选项决定新的章是仅仅在右边页（奇数页）还是在下一可用页开始。该选项对
article 文档类不起作用，因为该类中并没有定义“章”（Chapter）。report
类中新的一章开始于下一可用页，而 book 类中新的一章总是开始于右边页。</p>
<h3 id="宏包">宏包</h3>
<p>如果你想插入图形、彩色文本或源代码文件，你需要使用宏包来增强 LATEX
的功能。调入宏包使用如下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\usepackage[options]&#123;package&#125;</span><br></pre></td></tr></table></figure>
<p>这里 package 是宏包的名称，options
是用来触发宏包中的特殊功能的一组关键词。</p>
<h2 id="各类latex文件">各类LATEX文件</h2>
<ul>
<li>.tex LATEX 或 TEX 源文件。可以用 latex 处理。</li>
<li>.sty LATEX 宏包文件。可使用命令
将其加载到你的 LATEX 文件中。</li>
<li>.dtx 文档化 TEX 文件。这也是 LATEX 宏包发布的主要格式。通过处理一个
dtx 文件就可以得到该 LATEX 宏中所包括的宏代码文档。</li>
<li>.ins 为相应的 .dtx 文件的安装文件。如果你在网络上下载了一 LATEX
宏包，你通常会发现会有一个 .dtx 和一个 .ins 文件。使用 LATEX 对 .ins
文件进行处理，可以从 .dtx 文件中提取出宏包。</li>
</ul>
<p>当你运行 LATEX 处理你的源文件时，会得到下列文件：</p>
<ul>
<li>.dvi 与设备无关文件。这是 LATEX 编译运行的主要结果。你可以使用
DVI预览器浏览其内容，或者使用像 dvips 这样的应用程序输出到打印机。</li>
<li>.log 记录了上次编译运行时的详细信息。</li>
<li>.toc
存储了所有章节标题。该文件将在下次编译运行时被读入并生成目录。</li>
<li>.lof 类似 .toc 文件，可生成图形目录。</li>
<li>.lot 类似 .toc 文件，可生成表格目录。</li>
<li>.aux
另一个用来向下次编译运行传递信息的辅助文件。除了其它信息外，.aux
文件通常包含交叉引用信息。</li>
<li>.idx 如果你的文件中包含有索引，LATEX
使用此文件存储所有的索引词条。此文件需要使用 makeindex 处理。</li>
<li>.ind 经过处理后的 .idx
文件。可在下次编译运行时加入到你的文档中。</li>
<li>.ilg 运行 makeindex 时生成的记录文件。</li>
</ul>
<h3 id="页面式样">页面式样</h3>
<p>LATEX
支持三种预定的页眉、页脚（header/footer）格式，称为页面式样（page
styles）。命令 <code>\pagestyle&#123;style&#125;</code>
中的参数定义了所使用页面式样。</p>
<ul>
<li>plain 页眉为空，页脚由居中的的页码组成。这是默认的页面式样。</li>
<li>headings 页眉由当前的章节标题和页码组成，页脚为空。</li>
<li>empty 设置页眉、页脚均为空。</li>
</ul>
<p>可以使用下面的命令改变当前页的页面式样：
<code>\thispagestyle&#123;style&#125;</code></p>
<h2 id="大型文档">大型文档</h2>
<p>当处理大型文档时，最好将源文件分成几个部分。LATEX
有两条命令来处理这种情况。</p>
<p>在文档的正文中使用命令 <code>\include&#123;filename&#125;</code> 可将文件名为
<strong>filename.tex</strong> 的内容包括进来。注意 LATEX 在开始处理
<strong>filename.tex</strong> 的内容之前将会开始一新页。</p>
<p>第二个命令 <code>\includeonly&#123;filename,filename,. . . &#125;</code>
可用在文档的导言区，它允许你指导 LATEX 仅仅读入某些 <strong>*
文件。这条命令在导言区被 LATEX 读入执行后，在所有的 </strong>*
命令中，只有 <strong>*
命令参数中列出的文件才会被执行。</strong><em>注意在参数中，文件名和逗号之间不能有空格</em>**。</p>
<p><strong>* 命令在新页上排版包括进来的文本，这对于使用
</strong>*命令很有帮助。应为即使一些包括的文件被忽略，分页处也不会变更。如果不想在新页排版包括进来的文本，可使用下面的命令：<strong></strong>
该命令只是简单地将指定的文件包括进来，并没有其它限制。</p>
<p>使用 <em>syntonly</em> 宏包可以让 LATEX 快速的检查你的文档：LATEX
浏览你的文档，仅仅检查语法和所使用的命令是否正确，不会产生 DVI
输出。在这种模式下，LATEX
运行的非常快，可以节省可观的时间。使用方法非常简 单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;syntonly&#125;</span><br><span class="line">\syntaxonly</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="文档排版">文档排版</h1>
<h2 id="文档和语言的结构">文档和语言的结构</h2>
<p>在 LATEX
中段落是最重要的文档单位。我们之所以称之为“文档单位”，因为段落是反映一个连贯思想或观点的排版风格形式。在下面的章节中你将学习如何用
<code>\\</code>
强行断行，通过在源文件中留一空行强行转段。所以，<strong>如果开始一个新思想，就另起一段，否则，只应使用断行</strong>。如果还犹豫是否应转段，可以把文档想象为观点和思想的传递者。如果旧的思路还在继续，就不应转段。如果同一段中出现了全新的思路，就应该另起一段。</p>
<p>下一个较小的文档单位是句子。在英语文档中，在一个句子结尾处句号后的空间大于缩写词句号后的空间。LATEX
试图分辨出你需要那一个。如果 LATEX 分辨错了，你必须告诉 LATEX
你到底需要什么。</p>
<p>句子也有结构。大多数语言具有非常复杂的标点符号系统，但是在很多语言中（包括德语和英语）只要你记住它表示什么：语言流中的短暂停顿，你就能近乎完美地使用逗号。如果你不肯定在哪里使用逗号，就大声地朗读这个句子，在每个逗号处做一短呼吸。在什么地方如果你感到别扭，就删掉这个逗号；如果在什么地方，你感到必须呼吸（或做了短暂停顿）就插入一个逗号。</p>
最后，通过分成章、节、子节等形式，文档中的段落应该按逻辑在更高的层次进行组织。但是，使用
<p>的排版效果是如此明显，以致如何使用这些高水平的结构几乎是不证自明的。</p>
<h2 id="断行和分页">断行和分页</h2>
<h3 id="段落整理">段落整理</h3>
<p>通常书籍是用等长的行来排版的。为了优化整个段落的内容，LATEX
在单词之间插入必要的断行点（linebreak）和间隔。如果一行的单词排不下，LATEX
也会进行必要的断字。段落如何排版依赖于文档类别。通常，每一段的第一行有缩进，在两段之间没有额外的间隔。</p>
<p>在特殊情形下，有必要命令 LATEX 断行：</p>
<ul>
<li><code>\\</code> 或 <code>\newline</code>
另起一行，而不另起一段。</li>
<li><code>\\*</code> 在强行断行后，还禁止分页。</li>
<li><code>\newpage</code> 另起一新页。</li>
<li><code>\linebreak[n], \nolinebreak[n], \pagebreak[n] and \nopagebreak[n]</code>上述命令的效果可以从它们的名称看出来。通过可选参数
n，作者可以影响这些命令的效果。n 可以置为 0 和 4
之间的数。如果命令的效果看起来非常差，把 n 取为小于 4 的数，可以让 LATEX
选择忽略这个命令。不要这些“break” 命令与 “new” 命令混淆。即使你给出了
“break” 命令，LATEX
仍然试图对齐页面的右边界。如果你真想另起一行，就使用相应的命令。</li>
</ul>
<p>LATEX 总是尽可能产生最好的断行效果。如果断行无法达到 LATEX
的高标准，就让这一行在段落的右侧溢出。然后在处理输入文件的同时，报告溢出的消息（“overfull
hbox”）。这最可能发生在 LATEX 找不到合适的地方断字时候。你可以使用
<code>\sloppy</code> 命令，告诉 LATEX
降低一点儿标准。虽然最终的输出结果不是最优的，它通过增加单词之间的间隔，以防止出现过长的行。在这种情况下给出警告（“underfull
hbox”）。在大多数情况下得到的结果看起来不会非常好。<code>\fussy</code>
命令把 LATEX 恢复为缺省状态。</p>
<p>当发生（“overfull hbox”）时，虽然 LATEX
给出一个警告并显示溢出的那一行，但是不太容易发现溢出的行。如果你在
<strong>\documentclass</strong> 命令中使用选项 <em>draft</em>，LATEX
就在溢出行的右边标以粗黑线。</p>
<h3 id="断字">断字</h3>
<p>必要时就会出现断字。如果断字算法不能确定正确的断字点，可以使用如下命令告诉
TEX 如何弥补这个缺憾。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\hyphenation&#123;word list&#125;</span><br></pre></td></tr></table></figure>
<p>使列于参量中的单词仅在注有 “-”
的点断字。命令的参量仅由正常字母构成的单词，或由激活文本中视为正常字母的符号组成。应用于（特殊）语言的已存好，当断字命令出现时，就为激活的语言储存断字可选点。这意
味着如果你在文档导言中设置了断字命令，它将影响英文的断字。如果断字命令置于
\begin{document} 后面，而且你正使用类似 babel
的国际语言支持宏包，那么断字可选点在由 babel
激活的语言中就处于活动状态。</p>
<p>下面的例子允许对 “hyphenation” 和 “Hyphenation”
进行断字，却根本不允许 “FORTRAN”, “Fortran” 和 “fortran”
进行断字。在参量中不允许出现特殊的字符和符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\hyphenation&#123;FORTRAN Hy-phen-a-tion&#125;</span><br></pre></td></tr></table></figure>
<p>命令 <code>\-</code>
在单词中插入一个自主的断字点。它也就成为这个单词中允许出现的唯一断字点。对于包含特殊字符（注音字符）的单词，这个命令是特别有用的，因为对于包含特殊字符的单词
LATEX 不自动断字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I think this is: su\-per\-cal\-%</span><br><span class="line">i\-frag\-i\-lis\-tic\-ex\-pi\-%</span><br><span class="line">al\-i\-do\-cious</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I think this is: supercalifragilisticexpialido-</span><br><span class="line">cious</span><br></pre></td></tr></table></figure>
<p>命令 <code>\mbox&#123;text&#125;</code>
保证把几个单词排在同一行上。在任何情况下，这个命令把它的参量排在一起（同一行上）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">My phone number will change soon.</span><br><span class="line">It will be \mbox&#123;0116 291 2319&#125;.</span><br><span class="line">The parameter</span><br><span class="line">\mbox&#123;\emph&#123;filename&#125;&#125; should</span><br><span class="line">contain the name of the file.</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">My phone number will change soon. It will</span><br><span class="line">be 0116 291 2319.</span><br><span class="line">The parameter *filename* should contain the</span><br><span class="line">name of the file.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述两星号之间为斜体</p>
</blockquote>
<p>命令 和 类似，此外它还能围绕内容画一个框。</p>
<h2 id="特殊字符串和符号">特殊字符串和符号</h2>
<h3 id="引号">引号</h3>
<p>不要像在打字机上那样，把 " 用作引号。在 LATEX
中有专门的左引号和右引号。在 LATEX 中，用两个 ‘ 产生左引号，用两个 ’
产生右引号。一个 ‘ 和一个 ’ 产生一个单引号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">‘‘Please press the ‘x’ key.’’</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“Please press the ‘x’ key.”</span><br></pre></td></tr></table></figure>
<h3 id="破折号和连字号">破折号和连字号</h3>
<p>LATEX
中有四种短划标点符号。连续用不同数目的短划，可以得到其中的三种。第四个实际不是标点符号，它是数学中的减号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daughter-in-law, X-rated\\</span><br><span class="line">pages 13--67\\</span><br><span class="line">yes---or no? \\</span><br><span class="line">$0$, $1$ and $-1$</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daughter-in-law, X-rated</span><br><span class="line">pages 13–67</span><br><span class="line">yes—or no?</span><br><span class="line">0, 1 and −1</span><br></pre></td></tr></table></figure>
<p>这些短划线的名称是: ‘-’ 连字号，‘--’ 短破折号，‘---’ 长破折号和 ‘−’
减号。</p>
<h3 id="波浪号">波浪号</h3>
<p>波浪号经常和网址用在一起。它在 LATEX 中，可用 ~ 产生，但其结果：˜
却不是你真正想要的。试一下这个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.rich.edu/\~&#123;&#125;bush \\</span><br><span class="line">http://www.clever.edu/$\sim$demo</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.rich.edu/˜bush</span><br><span class="line">http://www.clever.edu/∼demo</span><br></pre></td></tr></table></figure>
<h3 id="度的符号">度的符号 (◦)</h3>
<p>在LATEX中如何排度的符号？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Its $-30\,^&#123;\circ&#125;\mathrm&#123;C&#125;$,</span><br><span class="line">I will soon start to</span><br><span class="line">super-conduct.</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Its −30 ◦C, I will soon start to super-conduct.</span><br></pre></td></tr></table></figure>
<h3 id="省略号">省略号</h3>
<p>在打字机上，逗号或句号占据的空间和其他字母相等。在书籍印刷中，这些字符仅占据一点儿空间，并且与前一个字母贴得非常紧。所以不能只键入三个点来输出‘省略号’，因为间隔划分得不对。我们使用专门的命令
<code>\ldots</code> 输出省略号。</p>
<h3 id="连字">连字</h3>
<p>一些字母组合不是简单键入一个个字母得到得的，而实际上用到了一些特殊符号。
在两个字母之间插入一个
，可以禁止连字。对于由两个词构成的单词，这可能是必要的。</p>
<h3 id="注音符号和特殊字符">注音符号和特殊字符</h3>
<p>LATEX 支持来自许多语言中的注音符号和特殊字符。在字母 i 和 j
上标一个注音符号，它的点儿必须去掉。这个可由 <code>\i</code> 和
<code>\j</code> 做到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H\^otel, na\&quot;\i ve, \’el\‘eve,\\</span><br><span class="line">sm\o rrebr\o d, !‘Se\~norita!,\\</span><br><span class="line">Sch\&quot;onbrunner Schlo\ss&#123;&#125;</span><br><span class="line">Stra\ss e</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hˆotel, na¨ıve, ´el`eve,</span><br><span class="line">smørrebrød, ¡Se˜norita!,</span><br><span class="line">Sch¨onbrunner Schloß Straße</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述为注音符号</p>
</blockquote>
<h2 id="支持使用国际语言">支持使用国际语言</h2>
<p>略</p>
<h2 id="单词的间隔">单词的间隔</h2>
<p>为了使输出的右边界对齐，LATEX
在单词间插入不等的间隔。在句子的末尾插入的空间稍多一些，因为这使得文本更具可读性。<strong>LATEX
假定句子以句号、问号或惊叹号结尾</strong>。<strong>如果句号紧跟一个大写字母，它就不视为句子的结尾</strong>。因为一般在有缩写地方，才出现句号紧跟大写字母的情况。</p>
<p>作者必须详细说明，这些假设中的任何一个例外。空格前的反斜线符号产生一个不能伸长的空格。波浪字符
‘~’ 也产生一个不能伸长的空格，并且禁止断行。句号前的命令 @
说明这个句号是句子的末尾，即使它紧跟一个大写字母。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mr.~Smith was happy to see her\\</span><br><span class="line">cf.~Fig.~5\\</span><br><span class="line">I like BASIC\@. What about you?</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mr. Smith was happy to see her</span><br><span class="line">cf. Fig. 5</span><br><span class="line">I like BASIC. What about you?</span><br></pre></td></tr></table></figure>
<p>命令 <code>\frenchspacing</code> 能禁止在句号后插入额外的空间，它告诉
LATEX
在句号后不要插入比正常字母更多的空间。除了参考文献，这在非英语语言中非常普遍。如果使用了
<code>\frenchspacing</code>，命令 <code>\@</code> 就不必要了。</p>
<h2 id="标题章和节">标题，章和节</h2>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>LATEX</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵及其存储格式（COO、CSR、CSC）</title>
    <url>/Learning/Notes/Sparse-Matrix/</url>
    <content><![CDATA[<blockquote>
<p>在矩阵中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为<strong>稀疏矩阵</strong>；与之相反，若非0元素数目占大多数时，则称该矩阵为稠密矩阵。定义非零元素的总数比上矩阵所有元素的总数为矩阵的稠密度。简单来说,<em>稀疏矩阵就是绝大部分都是0的矩阵,只包含很少的非零值</em>.</p>
</blockquote>
<p>封面 [ID:79498766].</p>
<span id="more"></span>
<h1 id="稀疏矩阵">稀疏矩阵</h1>
<p>例如：</p>
<p><span class="math display">\[
\begin{pmatrix}
    1 &amp; 2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 3 &amp; 4 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 5 &amp; 6 &amp; 7 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 8 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 9 \\
\end{pmatrix}
\]</span></p>
<p>上述稀疏矩阵非零元素有9个，26个零值，稀疏性是74%。</p>
<p>稀疏矩阵因为绝大部分都是0元素,如果我们仍然按照普通方式存储,无疑会浪费很多空间;同时如果进行运算时,0元素对最终结果也没有帮助,增加了许多无效计算.
因此,我们需要设计出新的存储方式,或者说数据结构来存储稀疏矩阵.比较常见的有：</p>
<ul>
<li>DOK: Dictionary of keys. 将非零元素的坐标 <strong>(row,
column)</strong>
作为<strong>key</strong>,非零元素值作为<strong>value</strong>,只存储非零元素值.
可以以任意顺序逐渐构建稀疏矩阵;但是按某种顺序访问非零元素时比较困难.
通常用来构建矩阵,然后再把矩阵转换成别的方式.</li>
<li>COO: Coordinate list. 坐标格式.
三个数组<strong>row</strong>,<strong>col</strong>,<strong>value</strong>分别存储非零元素坐标的行,列以及非零值.
理论上稀疏矩阵中的元素在存储时顺序是任意的,但是为了方便元素访问,存储时先按照先左后右,先上后下顺序进行存储(left
to right, top to buttom).</li>
<li>CSR: Compressed Sparse Row. 压缩稀疏行</li>
<li>CSC: Compressed Sparse Column. 压缩稀疏列,和CSR类似.</li>
</ul>
<h1 id="coo">COO</h1>
<p>我们使用三个数组row,column和data分别用来存储非零元素坐标的row_index,col_index,以及数值.比如:</p>
<figure>
<img data-src="/images/body/Sparse-Matrix/COO.webp" alt="COO" />
<figcaption aria-hidden="true">COO</figcaption>
</figure>
<p>三个数组的长度都是NNO.data[i] (NNO:The number of
nonzero.矩阵非零元素个数),在原稀疏矩阵中的坐标为(row[i],col[i]]).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from scipy.sparse import *</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; row = [0,0,1,1,2,2,2,3,3]</span><br><span class="line">&gt;&gt;&gt; col = [0,1,1,2,0,2,3,1,3]</span><br><span class="line">&gt;&gt;&gt; data = [1,7,2,8,5,3,9,6,4]</span><br><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; coo = coo_matrix((data,(row,col)),shape=(4,4),dtype=np.int)</span><br><span class="line">&gt;&gt;&gt; coo</span><br><span class="line">&lt;4x4 sparse matrix of type &#x27;&lt;class &#x27;numpy.int64&#x27;&gt;&#x27;</span><br><span class="line">    with 9 stored elements in COOrdinate format&gt;</span><br><span class="line">&gt;&gt;&gt; coo.todense()</span><br><span class="line">matrix([[1, 7, 0, 0],</span><br><span class="line">        [0, 2, 8, 0],</span><br><span class="line">        [5, 0, 3, 9],</span><br><span class="line">        [0, 6, 0, 4]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以发现,这种存储方式中,row数组和column数组中有一定的重复元素.我们是否可以针对这个冗余特性进一步进行压缩?
之后的CSR,CSC,分别是对row数组和column数组进行了压缩.</p>
<h1 id="csr与csc">CSR与CSC</h1>
<ul>
<li>V，用来存储矩阵中的非零元素的值；</li>
<li>COL_INDEX，第i个元素记录了V[i]元素的列数；</li>
<li>ROW_INDEX, 第i个元素记录了前i-1行包含的非零元素的数量。
进一步，令a=ROW_INDEX[row], b = ROW_INDEX[row+1]，则V[a,
b)的行数等于row，再结合COL_INDEX，即可得到非零元素的行数和列数。</li>
</ul>
<p><span class="math display">\[
\begin{pmatrix}
    1 &amp; 2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 3 &amp; 4 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 5 &amp; 6 &amp; 7 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 8 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 9 \\
\end{pmatrix}
\]</span></p>
<p>其中 V = [1, 2, 3, 4, 5, 6, 7, 8, 9] COL_INDEX = [0, 1, 1, 2, 2, 3,
4, 5, 6] ROW_INDEX = [0, 2, 4, 7, 8, 9]</p>
<p>假如我们想得到“7”的坐标位置，通过V得到index为6，通过COL_INDEX得到列数为4；
4 ∈ [4,7) ，所以行数为2，最终7的坐标为(2, 4).</p>
<p><strong>CSC同理.</strong></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Knowledage-Graphs</tag>
      </tags>
  </entry>
  <entry>
    <title>GraIL相关论文阅读笔记</title>
    <url>/Learning/Notes/Papers/GraIL/</url>
    <content><![CDATA[<p>论文 <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE5MTEuMDY5NjI=">Inductive relation
prediction by subgraph reasoning<i class="fa fa-external-link-alt"></i></span> 阅读笔记. 译文可见<a
href="https://pan.baidu.com/s/1IXtIZhYJFkEciqEPflWKuQ"
class="uri">https://pan.baidu.com/s/1IXtIZhYJFkEciqEPflWKuQ</a>，提取码<em>will</em>.</p>
<span id="more"></span>
<p>相关代码见<a
href="https://github.com/kkteru/grail">作者的GitHub</a>.</p>
<h1 id="背景">背景</h1>
<h2 id="现实背景">现实背景</h2>
<p>知识图谱（Knowledge
Graph，KG）是人工智能的重要分支技术，它在2012年由谷歌提出，是结构化的语义知识库，用于以符号形式描述物理世界中的概念及其相互关系，其基本组成单位是
<strong>“实体—关系—实体”（Facts： Head_Entity - Relation - Tail_Entity,
i.e., (h; r;
t)）三元组，以及实体及其相关属性—值对</strong>，实体间通过关系相互联结，构成网状的知识结构<a
href="#reference">1</a>。知识图谱本质上是一种叫作语义网络的知识库，即一个具有有向图结构的知识库，其中图的结点代表实体或者概念，而图的边代表实体/概念之间的各种语义关系<a
href="#reference">2</a>.</p>
<p>知识图谱的链接预测方法主要通过学习和操作实体和关系的潜在表示（即嵌入
embeddings）。然而这些基于嵌入的方法并没有明确地捕获知识图谱背后的组合逻辑规则，本质上假设图中的实体集是固定的——这种假设通常被称为直推式设置（Transductive
Setting），仅限于<em>直推式学习（Transductive
learning）</em>而不是<em>归纳式学习（Inductive
learning）</em>。因此我们使用了一个基于图神经网络的关系预测框架
<strong>GraIL</strong><a
href="#reference">3</a>，其对局部子图结构进行推理，并且具有很强的归纳能力来学习与实体无关的关系语义。与基于嵌入的模型不同，GraIL
是自身便具有归纳能力，可以在训练后泛化到无联通增量中。<a
href="#reference">3</a>提供了理论证明和强有力的经验证据，证明 GraIL
可以代表有用的一阶逻辑子集，还表明 GraIL
在归纳设置中优于现有的Baseline。<a
href="#reference">3</a>还展示了通过在直推式设置中将 GraIL
与各种知识图谱嵌入方法集成来获得的显著收益，突出了该方法的互补归纳倾向。</p>
<h2 id="在做什么">在做什么</h2>
<p>预测与另一个给定实体具有特定关系的实体，即<em>链接预测（Link
Prediction）</em>————给定头尾实体、关系三者中的任意两者，预测剩下那个，即<em>实体预测（Entity
Prediction）</em>或<em>实体排名（Entity Ranking）</em> <strong>（(?; r;
t)、(h; r; ?)）</strong> 和 <em>关系预测（Relation Prediction）</em>
<strong>（(h; ?; t)）</strong>。这本质上是
KG补全，即向图中添加缺失的知识（实体/关系），
通过事先学习的实体和关系表示，链接预测可以简单地通过排序过程来执行。例如预测任务(?;
r; t) 要预测头实体，可以将KG中的每个实体 h0 作为候选答案，计算得分fr(h0,
t)后进行排序。一旦在 KG
上训练了嵌入模型，就可以通过使用学习的嵌入和评分函数轻松实现这一点。</p>
<p>一种常见的做法是在有序列表中记录正确答案的排名，以便查看正确答案是否可以排在错误答案之前。例如预测
(?, DirectorOf, Psycho) 时，得到了有序列表[JamesCameron,
AlfredHitchcock, GeorgeLucas, QuentinTarantino]，正确答案
AlfredHitchcock 的排名为
2。排名越靠前表示性能越好。基于这些排名设计了各种评估指标，例如，<strong>mean
rank</strong>（预测排名的平均值）、<strong>mean reciprocal rank</strong>
（倒数排名的平均值）、<strong>Hits@n</strong>（排名不大于 n
的比例）、<strong>AUC-PR</strong>（精确召回曲线下的面积）。</p>
<h2 id="存在什么问题">存在什么问题</h2>
<p>对于直推式学习来说，链接预测如上所述般简单，但在许多情况下，我们通过引入与实体无关的逻辑规则来寻求具有归纳能力的算法。许多现实世界的知识图谱都在不断发展，随着时间的推移会添加新的节点或实体，例如电子商务平台上的新用户和产品或生物医学知识图谱中的新分子。面对无联通增量知识图谱进行链接预测，需要归纳式学习模型。训练无需昂贵的重新计算即可对这些新实体进行预测的能力的机器学习模型至关重要。尽管归纳式学习模型具有这一关键优势，但它们仍存在可扩展性问题，并且缺乏那些基于嵌入的方法的表达能力。</p>
<h2 id="使用的方法">使用的方法</h2>
<p>使用<em>图神经网络（GNN: Graph Neural Networks）框架</em>
<strong>GraIL（Graph Inductive Learning）</strong>，
其具有很强的归纳学习与实体无关的关系语义的能力。通过学习候选关系周围的子图结构来进行关系预测，学习对独立于任何特定节点身份的子图结构进行推理，能够自然地推广到无联通增量知识图谱中的节点。<a
href="#reference">3</a>提供了理论证明和强有力的经验证据。</p>
<p>除了 GraIL
框架，我们还为归纳关系预测问题引入了一系列<strong>benchmark
tasks</strong>。由于用于知识图谱补全的现有基准数据集是为直推式学习设置的，即它们确保测试集中的所有实体都在训练数据中。因此为了测试具有归纳式学习能力的模型，通过从不同的知识图谱数据集中采样子图来构建几个新的归纳式基准数据集。在这些新的基准数据集上的实验表明，GraIL
能够大大优于最先进的baseline，在 AUC-PR 和 Hits@10
方面，平均相对性能分别提高了 5.25% 和 6.75%。</p>
<p>最后，我们将 GraIL
与现有的基于嵌入的直推式学习模型进行比较。特别地，我们假设我们的方法具有与基于嵌入的方法互补的归纳偏差，并且研究了使用基于嵌入的方法集成
GraIL 后的能力。我们发现集成 GraIL 后性能显著提高。</p>
<h2 id="研究现状related-work">研究现状（Related Work）</h2>
<ul>
<li><p><strong>基于嵌入的模型</strong> 如前所述，大多数现有的 KG
补全方法都属于基于嵌入的范畴。 RotatE、ComplEx、ConvE 和 TransE
是为训练集中的每个节点训练浅嵌入的一些代表性方法，使得这些低维嵌入可以检索图的关系信息。GraIL
体现了另一种归纳倾向，明确地对结构规则进行编码。此外，虽然 GraIL
是自然归纳的，但在归纳式学习设置中采用嵌入方法进行预测，需要为新节点重新训练嵌入，代价很高。</p>
<p>与 GraIL 类似，R-GCN 模型也使用 GNN
来执行关系预测。尽管最初提出的这种方法本质上是直推式的，但如果给定一些节点特征，它便具有归纳的潜力。与
GraIL 不同的是，R-GCN 仍然需要学习特定于节点的嵌入，而 GraIL
将关系预测视为子图推理问题。</p></li>
<li><p><strong>归纳嵌入</strong>
无联通知识图谱的嵌入很有前景，尽管它们在某些方面受到限制。汉密尔顿等人和
Bojchevski &amp; Günnemann 依赖于许多 KG 中不存在的节点特征的存在。
(Wang et al., 2019) 和 (Hamaguchi et al., 2017) 通过使用 GNN
聚合相邻节点嵌入来学习为无联通增量知识图谱生成嵌入。然而，这两种方法都需要新节点被已知节点包围，且不能处理全新的图。</p></li>
<li><p><strong>规则归纳法</strong>
与基于嵌入的方法不同，统计规则挖掘方法通过枚举知识图中存在的统计规律和模式来诱导概率逻辑规则。这些方法本质上是归纳式学习，因为规则独立于节点。但这些方法存在可扩展性问题，并且由于它们基于规则的性质而缺乏表达能力。受这些统计规则归纳方法的启发，NeuralLP
模型使用 TensorLog 运算符以端到端的可微方式从 KG 中学习逻辑规则。基于
NeuralLP，Sadeghian 等人最近提出了
DRUM，它可以学习更准确的规则。这组方法构成了我们在归纳设置中的Baseline。</p></li>
<li><p><strong>使用 GNN 进行链接预测</strong> 在 KG 文献之外，Zhang
&amp; Chen (2018) 从理论上证明了 GNN
可以学习常见的图启发式方法，用于简单图中的链接预测。Zhang &amp; Chen
Inductive Relation Prediction by Subgraph Reasoning (2020) 提出了一种与
GraIL
非常相似的方法，并在归纳矩阵完成和迁移学习方面十分有效。虽然存在方法上的相似性，但
GraIL 的重点是多关系知识图与模型诱导逻辑规则的能力。</p></li>
<li><p><strong>逻辑推理和 GNN</strong>
最近的许多工作同时探索了逻辑推理和图神经网络的联系。 Barcel´o 等人
(2020) 提出了 GNN 的表达能力与一阶谓词逻辑子集 FOC2
之间的紧密联系，利用与 WL 同构测试的联系（Cai 等人，1992
年）。然而，他们的发现集中在简单的图表和一元逻辑公式上，而 GraIL
的结果通过在多关系图和二元逻辑公式的上下文中展示类似的连接来增强他们的发现。另一条并行工作将图神经网络与强大的概率推理引擎——马尔可夫逻辑网络（Markov
Logic Networks）相结合（Qu &amp; Tang，2019；Zhang
等人，2020）。这些方法侧重于使用一组给定的预定义规则对 KG
进行演绎和推理。事实上，张等人 (2020) 在其预处理步骤中使用
NeuralLP（我们的Baseline之一）来推导逻辑规则。GraIL
与他们的方法互补，因为其隐含地执行规则归纳以及演绎和推理。</p></li>
</ul>
<h1 id="嵌入方法">嵌入方法</h1>
<h2 id="传统世界嵌入">传统世界嵌入</h2>
<ul>
<li>距离转移方法：TransE (2013-NIPS)、TransH (2014-AAAI)、TransR
(2015-AAAI)</li>
<li>矩阵分解方法：RESCAL (ICML-2011)、DistMult (ICLR-2015)</li>
<li>传统神经网络方法：NTN (NIPS-2013)、MLP (SIGKDD-2014)</li>
<li>深度学习方法：ConvE (2018-AAAI)、ParamE (2020-AAAI)</li>
<li>图神经网络方法：R-GCN (2018-ESWC)、SACN (2019-AAAI)</li>
</ul>
<h2 id="开放世界嵌入">开放世界嵌入</h2>
<ul>
<li>附加信息：附加图片信息 IKRL (2016-IJCAI)、附加文本信息 DKRL
(2016-AAAI)</li>
<li>图神经网络：MEAN (2017-IJCAI)、LAN (2019-AAAI)、VN
Network（2020-CIKM)</li>
<li>规则推理：GraIL(2020-ICML)、TACT (2021-AAAI)</li>
<li>元学习：GEN (2020-NIPS)</li>
</ul>
<h1 id="做法">做法</h1>
<h2 id="baseline">baseline？</h2>
<h2 id="模型介绍">模型介绍</h2>
<p>GraIL
方法背后的关键思想是<strong>根据两个节点周围的子图结构来预测这两个节点之间的关系</strong>。其建立在图形神经网络(GNN)(Hamilton等人，2007a)(或神经消息传递(Gilmer等人，2017))形式主义基础上，不使用任何节点属性从而测试
GraIL 仅从结构学习和泛化的能力。由于 GraIL
只接受结构信息(即子图结构和结构节点特征)作为输入，因此学习知识图谱背后的结构语义是完成关系预测任务的唯一途径。总体任务是对三元组<span
class="math inline">\({u, r_t,
v}\)</span>进行评分，即预测KG中头节点u和尾节点v之间可能的关系rt的可能性，其中我们将节点u和v称为目标节点，并将rt称为目标关系。我们对这样的三元组进行评分的方法可以大致分为三个子任务：
- (I)提取目标节点周围的包围子图 - (II)标记提取的子图中的节点 -
(III)使用GNN对标记的子图进行评分</p>
<h2 id="模型算法">模型算法</h2>
<h3 id="子图提取">子图提取</h3>
<p>我们假设<em>KG中特定三元组的局部图邻域包含推导目标节点之间关系所需的逻辑证据</em>。特别地，我们假设连接两个目标节点的路径包含可能隐含目标关系的信息。因此，作为第一步，我们提取目标节点周围的封闭子图。我们将节点u和v之间的封闭子图定义为出现在u和v之间的路径上的所有节点所得到的图，它是两个目标节点相邻节点的交集。随后进行剪枝。即，设<span
class="math inline">\(N_k(u)\)</span>和<span
class="math inline">\(N_k(v)\)</span>是KG中两个目标节点的<a
href="https://support.huaweicloud.com/usermanual-ges/ges_01_0034.html">k跳（k-hop）</a>(无向)邻域中的节点集合。我们通过取这些k跳邻域集合的交集<span
class="math inline">\(N_k(u) ∩
N_k(v)\)</span>来得到封闭子图，然后<strong>修剪与任一目标节点独立或距离大于k的节点</strong>。由<em>Observation
1</em>知，这会得到在节点u和v之间的长度至多为k+1的路径上出现的所有节点。</p>
<ul>
<li><em>Observation
1：在任何给定图中，设两个不同节点x和y之间的长度为λ的路径上的节点构成集合Pxy(λ)。这样的路径v∈Pxy(λ)上的任何节点到x或y的最大距离是λ−1。</em></li>
</ul>
<p>注意，在提取封闭子图时，我们将其视为无向图。然而，在使用GNN传递消息时，我们考虑有向图，这将在后文提到。此外，我们将目标元组/边<span
class="math inline">\({u, r_t,
v}\)</span>添加到提取出的子图中来实现两个目标节点之间的消息传递。</p>
<h3 id="节点标记">节点标记</h3>
<p>GNN 需要将节点特征矩阵 <span class="math inline">\(X∈ R^{|V| ×
d_i}\)</span>
作为输入来初始化神经消息传递算法(Gilmer等人，2017年)。由于我们在输入KG中没有假设任何节点属性，因此我们遵循Zhang&amp;Chen(2018)，并将他们的<strong>双半径顶点标注方案</strong>扩展到我们的设置中。节点u和v周围的子图中的每个节点i用元组
<em>(d(i，u)，d(i，v))</em> 标记，其中 <em>d(i，u)</em>
表示节点i和u之间的不通过v的最短距离( <em>d(i，v)</em>
也是如此)。这将捕获每个节点相对于目标节点的拓扑位置，并反映其在子图中的结构角色。两个目标节点u和v被唯一地标记为(0，1)和(1，0)，以便模型可识别。因此，节点特征是
<strong>[One-Hot(d(i，u)) ⊕ One-Hot(d(i，v))]</strong>
，其中⊕表示两个向量的连接。注意，作为 <em>Observation 1</em>
的结果，以这种方式构建的节点特征的维度受提取封闭子图时所考虑的跳数的限制。</p>
<h3 id="gnn评分">GNN评分</h3>
<p>我们框架中的最后一步是给定G(u，v，rt)，使用GNN对元组<span
class="math inline">\({u, r_t,
v}\)</span>的可能性进行评分，其中G(u，v，rt)是目标节点周围提取和标记的子图。我们采用了Xu等人描述的
<em>通用消息传递方案</em>
(2019年)，其通过将节点表示与其相邻节点表示的聚集组合来迭代更新节点表示。特别地，我们GNN的第k层由下列公式给出</p>
<p><span class="math display">\[
a_t^k = AGGREGATE^k(\{h_s^{k-1}: s∈N(t)\}, h_t^{k-1})
\]</span></p>
<p><span class="math display">\[
h_t^k = COMBINE^k(h_t^{k-1}, a_t^k)
\]</span></p>
<p>其中<span
class="math inline">\(a_t^k\)</span>是来自相邻节点的聚合消息，<span
class="math inline">\(h_t^k\)</span> 表示第k层中节点t的潜在表示，<span
class="math inline">\(N(t)\)</span>表示节点t的直接相邻节点的集合。任何节点
<span class="math inline">\(i\)</span>，<span
class="math inline">\(h_i^0\)</span>
的初始潜在节点表示被初始化为步骤2中描述的<strong>双半径顶点标注方案</strong>构建的节点特征
<span
class="math inline">\(X_i\)</span>。该框架可以插入不同的AGGREGATE和COMBINE函数，从而拥有各种GNN架构。</p>
<p>受多关系R-GCN(Schlichtkrull等人，2017)和edge
attention的启发，我们将聚合函数定义为</p>
<p><span class="math display">\[
a^k_t = \sum_{r=1}^R\sum_{s∈N_r(t)}α^k_{rr_tst}W^k_rh^{k−1}_s
\]</span></p>
<p>其中，<span
class="math inline">\(R\)</span>是知识图中存在的关系的总数；<span
class="math inline">\(N_r(t)\)</span>表示关系r下节点t的直接传出邻节点集合；<span
class="math inline">\(W^k_r\)</span>是用于在关系r上的第k层中传播消息的变换矩阵；<span
class="math inline">\(α^k_{rr_tst}\)</span>是对应于经由关系r连接节点s和t的边的第k层的边attention权重。该attention权重是源节点t、邻节点s、边类型r和要预测的目标关系<span
class="math inline">\(r_t\)</span>的函数，定义为</p>
<p><span class="math display">\[
s=ReLU(A^k_1[h^{k-1}_s ⊕ h^{k-1}_t ⊕ e^a_r ⊕ e^a_{r_t}]+b^k_1)
\]</span></p>
<p><span class="math display">\[
α^k_{rr_tst}=σ(A^k_2s+b^k_2)
\]</span></p>
<p>这里，<span class="math inline">\(h^k_s\)</span>和<span
class="math inline">\(h^k_t\)</span>表示GNN的第k层的各个节点的潜在节点表示，<span
class="math inline">\(e^a_r\)</span>和<span
class="math inline">\(e^a_{r_t}\)</span>表示各个关系的学习注意嵌入。注意，attention权重并不是标准化的，而是来自一个Sigmoid门，该门控制着从每个相邻节点那里聚集来的信息。我们采用了Schlichtkrull等人(Schlichtkrull等人，2017)提出的<em>基共享机制</em>来正则化，，在每层的变换矩阵<span
class="math inline">\(W^k_r\)</span>中。我们还实现了一种<em>边丢弃</em>的方法，将边从图中随机丢弃，同时聚合来自相邻节点的信息。</p>
<p>有最好效果的COMBINE函数也是由R-GCN架构派生而来的。</p>
<p><span class="math display">\[
h^k_t=ReLU(W^k_{self}h^{k-1}_t+a^k_t)
\]</span></p>
<p>使用上述GNN体系结构，我们在L层消息传递之后获得节点表示。<span
class="math inline">\(G(u，v，r_t)\)</span>的子图表示是通过对所有潜在节点表示进行平均池化（average-
pooling）得到的：</p>
<p><span class="math display">\[
h^L_{G(u, v r_t)}=\frac{1}{V}\sum_{i∈V}h^L_i
\]</span></p>
<p>其中V表示<span
class="math inline">\(G(u，v，r_t)\)</span>的顶点集。</p>
<p>最后，为了获得三元组<span class="math inline">\({u, r_t,
v}\)</span>的可能性得分，我们串联四个向量：子图表示 (<span
class="math inline">\(h^L_{G(u, v r_t)}\)</span>)、目标节点的潜在表示
(<span class="math inline">\(h^L_u\)</span> 和 <span
class="math inline">\(h^L_v\)</span>)以及已学习的目标关系的嵌入 (<span
class="math inline">\(e_{r_t}\)</span>)，并通过线性层传递这些连接表示：</p>
<p><span class="math display">\[
score(u, r_t, v) = W^T[h^L_{G(u, v, r_t)} ⊕ h^L_u ⊕ h^L_v ⊕ e_{r_t} ]
\]</span></p>
<p>在我们的最佳性能模型中，除了使用最后一层的节点表示外，我们还使用间歇层的表示。这是受Xu等人介绍的<em>JK-Connection机制</em>的启发(2018)，为每个节点提供灵活的邻域范围。这种JK连接的加入使得我们的模型的性能对于GNN的层数是稳健的。</p>
<h2 id="训练制度">训练制度</h2>
<p>根据标准和成功的实践，我们使用噪声对比铰链损失训练模型以使正三元组得分高于负三元组（Bordes
et al.,
2013）。更准确地说，对于训练图中存在的每个三元组，我们通过用均匀采样的随机实体替换三元组的头部（或尾部）来获得一个负三元组。
然后我们使用以下损失函数通过随机梯度下降训练我们的模型：</p>
<p><span class="math display">\[
L = \sum^{|E|}_{i=1}max(0, score(n_i) − score(p_i) + γ)
\]</span></p>
<p>其中 <span class="math inline">\(E\)</span>
是训练图中所有边/三元组的集合；<span class="math inline">\(p_i\)</span>
和 <span class="math inline">\(n_i\)</span> 分别表示正负三元组；γ
是边距超参数。</p>
<h2 id="理论分析">理论分析</h2>
<p>我们可以证明，GraIL
架构能够编码流行规则归纳模型中使用的同一类基于路径的逻辑规则，如 RuleN和
NeuralLP以及在最近使用神经网络进行逻辑推理的工作的研究。为了便于说明，我们将知识图谱中的边
(u, r, v) 等同于二元逻辑谓词 r(u, v)，其中边 (u, r, v)
存在于图中当且仅当r(u,v) = true。 定理 1. 令 R
为以下形式的二元谓词上的任何逻辑规则（即子句）：</p>
<p><span class="math display">\[
r_t (X,Y)← r_1 (X,Z_1 )∧ r_2 (Z_1,Z_2 )∧ …∧ r_k (Z_(k-1),Y )
\]</span></p>
<p>其中rt, r1, ..., rk是知识图谱中的（不一定是唯一的）关系，X, Z1, ...,
Zk, Y 是可以被任意唯一实体绑定的自由变量。对于任何这样的
R，都存在一个参数设置为Θ的 GraIL
模型，其具有k个GNN层，且所有潜在嵌入的维度为d = 1，使得<span
class="math inline">\(score(u,r_t,v)≠0\)</span>,当且仅当∃Z1,…,
Zk，使R的主体满足X = u和Y = v。</p>
<p>定理 1
指出，知识图中路径对应的任何逻辑规则都可以被模型编码。GraIL将输出一个非零值当且仅当此逻辑规则的主体基于一组特定的查询实体
X = u 和 Y = v 时。定理 1
的完整证明在附录中有详细说明，其关键思想如下：可以使用边注意力权重设置模型参数，使得节点的隐藏嵌入在一轮消息传递后非零（即h_s^i≠0）当且仅当节点
s 通过关系 ri
有至少一个邻节点。换句话说，边缘注意机制允许模型指示特定关系是否与特定实体相关，并且——因为我们已经唯一标记了目标节点
u 和 v——我们可以使用这种关系指示属性来检测是否存在节点 u 和 v
之间的特定路径。 我们可以直接对定理 1进行扩展得到显示以下推论：</p>
<p><strong>推论 1.</strong> 令 R1,…, Rm 是一组与定理 1
中有着相同结构的逻辑规则，每个规则具有相同的头部rt(X, Y )。令</p>
<p><span class="math display">\[
β = |{R_i ∶∃Z_1,…,Z_k  where R_i=true with X = u and Y = v}|.
\]</span></p>
<p>那么便存在一个与定理1相同假设的GraIL模型的参数设置，为</p>
<p><span class="math display">\[
score(u,r_t,v)∝β
\]</span></p>
<p>这个推论表明，给定一组暗示相同目标关系的逻辑规则，GraIL
可以计算对于特定的查询实体u和
v，这些规则有多少是满足的。换句话说，类似于规则归纳模型，如RuleN，GraIL
可以结合来自多个规则的证据来进行预测。</p>
<p>有趣的是，定理 1 和推论 1 表明 GraIL
可以仅使用实体和关系的一维嵌入来学习逻辑规则，这与我们的经验相吻合，即
GraIL 的性能在维度d = 1, ..., 64
范围内相当稳定。但是，上述分析只对应于固定类别的逻辑规则，我们期望GraIL可以受益于更大的潜在维度来学习不同种类的逻辑规则以及这些规则之间更复杂的组合。</p>
<h2 id="复杂度分析">复杂度分析</h2>
<p>与传统的基于嵌入的方法不同，GraIL
模型中的推理需要提取和处理候选边（u、rt、v）周围的子图，并在该提取的子图上运行
GNN。鉴于我们的处理需要评估提取的子图中从目标节点到所有其他节点的最短路径，我们认为
GraIL 对候选边 (u, rt, v) 进行评分的推理时间复杂度为</p>
<p><span class="math display">\[
O(log(V)E + Rdk)
\]</span></p>
<p>其中 V、R 和 E 分别是由u和v导出的封闭子图中的节点、关系和边的数量。d
是节点/关系嵌入的维度。
因此GraIL推理的成本很大程度上取决于提取的子图大小，实际的运行时间一般由在这些子图上运行Dijkstra算法来决定。</p>
<h1 id="模型实验">模型实验</h1>
<p><strong><em>该章节的所有图表请见原文或我的译文</em></strong></p>
<p>我们在三个基准知识完成数据集上进行实验：WN18RR、FB15k-237和
NELL-995（以及其他由他们衍生而来的数据集）。我们的实证研究主要关注以下问题：</p>
<ol type="1">
<li>归纳式关系预测。通过定理 1，我们知道 GraIL
可以编码归纳式逻辑规则。与在归纳式设置中明确进行规则归纳的现有统计和可微方法相比，它的表现如何？</li>
<li>直推式关系预测。我们的方法具有很强的结构归纳偏差，我们假设它是对现有最先进的知识图嵌入方法的补充。这种互补的归纳偏置能否对传统直推式设置中现有的最先进的知识图谱嵌入方法进行任何改进？</li>
<li>灵敏度分析。我们提出的框架的各个组成部分有多重要？比如，定理 1
依赖于注意力和节点标记方案的使用，但这些模型方面在实践中有多重要？</li>
</ol>
<p>所有提及的实验代码与数据都在：https://github.com/kkteru/grail。</p>
<h2 id="归纳式关系预测">归纳式关系预测</h2>
<p>如图 1c
所示，归纳式设置评估模型泛化到新实体的能力。完全归纳式的设置中，在训练和测试期间看到的实体集是没有交集的。更一般地，新实体的数量范围可以从仅引入几个新实体到完全的归纳设置（图
1c）。只要关系的底层语义（即知识图的模式）保持不变，GraIL
得到的节点特性是不变的。我们展示了我们的归纳结果在非常极端的情况下：一个带有新的实体集的全新的测试图。</p>
<p><strong>数据集。</strong>WN18RR、FB15k-237 和 NELL-995
基准数据集最初是为直推式设置开发的。换句话说，标准测试拆分的实体是训练拆分中实体的子集（图
1b）。为了促进归纳测试，我们通过从这些数据集中采样不相交的子图来创建新的全归纳基准数据集。特别地，我们的每个数据集都由一对图组成：train-graph
和 ind-test-graph。这两个图(i)具有完全不相交的实体集，并且(ii)
train-graph包含ind-test-graph中存在的所有关系。生成该数据集的过程在附录中有详细说明。为了进行稳健的评估，我们采样了四对不同的train-graph和ind-test-graph，其中每对基准知识图的节点和边数都在增加。在附录的表中给出了这些归纳基准的统计数据。在归纳式设置中，模型在
train-graph 上进行训练并在 ind-test-graph 上进行测试。我们随机选择
ind-test-graph 中10%的边/元组作为测试边。</p>
<p><strong>Baseline和实施细节。</strong>我们将 GraIL
与其他两种端到端可微分方法NeuralLP17和
DRUM19进行了比较。据我们所知，这些是唯一能够进行归纳关系预测的可微方法。我们使用作者公开提供的最佳配置实现。我们还与最先进的统计规则归纳方法
RuleN15进行了比较，该方法在直推式设置表现得比与其他基于嵌入的方法更好。
RuleN 代表了KG上归纳关系预测的当前最先进技术。它显式地提取了等式 (1)
中所示的那种基于路径的规则。我们使用 RuleN 的原始术语来训练它学习长度为
4 的规则。通过Observation 1，这对应于目标节点周围的 3
跳邻域。为公平起见，我们在 GNN 方法的目标链接周围采样 3
跳封闭子图。我们使用了一个 3 层 GNN，所有潜在嵌入的维度都等于
32，基础维度设置为 4，边缘丢失率设置为 0.5。在我们的实验中，GraIL
对超参数相对稳健，并且在各种设置下都具有稳定的性能。更多的超参数选择在附录中有详细说明。</p>
<p><strong>结果。</strong>我们在分类和排名指标上评估模型，即分别在精确召回曲线
(AUC-PR) 下的面积和 Hits@10。为了计算
AUC-PR，连同测试集中存在的三元组，我们使用随机实体替换头部（或尾部）的标准做法对相同数量的负三元组进行评分。由于第
3.4 节中描述的推理复杂性，我们通过在 50
个其他随机采样的负三元组中对每个测试三元组进行排名来近似 Hits@10。在表 1
和表 2 中，我们分别列出了 5 次运行的平均 AUC-PR 和 Hits@10。
（所有设置中的方差都非常低，因此这些表中省略了标准误差。）</p>
<p>正如我们所见，GraIL
在两个指标中的所有数据集上都显著优于归纳基线。仔细观察，之前的可微分方法（Neural-LP
和 DRUM）的性能明显比 GraIL 差。此外，如图 3 所示，GraIL
的强结构归纳偏置使其能够以数量级更少的参数数量实现极高的参数效率。GraIL
还始终优于统计规则归纳方法 RuleN，这表明 GraIL
不仅能够学习基于路径的逻辑规则，而且 GraIL
还能够利用更复杂的结构模式并有效地组合多个规则（推论
1）。为了完整起见，我们还在附录中列出了这些生成的数据集的直推式性能。请注意，与直推式设置相比，归纳式性能（在所有数据集和模型中）相对低于转导性能，这体现了归纳关系预测任务的难度。</p>
<h2 id="直推式关系预测">直推式关系预测</h2>
<p>正如之前所展示的，GraIL
具有很强的归纳偏差来编码知识图谱背后的逻辑规则和复杂的结构模式。我们相信，这与当前最先进的直推式知识图谱补全方法相辅相成，后者依赖于基于嵌入的方法。基于这一观察，在本节中，我们将探讨（i）GraIL
在直推式设置中的表现以及（ii）将 GraIL
与现有的基于嵌入的方法集成的效益。由于相较基于嵌入的方法，GraIL拥有很强的互补归纳偏差，我们预计通过将其与现有的基于嵌入的方法集成可以获得显着的收益。</p>
<p>我们的主要集成策略是后期融合，即集成各组成方法的输出分数。我们使用要集成的方法对每个测试三元组进行评分，每种方法输出的分数形成了每个测试点的特征向量。该特征向量被输入到一个线性分类器中，将该分类器训练得能够使正三元组得分高于负三元组。我们使用验证集训练这个线性分类器。</p>
<p><strong>数据集。</strong>我们使用标准的 WN18RR、FB15k-237 和 NELL-995
基准。对于 WN18RR 和 FB15k-237，我们使用文献中可用的拆分。对于
NELL-995，我们以 70/15/15
的比例将整个数据集拆分为训练集/验证集/测试集，确保拆分出的验证集和测试集中所有实体和关系在训练集中至少出现一次。</p>
<p><strong>Baseline和实施细节。</strong>我们将 GraIL 与
TransE、DistMult、ComplEx和
RotatE中的每一个进行了集成，它们构成了一组代表性的KGE方法。对于所有方法，我们使用5提供的实现和超参数，其给出了所有方法的最新结果。为了公平比较所有方法，我们禁用了5提出的自我对抗负采样。对于
GraIL，我们对 WN18RR 和 NELL-995 使用2跳邻域子图，对
FB15k-237使用1跳邻域子图。其他所有超参数与归纳式设置中的相同。</p>
<p><strong>结果。</strong>表3、4、5展示了不同KGE方法之间以及与 GraIL
的成对集成的AUC-PR性能。这些表中的一个特定条目对应于由行和列标签表示的一对方法的集合，每个方法的单独性能在对角线上。从这些表的最后一列可以看出，在这三个数据集的其中两个，使用GraIL集成可以在所有直推式方法中获得一致的性能提升。此外，使用
GraIL
进行集成比使用其他任何两种方法获得更多收益。更精确地，我们定义了通过集成两种方法获得的增益，G(M1,
M2)，如下</p>
<p><span class="math display">\[
G(M_1,M_2 )=\frac{P(M_1,M_2 )-max⁡(P(M_1 ),P(M_2))}{max⁡(P(M_1 ),P(M_2 )}
\]</span></p>
<p>换句话说，它实现的百分比改进是相较于两种方法中最好的。因此，通过使用GraIL集成获得的平均增益由下式给出</p>
<p><span class="math display">\[
G_{avg}^{GraIL}=\frac{1}{4} \sum_{|M_1 |∈KGE}G(M_1,GraIL)
\]</span></p>
<p>通过KGE方法之间的成对集成获得的平均增益由下式给出，</p>
<p><span class="math display">\[
G_{avg}^{GraIL}=\frac{1}{12}\sum_{(|M_1 |,|M_2 |)∈KGE}G(M_1,M_2 )
\]</span></p>
<p>GraIL 在 WN18RR 和 NELL-995 上获得的平均增益分别为 1.5% 和
0.62%。这比 KGE 集成获得的平均增益好几个数量级：0.007% 和
0.08%。令人惊讶的是，没有一个集成获得FB15k-237的显着收益。因此，虽然
GraIL
本身针对归纳式设置进行了优化，而不是最先进的直推式预测，但它确实通过集成对最先进的直推式方法进行了有意义的改进。</p>
<p>表 6 显示了当节点特征（由我们的原始节点标记方案计算）与 TransE
模型学习的节点嵌入连接时GraIL
的性能。添加这些预训练嵌入可以显着提升性能。因此，虽然后期融合展示了
GraIL 所体现的互补归纳偏差，但这种早期融合展示了 GraIL
利用任何可用节点嵌入/节点特征的自然能力。可以在附录中看到，所有
Hits@10的结果均呈现相似的趋势。</p>
<h2 id="灵敏度分析">灵敏度分析</h2>
<p>在本节中，我们强调 GraIL
的三个关键组件的重要性：i）封闭子图提取，ii）双半径节点标记方案，以及
iii）GNN 中的注意力机制，结果总结在表 7 中。</p>
<p>封闭子图提取。如前所述，我们假设特定链接的逻辑证据可以在链接的两个目标节点周围的子图中找到。因此，我们建议提取由两个目标节点之间的路径上出现的所有节点诱导的子图。在这里，我们想强调仅提取路径，而不是天真地提取由目标节点的所有k-hop邻接点得到的子图的重要性。在这种配置下，性能急剧下降。事实上，该模型严重地过度拟合训练数据，训练AUC超过
99%。该模式适用于所有数据集。</p>
<p>双半径节点标记。定理 1
的证明假设了目标节点u和v具有唯一的标记。我们通过使用 (1, 1)
的恒定节点标签而不是最初提出的节点标签方案来评估 GraIL
，结果的性能下降证实了我们的节点标记方案的重要性。</p>
<p>GNN中的注意力机制。正如定理 1
的证明中所指出的，注意机制是我们模型编码路径规则时的重要组成部分。我们在没有注意机制的情况下评估GraIL并注意到性能明显下降，这与我们的理论发现相呼应。</p>
<h1 id="总结">总结</h1>
<p>我们提出了一个基于 GNN 的框架
GraIL，用于归纳式知识图推理。与基于嵌入的方法不同，GraIL
模型能够预测在训练期间没有的节点之间的关系，并在这种归纳式设置中实现最先进的结果。此外，我们展示了
GraIL
带来了与当前最先进的知识图谱补全方法之间互补的归纳偏差。特别是，我们通过一组完整的实验证明了与
GraIL
集成时各种知识图谱嵌入方法的性能提升。此外，我们还从理论上了解了关于GNN在编码有用的逻辑规则子集方面的表达能力。</p>
<p>这项工作通过一组新的基准数据集与对现有归纳关系预测方法的全面研究，为知识图谱背景下的归纳式推理探索开辟了一个新方向。例如，进一步探索的明显方向包括从
GraIL
中提取可解释的规则和结构模式，分析关系分布的变化如何影响归纳性能，以及将
GraIL 与元学习策略相结合来处理小样本学习设置。</p>
<h1 id="致谢">致谢</h1>
<p>这项研究的部分资金来自微软研究院的学术资助，以及由 Mila - Quebec AI
研究所的 Hamilton 教授担任的Canada CIFAR AI 主席。此外，IVADO
通过本科生研究奖学金为 Etienne 提供支持。</p>
<h1 id="reference">Reference</h1>
<p>[1] 刘峤, 等.知识图谱构建技术综述[J]. 计算机研究与发展, 2016, 53
(3):582-600. [2] 漆桂林, 高桓, 吴天星. 知识图谱研究进展[J]. 情报工程,
2017, 3(1): 4-25 [3] Teru, Komal K. Inductive Relation Prediction by
Subgraph Reasoning, ProQuest Dissertations Publishing, 2020.</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Knowledage-Graphs</tag>
        <tag>GraIL</tag>
      </tags>
  </entry>
  <entry>
    <title>宝可梦六代实机乱数（破解机插件辅助 &amp; 不包含蛋）</title>
    <url>/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen6/</url>
    <content><![CDATA[<p>本文内容不涉及3ds/2ds系列的破解过程，本篇内容均建立在读者已经将3ds/2ds系列破解了的基础上.</p>
<p>同时本文使用的是<strong>正版卡带 +
辅助插件</strong>，相应盗版软件无法正常操作.</p>
<p>封面 [ID:50105089].</p>
<span id="more"></span>
<p><strong>注意，本教程仅支持宝可梦六代正作游戏：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Version</th>
<th style="text-align: center;">X</th>
<th style="text-align: center;">Y</th>
<th style="text-align: center;">欧米伽红宝石</th>
<th style="text-align: center;">阿尔法蓝宝石</th>
<th style="text-align: center;">其他</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Support</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✘</td>
</tr>
</tbody>
</table>
<p>本篇搬运+修改自<strong>無論</strong>的原博客：<a
href="https://wulun0102.github.io/2021-08-21/%E5%8F%A3%E8%A2%8B%E5%A6%96%E6%80%AA%E7%AC%AC%E5%85%AD%E4%B8%96%E4%BB%A3-ORAS%E4%B9%B1%E6%95%B0%E8%AE%B0%E5%BD%95/">口袋妖怪第六世代-ORAS乱数记录</a>.</p>
<p>授权图： <img
src="/images/body/Pokemon-RNG-Abuse-Gen6/Authorization.jpg"
alt="Authorization" /></p>
<h1 id="前言">前言</h1>
<p>本文仅写出了自己在使用插件过程中遇到的BUG，如果有其他小伙伴出现了其他问题，可以跳转到参考网址中相关插件的发布网址寻求答案.
关于原始 <strong>（非破解）</strong> 的Seed确定方法我找到了一篇文章：<a
href="https://sina-poke.hatenablog.com/entry/2017/05/06/000557">第六世代固定シンボル乱数調整のやり方
- かけらの記録ノート</a>. 总的来说非常繁琐，值得尝试但不建议推广.
参考文章中也有说到六代的乱数麻烦在哪里，在这里就不再赘述了.</p>
<p>成果展示：<a
href="https://www.bilibili.com/video/BV13v411N74t?spm_id_from=333.999.0.0">無論的b站视频</a></p>
<blockquote>
<p>如果你在找 3DS 系列的破解教程，请参考 <a
href="https://stray-soul.com/index.php/3dshack-getstarted">3DS/2DS破解-开始
-一只火狐的杂物间</a> 或者 <a
href="https://3ds.hacks.guide/">这里</a>.</p>
</blockquote>
<h1 id="辅助插件准备及使用">辅助插件准备及使用</h1>
<blockquote>
<p><strong>PCalc</strong> 和 <strong>pokeCalcNTR</strong> 是一个东西.
对于 alc 我只搜到了 <em>ALC MAXScript</em>（以下称为<em>ALC</em>）</p>
</blockquote>
<p>安装一个插件（PCalc）来辅助您的Pokemon游戏，以下内容将引导您如何让插件正常运行.
<strong>pokeCalcNTR for Gen 6 - v0.3.0</strong></p>
<h2 id="所需工具">所需工具：</h2>
<ul>
<li>一台有CFW（Custom Firmware）的3DS系列掌机（即俗称破解3DS）</li>
<li><a
href="https://github.com/wwwwwwzx/3DSRNGTool/releases">3DSRNGTool</a></li>
<li>PCalc for Gen 6
<ul>
<li><a
href="https://pokemonrng.com/downloads/pcalc/pcalc-oras.zip">PCalc-oras</a></li>
<li><a
href="https://pokemonrng.com/downloads/pcalc/pcalc-xy.zip">PCalc-xy</a></li>
</ul></li>
</ul>
<h2 id="step-1安装-ntr">Step 1：安装 NTR</h2>
<p>通过安装一种引导器（BootNTR Selector）来完成安装 NTR.</p>
<ul>
<li>N3DS and N2DSXL: Download and install BootNTR Selector.
<ul>
<li>Download either of the CIAs that are not Mode 3. (Difference is
Banner when loading BootNTR Selector, so you can choose either one.)
Then copy CIA to SD card and install using FBI. &gt; Note：
如果使用FBI安装CIA，请在控制台启动FBI然后导航到目标CIA文件，然后按<strong>A键</strong>安装</li>
</ul></li>
</ul>
<p>启动引导NTR选择器并选择修改默认设置 -
版本3.6（替换3.4和3.5）是唯一适用于插件的版本，因此每次启动 NTR
时都会选择该版本 - <strong>针对 O3DS 和 O2DS</strong>：请在<a
href="https://www.pokemonrng.com/misc-3ds-installing-pcalc">How to
Install PCalc</a>中寻找，但是ORAS对O3DS并不支持.</p>
<h2 id="故障排除">故障排除：</h2>
<ul>
<li><p>（主要是3DS固件版本过高和Luma的问题？）</p></li>
<li><p>BootNTR Selector 下最高版本的没有问题（需要）</p></li>
<li><p>我用的是 <strong>Luma3ds 10.2.1</strong> 与 <strong>3DS 11.14.0
固件</strong></p></li>
<li><p><a
href="https://support.sudomemo.net/info-about-2ds-3ds-system-version-11-14/">Important
Information about 2DS/3DS System Version 11.14</a></p>
<ul>
<li>这个里面导致NTR安装失败出问题的是<strong>boot.firm</strong></li>
<li>我不知道网上在哪里找了一个做替换，然后就成了</li>
<li>最后升级游戏时升级3DS固件版本到11.15现在也没啥问题</li>
</ul></li>
<li><p>在下面贴出当时使用的 <strong>Luma10.2.1原文件</strong> 和
<strong>现在使用的文件</strong></p>
<ul>
<li><a
href="https://pan.baidu.com/s/1Yjeuk1-qx2sC1cFhxXR57w">Luma10.2.1原文件</a>
可以用来升级Luma什么的</li>
<li><a
href="https://pan.baidu.com/share/init?surl=l0SK4vuE5qv_dcetW3tuaQ">现在使用的文件</a>
请提取对应的 <strong>boot.firm</strong> 文件</li>
<li>提取密码都是：<strong>0102</strong></li>
</ul></li>
</ul>
<blockquote>
<p>更新 Luma 可以参考<a
href="https://stray-soul.com/index.php/updateluma10-2">更新Luma10.2.1
-一只火狐的杂物间</a></p>
</blockquote>
<h2 id="step-2下载-pcalc-文件">Step 2：下载 PCalc 文件</h2>
<p>第二步是下载 PCalc
插件（其他版本的插件可以找下面参考网址中的帖子去下载）</p>
<p><a
href="https://pokemonrng.com/downloads/pcalc/pcalc-oras.zip">OR/AS</a>
<span class="exturl" data-url="aHR0cHM6Ly9wb2tlbW9ucm5nLmNvbS9kb3dubG9hZHMvcGNhbGMvcGNhbGMteHkuemlw">X/Y<i class="fa fa-external-link-alt"></i></span> <a
href="https://pokemonrng.com/downloads/pcalc/pcalc-tport.zip">Transporter</a></p>
<ol type="1">
<li>下载 <code>.zip</code> 文件，以获得对应的版本并解压内容.</li>
<li>将插件文件夹从 <code>.zip</code> 移动到SD卡的根部.
如果出现提示，选择合并并覆盖内容.</li>
<li>在SD卡上的<code>root部分</code>应有文件夹，并且应有 2/4/6/8
个文件夹（这取决于您下载并安装的 PCCALCS）. 并且每个文件夹内应有
<code>.Plugin</code> <code>cheat.plg</code> 的文件组成</li>
</ol>
<h2 id="step-3启动-pcalc">Step 3：启动 PCalc</h2>
<p>启动NTR选择器，然后应用您的选择 <code>NTR 3.6</code>.
屏幕会闪烁一下蓝色，当你启动游戏的时候如果屏幕闪烁绿色，恭喜你做到了！</p>
<blockquote>
<p>Note: PCalc Menu can be opened by pressing X+Up on D-pad. NTR Menu
can be opened by pressing X+Y. Useful for taking screenshots for proofs,
all screenshots are saved to root of SD card as .bmp files.</p>
</blockquote>
<h1 id="游戏更新及插件启动故障排除">游戏更新及插件启动故障排除</h1>
<h2 id="ds固件版本故障排除">3DS固件版本故障排除</h2>
<p>如果您更新到 11.6，NTR 无法工作，请确保您拥有最新的 BootNTR
选择器和/或引导选择器模式 3. &gt; 您可以在启动X时通过按住X轻松更新.</p>
<h2 id="游戏版本故障排除">游戏版本故障排除</h2>
<p>如果使用 ORAS 和 PCalc 不起作用： - 确保你有最新更新的游戏补丁. -
ORAS为v1.4. 游戏版本可以在系统设置里面找到.</p>
<blockquote>
<p>（System Settings —&gt; Data Management —&gt; NINTENDO 3DS —&gt;
Downloadable Content）</p>
</blockquote>
<p>-更新可以从 Eshop 下载或使用 CFW 从另一台机器中提取.</p>
<h2 id="其他原因故障排除">其他原因故障排除</h2>
<p>如果游戏更新到最新版本，并且PCalc和/或NTR未加载： - 删除 SD
卡上的所有 NTR 相关文件. - 删除 SD 卡根部的任何 NTR .bin文件. -
删除这些文件夹及其内容： - SD:/Nintendo 3DS/EBNTR/ - SD:/3ds/ntr/ -
SD:/3ds/BootNTRSelector/ -
通过启动引导NTR选择器和启动NTR选择器模式3，再次重新下载所需的NTR文件.</p>
<h2 id="关于神奇宝贝第-67-代游戏更新">关于神奇宝贝第 6/7
代游戏更新：</h2>
<ul>
<li>如果您有一个固件区域更改<code>console or emunand</code>，这可以从其他来源获得，例如从其他console、emunand
或 sysnand 中丢掉您的更新.</li>
<li>口袋妖怪游戏更新不是区域锁定（即日版破解机也能通过插入美版卡带下载游戏更新，即更新补丁各个区域的卡带通用）.</li>
<li>游戏卡带和数字更新存储在 SD
卡上，并且<code>console/emunand</code>是每个机子特定的，并且必须安装在您正在使用游戏对应的<code>console/emunand</code>上.</li>
</ul>
<h2 id="主机相关报错">主机相关报错</h2>
<h3 id="err-009-2920">err 009-2920</h3>
<ul>
<li>问题描述：
<ul>
<li>我遇到的情况就是OR游戏可以正常更新，但是AS的不行，猜测是之前有遗留没有删干净的残余文件（在删干净主界面能看到的应用之后）</li>
</ul></li>
<li>修复方法：
<ul>
<li>打开FBI —&gt; 打开 ticket 选项 —&gt; 看到红色字的ID一律删除</li>
<li>疯狂选中按A就好了，然后直接就更新正常了</li>
</ul></li>
</ul>
<h1 id="乱数id">乱数ID</h1>
<p>详情 <span class="exturl" data-url="aHR0cHM6Ly93d3cucG9rZW1vbnJuZy5jb20vcmV0YWlsLW9yYXMtdGlk">Trainer ID
RNG（ORAS）<i class="fa fa-external-link-alt"></i></span>、<a
href="https://www.pokemonrng.com/pcalc-xy-tid">Trainer ID, Secret ID,
and/or TSV RNG（XY）</a>中已经写明了，我在这里只简单的说一些事项. <img
src="/images/body/Pokemon-RNG-Abuse-Gen6/Trainer-ID-RNG.png"
alt="Trainer ID RNG" /></p>
<ol type="1">
<li>打开 <code>wwwwwwzx</code> 大佬的乱数工具
<strong>3DSRNGTool</strong></li>
<li>获取开始帧信息（gen6下方的四组数据）</li>
</ol>
<ul>
<li>方法1：使用NTR助手（非必须，需要在局域网下进行）</li>
<li>方法2：手动填入</li>
<li><strong>注意事项</strong>：这里不需要关注frame对应的seed，因为这里的乱数信息在很早就已经确定并且不是以60帧/s的速度改变ID数据，只需要注意给<strong>角色取名</strong>时的关键节点进行帧信息的获取就好.
（具体方法请看上面的网址和<a
href="https://github.com/wwwwwwzx/3DSRNGTool#readme">wwwwwwzx大佬GitHub中的<code>Readme.md</code>文件</a>）</li>
</ul>
<ol start="3" type="1">
<li>决定ID信息</li>
</ol>
<ul>
<li>如上面所述这里的乱数信息不是跟随图像变化的，消耗帧的方法是<strong>给角色取名之后再取消</strong>，过程相对比较繁琐所以我当时只刷了几遍，看到4999就收了emmm</li>
<li>乱这个的时候建议多过几遍最开始的剧情找个好的开始帧…这样轻松一些（建议使用NTR助手）</li>
<li>NTR Helper里面的那个自动过帧我没玩儿明白反正…</li>
</ul>
<ol start="4" type="1">
<li>记录ID信息</li>
</ol>
<ul>
<li>我个人建议在你乱出来ID之后，记录一下对应的表里ID（也就是TID &amp;
SID）他们共同决定了你的闪值（TSV） &gt;
在六七代中训练家的TSV和获得宠物（初次取名）时的PSV是否相同决定了宠物是否为异色</li>
</ul>
<h1 id="确定tsv">确定TSV</h1>
<ul>
<li>如果你之前乱数过ID并记录了对应的TSV，请跳过这步并在乱数工具对应的位置上填好tsv</li>
<li>如果没有乱数过，请继续往下看</li>
</ul>
<h2 id="额外需要工具">额外需要工具：</h2>
<ul>
<li>Checkpoint（宝可梦游戏存档导出导入工具包）</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t3c2NoL1BLSGVYL3JlbGVhc2Vz">PKHex<i class="fa fa-external-link-alt"></i></span>
仅用于查看 <strong>tsv</strong>.</li>
</ul>
<h3 id="step-1导出存档">STEP 1：导出存档</h3>
<p>如何导出存档请看 <a
href="/Pokemon/Strategies/In-Game/How-To-Back-Up-Your-Savefiles/#NDS-%E4%B8%8E-3DS-%E5%8D%A1%E5%B8%A6-%E4%BB%A5%E5%8F%8A-3DS-VC-%E7%B3%BB%E5%88%97">如何备份你的存档
相应部分</a>或者直接点击<a
href="https://projectpokemon.org/home/tutorials/save-editing/managing-3ds-saves/using-checkpoint-r25/">这里</a>来查看.
然后在 <code>/3ds/Checkpoint/saves/(your game)/</code>目录中的
<code>main</code> 文件就是你的游戏存档，将其放到电脑合适地方以便于后面在
<strong>PKHeX</strong> 中打开</p>
<h3 id="step-2打开-pkhex">STEP 2：打开 PKHEX</h3>
<ul>
<li>打开PKHeX （ 黄色框中参数选项中可以将软件调成中文 ）</li>
<li>将Step 1中获得的main文件拖入到PKHeX中</li>
<li>再选择红色框中的那个“OT/…”（初训家&amp; ？）</li>
<li>鼠标悬浮到SID（or TID）里面的数字上就能看到你的TSV了</li>
</ul>
<table>
<colgroup>
<col style="width: 46%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">需要注意的参数</th>
<th style="text-align: center;">TSV显示</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img
src="/images/body/Pokemon-RNG-Abuse-Gen6/pkhex1.png"
alt="pkhex1" /></td>
<td style="text-align: center;"><img
src="/images/body/Pokemon-RNG-Abuse-Gen6/pkhex2.png"
alt="pkhex2" /></td>
</tr>
</tbody>
</table>
<h1 id="乱数宝可梦">乱数宝可梦</h1>
<h2 id="dsrngtool界面设置">3DSRNGTOOL界面设置</h2>
<p>以下是3DS乱数工具中会用到以及需要调整的部分 -
蓝色框中注意TSV是否填写正确（如果不知道请跳转到上方<a
href="#确定tsv">确定TSV</a>） - 红色框中注意每次的 <em>Init Seed</em>
（在点击神兽界面变化之后的）和延迟（因为不同神兽的捕获地点入场动画不同，所以对应的延迟参数也不同）
- 请确认蓝色框和红色框的数据之后再点击绿色框 -
<strong>注意！</strong>黄色框的同步性格选项不会对下面结果有任何影响
依旧是是50%几率替换对应帧的性格Orz</p>
<h2 id="pcalc-工具使用">PCALC 工具使用</h2>
<p>组合键使用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- X+Up: Key Combo Menu</span><br><span class="line">- Start+Down: Egg Seed View</span><br><span class="line">- Start+Up: RNG Tools</span><br><span class="line">- Start+Left: Wild Pokemon View</span><br><span class="line">- Start+Right: Party Pokemon View</span><br><span class="line">- Select+Left: Party Pokemon View -1 Slot</span><br><span class="line">  - Plugin switches to the other daycare in Egg View</span><br><span class="line">  - Plugin switches Horde Pokemon -1 Slot in Wild View</span><br><span class="line">- Select+Right: Party Pokemon View +1 Slot</span><br><span class="line">  - Plugin switches to the other daycare in Egg View</span><br><span class="line">  - Plugin switches Horde Pokemon +1 Slotin Wild View</span><br><span class="line">- Start+Select: Pause Game</span><br><span class="line">- Pause+A: Unpause Game</span><br><span class="line">  - Additionally, press any D-Pad and the &quot;Y&quot; button plus A to unpause as well</span><br><span class="line">    - (This helps with certain RNG types)</span><br><span class="line">- Pause+Start: Unpause Game</span><br><span class="line">- Pause+Select: Advance One Frame</span><br></pre></td></tr></table></figure> 这个里面我们主要用到
<code>Start+Select</code> &amp;
<code>Pause+Select</code>，简单翻译就是先使用 <code>Start+Select</code>
暂停帧跳动，然后再在 <em>Pause</em> 状态下单独按 <code>Select</code>
让游戏消耗一帧.</p>
<h3 id="部分故障排除">部分故障排除</h3>
<ul>
<li>我按了"A"，但我的战斗没有开始/没有点击上"A"
<ul>
<li>确保按住"A"，而不是轻点它</li>
</ul></li>
<li>我暂停在一个奇数/偶数的帧，但我的目标是在一个偶数/奇数帧
<ul>
<li>保存您的游戏通常会将帧从奇数切换到偶数 or 偶数切换到奇数
<ul>
<li>请在到达目标帧之前操作，以免后面无法调整</li>
</ul></li>
</ul></li>
<li>other：<a
href="https://gbatemp.net/threads/pokecalcntr-for-gen-6-the-rng-tool-suite-for-the-3ds.473221/">pokeCalcNTR
for Gen 6 - The RNG Tool Suite for the 3ds</a></li>
</ul>
<h2 id="操作流程通用">操作流程（通用）</h2>
<ol type="1">
<li>进入 <strong>BootNTR Selector</strong> 显示 <em>Succeeded</em> &amp;
屏幕一篮 ---&gt; 进入游戏屏幕一绿（就可以开工了）</li>
<li>在选择存档界面输入 <em>Init Seed</em> 到 3DSRNGTool
里面计算是否有合适的目标帧</li>
</ol>
<ul>
<li>如果没有，按 <strong>B</strong> 回到神兽界面，再按
<strong>A</strong> 进入刷新 <em>Init Seed</em> ，道理同SL <img
src="/images/body/Pokemon-RNG-Abuse-Gen6/InitSeed.png"
alt="InitSeed" /></li>
</ul>
<ol start="3" type="1">
<li>确定停止界面（离目标帧大约100帧内 然后用select慢慢逼近）</li>
<li>校准延迟（不同神兽的场景对应这不同击中时机，可以根据自己机器的情况改变
3DSRNGTool 中的延迟参数）</li>
<li>精确调整帧数（逐步使用<strong>Select</strong> <a
href="#部分故障排除">注意：击中的帧数是奇数还是偶数</a>）</li>
</ol>
<ul>
<li>使用 PCalc，在游戏选择屏幕上等待，直到接近您想要的Frame</li>
<li>一旦你接近你想要的Frame，按<strong>Start+Select</strong>暂停游戏</li>
<li>按<strong>Select</strong>逐帧前进，直到达到您想要的Frame</li>
<li>到达所需Frame后，<strong>按住A</strong></li>
</ul>
<ol start="6" type="1">
<li>击中目标帧</li>
</ol>
<h2
id="部分场景的逐步调整击中帧的界面">部分场景的逐步调整击中帧的界面</h2>
<ul>
<li>御三家 <img
src="/images/body/Pokemon-RNG-Abuse-Gen6/initialFlash.jpg"
alt="initialFlash" /></li>
<li>水都剧情闪（OR的哥哥，AS的妹妹） <img
src="/images/body/Pokemon-RNG-Abuse-Gen6/Latios.gif"
alt="Latios" /></li>
<li>定点闪
<ul>
<li>充满雷电的云 <img
src="/images/body/Pokemon-RNG-Abuse-Gen6/Thundurus.gif"
alt="Thundurus" /></li>
<li>时空裂缝 <img data-src="/images/body/Pokemon-RNG-Abuse-Gen6/Palkia.gif"
alt="Palkia" /></li>
</ul></li>
</ul>
<h1 id="reference">Reference</h1>
<ul>
<li><a
href="https://wulun0102.github.io/2021-08-21/%E5%8F%A3%E8%A2%8B%E5%A6%96%E6%80%AA%E7%AC%AC%E5%85%AD%E4%B8%96%E4%BB%A3-ORAS%E4%B9%B1%E6%95%B0%E8%AE%B0%E5%BD%95/">口袋妖怪第六世代-ORAS乱数记录</a></li>
<li><a
href="https://stray-soul.com/index.php/3dshack-getstarted">3DS/2DS破解-开始
-一只火狐的杂物间</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucG9rZW1vbnJuZy5jb20vbWlzYy0zZHMtaW5zdGFsbGluZy1wY2FsYw==">How
to Install PCalc<i class="fa fa-external-link-alt"></i></span></li>
<li><a
href="https://sina-poke.hatenablog.com/entry/2017/05/06/000557">第六世代固定シンボル乱数調整のやり方
- かけらの記録ノート</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucG9rZW1vbnJuZy5jb20vcmV0YWlsLW9yYXMtdGlk">Trainer ID
RNG<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucG9rZW1vbnJuZy5jb20vcGNhbGMteHktdGlk">Trainer ID, Secret
ID, and/or TSV RNG<i class="fa fa-external-link-alt"></i></span></li>
<li><a
href="https://gbatemp.net/threads/pokecalcntr-for-gen-6-the-rng-tool-suite-for-the-3ds.473221/">pokeCalcNTR
for Gen 6 - The RNG Tool Suite for the 3ds</a></li>
<li><a
href="https://tieba.baidu.com/p/5168730356?pid=108235360876&amp;cid=0#108235360876">【乱数】3ds乱数工具+6代一些游戏机制的补充【口袋妖怪吧】</a></li>
<li><a
href="https://tieba.baidu.com/p/5168730356?pid=108235360876&amp;cid=0#108235360876">常见问题
- 3DS Hacks Guide</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdHJheS1zb3VsLmNvbS9pbmRleC5waHAvaG93LXRvLXVzZS1ib290bnRy">3DS
BootNTR金手指使用教程 - 一只火狐的杂物间一只火狐的杂物间<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aWViYS5iYWlkdS5jb20vcC83MTA4NDczNTI5">BootNTRSelector
2.13.4更新支持11.14【3ds破解吧】_百度贴吧<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="appreciation">Appreciation</h1>
<ul>
<li>感谢<strong>無論</strong>的授权，可以去<a
href="https://wulun0102.github.io/">無論的博客</a>看看.</li>
<li>感谢<strong>wwwwwwzx</strong>大佬的研究成果.</li>
</ul>
]]></content>
      <categories>
        <category>Pokemon</category>
      </categories>
      <tags>
        <tag>Pokemon</tag>
        <tag>Pokemon-RNG-Abuse</tag>
        <tag>Pokemon-Gen6</tag>
      </tags>
  </entry>
  <entry>
    <title>宝可梦四代实机乱数</title>
    <url>/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen4/</url>
    <content><![CDATA[<p>这是宝可梦四代的实机乱数教程. 包含 ID 与 Egg 的乱数教程.
如有纰漏，请<a href="/about/">与我联系</a>，万分感谢！</p>
<p>封面 [ID:92026700].</p>
<span id="more"></span>
<p><strong>注意，本教程仅支持宝可梦四代正作游戏：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Version</th>
<th style="text-align: center;">珍珠</th>
<th style="text-align: center;">钻石</th>
<th style="text-align: center;">白金</th>
<th style="text-align: center;">心金</th>
<th style="text-align: center;">魂银</th>
<th style="text-align: center;">其他</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Support</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✘</td>
</tr>
</tbody>
</table>
<p>前人栽树，后人乘凉. 本篇对转载原文:<a
href="https://tieba.baidu.com/p/6552613197?pid=130747309042&amp;cid=0#130747309042">【转载】四代乱数教程及工具</a>稍作修改，无法找到原作者，见谅.
如果你认识原作者，可以<a href="/about/">与我联系</a>！</p>
<h1 id="前言">前言</h1>
<ol type="1">
<li>四代乱数的原理，机制. 还有各种乱数相关的知识，大多源自于外文网站<a
href="https://www.smogon.com/ingame/rng/dpphgss_rng_intro">Smogon</a>(虽然Smogon的一些资料也是翻译自日文资料).
没有多少是原作者原创的.
这篇教程更多是一篇翻译+整理，加上实际乱数的一些技巧.
感谢各位大大做的努力，造福广大口袋玩家.</li>
<li>本教程采用傻瓜式渐进方式，从头开始一点一点的讲解四代乱数，希望能带来一些帮助.</li>
</ol>
<h1 id="准备工作">准备工作</h1>
<p>如果你想要乱数闪光宝可梦，你需要知道你的<a
href="https://wiki.52poke.com/wiki/ID_No.#.E9.87.8CID_No.">SID</a>.</p>
<blockquote>
<p>如果你想要乱数的是已经创建好的存档，这可能会需要你导出存档并使用
<em>PKHex</em>
等软件查看你的存档（不涉及修改与导入），请根据自身接受程度使用.<br>
不会导出存档？看看这篇博客：<a
href="/Pokemon/Strategies/In-Game/How-To-Back-Up-Your-Savefiles/">如何备份你的存档</a>.</p>
</blockquote>
<h2 id="硬件准备">硬件准备</h2>
<ul>
<li>能够游玩第四世代宝可梦卡带的机器（<em>NDS</em> 或 <em>3DS</em>
系列）.</li>
<li>电脑.</li>
<li>（若需要导出存档）<em>NDS</em>烧录卡与读卡器.</li>
</ul>
<blockquote>
<p>如果不准备使用烧录卡，可能需要准备足够的神奇糖果.</p>
</blockquote>
<h2 id="下载乱数所需工具">下载乱数所需工具：</h2>
<ul>
<li>计时器<a
href="https://github.com/dylmeadows/EonTimer/releases">EonTimer</a>
如果因为国内 GitHub 下载速度原因不好下载，可以点击<a
href="/download/EonTimer.rar">这里</a>进行下载.</li>
<li>乱数工具<a
href="https://github.com/Admiral-Fish/RNGReporter/releases">RNGReporter</a>
如果因为国内 GitHub 下载速度原因不好下载，可以点击<a
href="/download/RNGReporter.zip">这里</a>进行下载.</li>
</ul>
<h2 id="了解四代乱数机制">了解四代乱数机制</h2>
<p>说到乱数，就不得不提 <strong>Seed</strong>.
对数论和密码学没什么了解的玩家，对于 <strong>Seed</strong>
可以简单的这么理解. <strong>Seed</strong>
是一个数值，在游戏开始的时候会确定下来. 然后游戏系统会根据
<strong>Seed</strong>
计算出一个长长长长的随机数序列，然后游戏内的随机事件，就会由这个数列里的随机数来决定如何发生.</p>
<blockquote>
<p>举一个最简单的例子，某一次我进入游戏. 当前 <strong>Seed</strong>
生成的前三个随机数是 F011，F410，0112. 那么此时我按下 <strong>A</strong>
键与我面前的一只闪电鸟进入战斗(身上无同步率).
此时系统会根据第一个随机数来决定闪电鸟的性格. F011 / A3E = 17.
查表可以知道，17对应的是Quiet性格.
所以我进入战斗遇到的这只闪电鸟性格一定是Quiet.</p>
</blockquote>
<p>既然 <strong>Seed</strong> 决定了游戏内的随机事件如何发生.
那么我们怎么来得到我们想要的 <strong>Seed</strong> 呢？</p>
<p>四代的 <strong>Seed</strong> 由两个因素决定.</p>
<ol type="1">
<li>在游戏内，按下 <strong>A</strong>
键读档进入游戏这一刻的时间，年月日时分秒全部参与计算，也只精确到秒.</li>
<li>从启动游戏这一刻，到按下 <strong>A</strong>
键读档进入游戏这一刻，所经过的时间. 这个时间的精度为 1/30
秒，即约0.033秒.</li>
</ol>
<p>这是四代乱数最基础的两点知识，想要着手开始四代乱数的各位一定要牢记.
最后，本教程默认读者了解涉及的一些基础知识，例如何为<a
href="https://wiki.52poke.com/wiki/ID_No.">ID</a>， <a
href="https://wiki.52poke.com/wiki/ID_No.#.E9.87.8CID_No.">SID</a>， <a
href="https://wiki.52poke.com/wiki/%E6%80%A7%E6%A0%BC%E5%80%BC">PID</a>，
<a
href="https://wiki.52poke.com/wiki/%E4%B8%AA%E4%BD%93%E5%80%BC">IV(个体值)</a>.</p>
<h1 id="id乱数">ID乱数</h1>
<h2 id="目的">目的</h2>
<p>通常大家追求ID，SID，是为了两个目的：</p>
<ol type="1">
<li>获得自己喜欢的表ID.</li>
<li>获得高个体的闪光宝可梦.
因为四代乱数机制的关系，一只宝可梦如果IVs全部确定，那么这只宝可梦就只有少数几种可能的
PID.
例如最常说的6V神兽，就只有6种可能的PID(火钢除外)，如果不借助乱数，自然获得一个ID，SID进入游戏.
那么我们获得6V闪光神兽的概率，也就和BW异国孵蛋出闪光的概率一样(而且性格还不一定是自己想要的).
所以，为了心仪的闪光神兽，乱一个 ID，SID 开始游戏，也是有必要的.</li>
</ol>
<h2 id="确认目标">确认目标</h2>
<ol type="1">
<li><p>打开 RNGReporter，选择 <strong>Time Finder --&gt; 4th Generation
Time Finder</strong>. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure1.jpg"
alt="Figure1" /></p></li>
<li><p>在这个界面，按图中所示的填入各项. year可以随便填. Min，Max
Delay，Min，Max Frame如果不理解的话，都和图上一样的填好.
然后填上自己想要的个体，性格，特性，性别. 点击 <strong>Generate</strong>
. <img data-src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure2.png"
alt="Figure2" /></p>
<blockquote>
<p>另外，这里有一个成对的概念.
具体原理略不过不谈，只需要知道，对同一组个体值，同一组
ID，SID，有两个PID会同时对应闪光.
例如图上最后两行对应的Timid，Modest，就是成对的. 一组 ID，SID
只要能让其中一个闪光，就必定能闪另一个.
从图上观察，只要两个分布具有相同的 Frame，Hour，并且 PID
的末三位都相同，那它们就是成对闪光的.</p>
</blockquote></li>
<li><p>找到目标之后，就记下这对分布的任意一个PID. 这里我们以最后一对
TIMID，MODEST 为例，记下 PID: 7942EF72.</p></li>
<li><p>在 RNGReporter 的主界面，选择 <strong>4th Gen Tools</strong> 中的
<strong>TIDManipulation ("Pandora's Box")</strong>. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure3.png"
alt="Figure3" /></p></li>
<li><p>在红框所示的地方，填入刚才记下的PID，Minimum
Delay填入5000(如果是乱Pt，建议填5300+)，勾上 <em>Infinite Serach</em>.
如果你想要一个自己满意的表ID，那么可以勾上 <em>Search for Trainer
ID</em>，在<em>Desired Trainer</em>框中填入目标表ID（这样耗时会较久）.
<img data-src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure4.png"
alt="Figure4" /></p></li>
<li><p>点击<em>Find Compatible
Seeds</em>按钮，就可以生成满足条件的ID，SID了.
因为会无限生成，所以在有一定数量的结果之后，请点Cancel.
之后从结果列表里挑一个自己满意的 ID，SID
作为目标，将目标ID对应的SEED复制下来. 这里以图上蓝色高亮的ID 20802，SID
51056为例. <img data-src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure5.png"
alt="Figure5" /></p></li>
<li><p>在 RNGReporter 的主界面，选择 <strong>4th Gen Tools</strong> 中的
<strong>Seed To Time</strong>. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure6.jpg"
alt="Figure6" /></p></li>
<li><p>在SEED(HAX)框内填入刚才记下的seed，在Second内填入自己觉得方便的描述.
这里以HgSs作例子，所以选择HgSs，其余设置和图上保持一致. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure7.png"
alt="Figure7" /></p></li>
<li><p>点击
<strong>Generate</strong>，在结果图里任选一组目标时间，作为我们实际操作的选择.</p></li>
</ol>
<h2 id="校准偏差与乱数id">校准偏差与乱数ID</h2>
<ol type="1">
<li>使用 Eontimer 击中seed，这里请查看<a
href="#如何使用Eontimer计时器">如何使用Eontimer</a>.
<ul>
<li>如果是HgSs请在上图所示的界面等待计时器到0进入游戏. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure8.png"
alt="Figure8" /></li>
<li>如果是DPPt，请在上图所以的界面等待计时器到0时按 <strong>A</strong>
键. <img data-src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure9.png"
alt="Figure9" /> 操作细节请注意:
取名字的时候，每次都按相同的操作取名字，以免造成帧数不必要的变化.</li>
</ul></li>
<li>进入游戏之后，查看自己的表ID，这个ID多半不是我们的目标，此时需要确定偏差.</li>
<li>将得到的表ID填入下图的红色框内，seed对应的月日年时分也依次填入.
MinMax delay填入自己估计的偏差. 例如目标是4987，那Min
Max可以分别填入4900 5100. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure10.png"
alt="Figure10" /></li>
<li>点击 <strong>Find</strong> 按钮，看到自己实际击中的delay.
如果没有结果. 可以将Min Max的范围扩大再搜索.
如果依然没有，请检查年月日时分秒和eontimer的设置是否正确.</li>
<li>得到我们实际击中的delay之后，即可使用 Eontimer
调整偏差，继续尝试，直到得到目标ID.</li>
</ol>
<h1 id="如何使用eontimer计时器">如何使用Eontimer计时器</h1>
<p>Eontimer是一个非常好用的计时器，功能涵盖三四五代，这里我们只需要用到四代的功能.</p>
<ol type="1">
<li>打开软件，选择 4 选项卡. 除了红色框内的：如果是
HgSs，参数如图上所示就ok. 如果是PT，请将490改为600，其他不变.
这样就完成了初步设置. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure11.png"
alt="Figure11" /></li>
<li>我们从RNG的Seed To Time 工具里得到的时间是这样的. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure12.png" alt="Figure12" />
想要击中对应的目标seed. 将对应的秒数填入红色框内 Target
Second的位置(这里是47)，将对应的delay填入红色框内TargetDelay的位置(这里是4987).
然后设置游戏机的时间到目标时间(这里是2013年4月23日，13点57分).
注意图上的 Minutes Before Target 后面红色的数字.
这代表需要提前设置的分钟数. 这里的分钟数为1，机器时间设置需要提前一分钟.
即为2013年4月23日，13点56分.
如果是0的话，就不需提前，按目标时间设置就好.</li>
<li>设置好之后，同时在机器时间设置界面按下 <strong>A</strong>键，以及
Eontimer 的 <strong>start</strong>按钮.
这时Eontimer即会开始计时，在第一个计时到0的时候，在机器的主界面按
<strong>A</strong> 进入游戏（如果是 DSi 或者 3DS
系列，可以提前进入游戏后在归0时软重置，不然校准误差时需要多往后搜索一些）.
在第二个计时到0的时候，在读档确认界面（即选择存档进入游戏的界面）按下
<strong>A</strong> 键，进入游戏.</li>
<li>进入游戏之后，我们可以通过各种方法来验证自己实际击中的delay.
将实际击中的delay填入Delay Hit
框内，然后点选Update，Eontimer会自动调整计时. 当然.
如果你击中的delay离目标delay已经很近（+-6之内），那么基本不需要Update，保持一致的操作，反复尝试即可.</li>
<li>如果击中的delay和我们的目标delay奇偶不同，那么在Seed To
Time工具内，改一下种子的年份(+-1)，用新生成的种子作为目标就可以了.
如果是在乱ID的时候，也可以不改年份，在取名界面多改变一次大小写.
（据说对于DS系统，插入GBA卡带也可以改变奇偶，有待测试）</li>
</ol>
<p>大部分时候Eontimer的使用都如上面描述，不过还是有几个特别的地方：
在乱ID的时候，由于没有读档界面，在第二个计时器到0的时候，请在乱ID篇给出的界面按A.
(友情提示，乱ID前记得删除存档)</p>
<p>另外是秒数的设置. 几乎所有的情况，和目标秒数保持一致就ok.
唯一的例外是<strong>在HgSs(仅限HgSs)里乱ID的时候，Eontimer的秒数设置比目标秒数减3.例如目标秒数是47，eontimer里就填入44.</strong></p>
<h1 id="宝可梦乱数">宝可梦乱数</h1>
<p>在前文讲seed的时候提到过，seed生成了一个长长长长的随机数序列.
但是，如何用这些随机数来生成我们实际得到的宝可梦的各项参数：例如个体，性格，特性，性别，是否闪光之类的；均是由method来决定的.
所以，即便是一串相同的随机数，在不同的method下得到的宝可梦是不同的(即便是同一编号的宝可梦).
最简单的例子就是绿宝石内定点的变隐龙和野生的变隐龙，即便在相同的随机数序列下，抓到的定点和野生的变隐龙也是不同的.
所以乱宝可梦，首先要知道它对应的Method.</p>
<h2 id="确定乱数目标">确定乱数目标</h2>
<p><strong><em>如果选择了野外相遇的宝可梦，请在队伍中准备一只习得了<a
href="https://wiki.52poke.com/wiki/%E7%94%9C%E7%94%9C%E9%A6%99%E6%B0%94%EF%BC%88%E6%8B%9B%E5%BC%8F%EF%BC%89#.E5.8F.AF.E4.BB.A5.E5.AD.A6.E4.BC.9A.E8.AF.A5.E6.8B.9B.E5.BC.8F.E7.9A.84.E5.AE.9D.E5.8F.AF.E6.A2.A6">甜甜香气</a>的宝可梦.</em></strong>
确定乱数目标后，选择相应的 <em>Method</em>. 如果是乱数蛋，请点击<a
href="#蛋乱数">这里</a>.</p>
<h3 id="method-1"><em>Method 1</em></h3>
<ul>
<li>初始御三家，赠送的前代御三家</li>
<li>赠送的波可比的蛋，小卢卡的蛋</li>
<li>赠送的伊布，3D龙，巴尔郎，迷你龙</li>
<li>各类化石复活的宝可梦，游戏中心兑换的宝可梦</li>
<li>各类游走神兽：雷公，炎帝，水都，美梦，游走蘑菇，三鸟（水都和三鸟只有游走的才是
<em>Method1</em>）</li>
<li>阿尔宙斯祈祷剧情赠送的DPPt三神</li>
</ul>
点击下面的谜拟Q来查看英文描述：
<details>
<summary>
<img no-lazy data-src="/images/mimikyu.png" alt="Method 1 请点击丘丘" align=left>
</summary>
<p><br> DPP：<br> Starter Pokemon<br> Cynthia's Togepi Egg<br> Fossil
Pokemon from Mining Museum<br> Riolu Egg from Riley<br> Eevee from
Bebe<br> Porygon from Veilstone<br> Cresselia， Mesprit， Articuno，
Zapdos， and Moltres<br><br></p>
<p>HgSs：<br> Kanto/Hoenn/Johto Starters<br> Togepi Egg<br> Bill's
Eevee<br> Raikou， Entei， and Latios/Latias roamer; the Latios/Latias
from the Enigma Stone event is NOT Method 1<br> Tyrogue from Mt.
Mortar<br> ExtremeSpeed Dratini received from Dragon's Den<br>
Goldenrod/Celadon Game Corner Prize Pokemon<br> Fossil Pokemon Pewter
City Museum<br> Sinjoh Ruins Dragon event where you need
Arceus<br><br></p>
<p>Note: Any Pokemon received from a trade or as a gift that has a fixed
nickname and OT (Kenya the Spearow， Gaspar the Haunter， etc.) will
have set IVs and nature so RNG manipulation techniques will never work
on them.</p>
</details>
<p><br><br></p>
<h3 id="method-jk"><em>Method J/K</em></h3>
<p>Method J/K(DPPt对应 J，HgSs对应
K)的宝可梦可以被同步率、魅惑身躯影响（之后的选项中需要更改
<strong>Requied Lead</strong> 项）.
而游戏中几乎所有的野生怪兽、定点神兽都对应Method J/K.
（愤怒湖的红色暴鲤龙是Chained Shiny Method，不要尝试用Method
K去乱它）</p>
<p>如果乱数野生宝可梦，你还需要选择 <em>Encounter Slot</em>
项，点击顶部菜单项 <strong>4th Gen Tools</strong> 选择对应游戏版本的
<em>Encounter Table</em>，来查看你想要的宝可梦属于什么 <em>Encounter
Slot</em>.（可能需要科学上网）</p>
<h3 id="wondercard-ivs"><em>Wondercard IVs</em></h3>
<ul>
<li>在商店领取的Wondercards宝可梦 <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/WonderCards.png"
alt="WonderCards" /></li>
</ul>
<p>对于 DPPt，您需要保存在 Pastoria City Mart，因为那里随机移动的 NPC
数量最少. 对于 HgSs，请保存在 Fuchsia 或 Cerulean City's Mart
中，因为这两个位置都没有随机移动的 NPC. 在当前没有 NPC
移动时进行保存也很重要. 此外，在 DPPt
中乱数时，请确保在进入游戏的那一刻调出菜单，以防止 NPC 移动.
与其他方法不同的是，无法在不作弊的情况下保证获得确定的性格，多尝试几次吧.</p>
<h2 id="乱数宝可梦">乱数宝可梦</h2>
<ol type="1">
<li><p>打开 RNGReporter，选择 <strong>Time Finder --&gt; 4th Generation
Time Finder</strong>.</p></li>
<li><p>Year Min Max Delay Min Max Frame如果仍然不理解，请按图上的填入.
个体性格按自己需要的填写. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure13.png"
alt="Figure13" /></p></li>
<li><p>点击 Generate，得到目标 Seed，我们选择帧数较小的一个.</p></li>
<li><p>用seed To time 工具得到种子对应的时间和delay，设置好 Eontimer.
（如果有游走宝可梦可以打开map来方便确定delay）</p></li>
<li><p>将游戏进行到所需位置存档.</p></li>
<li><p>用Eontimer计时器辅助进入游戏之后，<a
href="#初始帧与判断delay">判断实际击中的delay</a>.</p></li>
<li><p>找到实际delay之后，调整eontimer的设置，反复尝试，直到击中目标delay.</p></li>
<li><p>击中目标delay之后，<a href="#增加帧数">推进至目标帧</a>.</p></li>
<li><p>触发，得到宝可梦.</p></li>
</ol>
<blockquote>
<p>需要注意的一点是，在野外乱数时，很可能受到随机NPC的干扰，这里就需要乱数的各位自行调整偏差.
可以根据第一次击中帧数的偏移帧来调整，也可以通过打电话看回复的方法来调整，这里就留给大家去尝试吧.
这里能给大家的一点经验就是，在同一个地方不同的时间存档，帧数的偏移很可能会不一样，因为存档的同时也记录下了NPC的位置，所以调整帧数之后不要重新存档.</p>
</blockquote>
<blockquote>
<p>最后，几乎所有的Method1 宝可梦起始帧数都为1.
例外主要是同时判定多只宝可梦的情况.
比如燃烧塔同时判定雷公炎帝(1、6，欧版反之)，白金和大木博士对话同时判定关东三鸟.
三鸟先后顺序是火焰鸟、闪电鸟、急冻鸟，帧数分别为1、6、11.
比较好的方法是，先乱其中一只鸟，把目标的那只捕获后，打死另外两只，再和博士对话.
这样剩下的两只释放时，先后关系依然如上，帧数分别对应1、6.
不建议在和宝石钢天王对话时乱游走水都，因为那地方NPC多，帧数难以控制，所以游走水都还是很使用打联盟的方法乱吧.</p>
</blockquote>
<h2 id="初始帧与判断delay">初始帧与判断delay</h2>
<h3 id="hgss">HgSs</h3>
<h4 id="通过打电话来确认帧">通过打电话来确认帧</h4>
<p>在某些情况下，我们只有使用打电话的方法来确认delay.</p>
<ol type="1">
<li><p>在35号路获得杂耍艺人 麦克的电话： <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Irwin1.jpg" alt="Irwin1" />
<img data-src="/images/body/Pokemon-RNG-Abuse-Gen4/Irwin2.png"
alt="Irwin2" /> Irwin可能的回复有三种： <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/E.png" alt="E" /> <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/K.png" alt="K" /> <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/P.png" alt="P" /> 分别记为
<strong>E</strong>，<strong>K</strong>，<strong>P</strong>.</p></li>
<li><p>进入游戏之后，快速转到打电话页面，给Irwin打电话，记录下每次打电话的结果.
注意，每打一个电话会增加1帧，如我打了8个电话，回复序列是P P K P P K E
E，则前进了8帧.</p></li>
<li><p>在 seed to time 界面. 选中目标时间和delay.
点击界面下半部的generate. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure14.png"
alt="Figure14" /></p></li>
<li><p>可以看到，结果列表里出现了目标delay附近的delay对应的电话序列.
用刚才得到的电话序列去列表中对照，如果完全吻合，即可基本确认，我们实际击中的delay是多少.
刚才我们的8个电话的回复对应的是delay 1061.
因为1061和目标奇偶不同，所以需要改一下年份，重复前面的过程.
具体参照eontimer的部分.</p>
<blockquote>
<p>如果距离目标delay差距较大，界面的Delay+-(图上是+-10)，例如改成+-50，结果列表里即会出现距离目标delay+-50范围类的结果.
继续查找就行.</p>
</blockquote></li>
<li><p>如果结果范围太大. 可以使用界面上的 SearchCalls 按钮. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure15.jpg" alt="Figure15" />
将自己的电话回复填入，直到 PossibleResults
是1的时候，点击确认即可找到delay.</p></li>
</ol>
<h4 id="通过游走神兽的位置来确认帧">通过游走神兽的位置来确认帧</h4>
<p>在RNG的Seed To Time界面打开 Map 按钮.
可以看到，游戏内地图上每一个游走神兽可能出现的位置都用数字编号标出.
进入游戏之后查看游走神兽的位置，即可知道自己当前击中的seed. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Map.png" alt="Map" /> <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure16.png" alt="Figure16" />
在地图上存在游走神兽的时候(R雷公E炎帝L水都)，查找seed的时候需要勾上对应的选项.
然后在delay范围的列表里，可以看到每个seed(delay)对应的游走神兽分布.
进入游戏之后，快速打开地图. 查看游走神兽的位置，与给出的位置对照.
如果发现游走神兽的位置是 R 33 E 30 L
17，那么就基本可以确定击中了目标seed. 当然如果出现的位置是 R30 E 35 L18
那么基本就可以确定击中的delay是8487.
同样，如果delay的范围较大，可以使用searchroamers的功能来查找.</p>
<p>最后需要注意的是，地图上有游走神兽的时候，读档开始游戏时就会额外的消耗帧.
绝大部分情况下，都是1只消费一帧.
所以，地图上有N只游走神兽时，起始帧数即为N+1，乱数时候请牢记.</p>
<blockquote>
<p>在极少数情况下，会出现某只游走神兽消费两帧的情况.
这个时候，即便击中了seed，游走神兽的位置也会和软件显示的位置不符合.
如果发现反复击中目标delay前后，但是老是击不中目标.
这时候可以用非目标的那个位置打电话验证一下. (我还没遇到过这种情况)</p>
</blockquote>
<h3 id="dppt">DPPt</h3>
<h4
id="使用口袋手表的硬币插件来确认帧">使用口袋手表的硬币插件来确认帧</h4>
<p>在选择DPPT的选项时，生成的结果列表里会有seed(delay)对应的抛硬币结果.
在Search Flips 选项卡里，可以看到 T H 的含义. <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure17.png" alt="Figure17" />
<img data-src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure18.jpg"
alt="Figure18" /> 进入游戏之后，将抛硬币得到的结果输入，直到Possible
Results变为1，确认之后就能找到结果了.
与HgSs的不同点在于，抛硬币不像打电话一样会增加帧数.
另外，在PT中，进入游戏时的日记会增加帧数(看一页增加2帧).
所以在PT里乱的时候，到目标处，存档读档再存档，去掉日记的干扰为最佳.</p>
<p><strong>白金的<a
href="https://wiki.52poke.com/wiki/%E5%AF%B6%E5%8F%AF%E9%8C%B6#.E6.8E.B7.E7.A1.AC.E5.B8.81">抛硬币插件</a>要拿到攀岩之后才能获得.
</strong></p>
<blockquote>
<p>注意，对于无法利用上述方法的场合，可以通过导出存档后查看个体并通过RNGReporter的工具<strong>4th
Gen Tools --&gt; Find Seed by IVs</strong>来反查seed/delay.
此外，也可以参考别人写的呆呆兽初始与迷人之躯教程中列表的方法，但会很耗时间.
相关文章可点击<a
href="/download/GEN4-Slowpoke-RNG.rar">这里</a>下载.</p>
</blockquote>
<h3 id="初始御三家的确认帧">初始御三家的确认帧</h3>
<p>在目标前存档并<strong>备份</strong>，领取后导出存档，根据<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part3/#确定初始seed组并选择备用初始seed">宝可梦火红叶绿实机乱数（不包含
ID 或
Egg）中【确定初始seed组并选择备用初始seed】章节的7~9步</a>的方法进行反查得到初始seed。</p>
<blockquote>
<p>注意，pt的初始会有游走npc消耗帧数，请尽快操作，并记下消耗帧。</p>
</blockquote>
<h2 id="增加帧数">增加帧数</h2>
<p>HgSs里，已经讲过打电话的方法，每一个电话增加1帧. 但是这非常不方便.
还有一个HgSs和PT通用的更好的方法：聒噪鸟.
在给聒噪鸟录好音的情况下，查看一次聒噪鸟的状态增加1帧(不需要听到叫声).
身上准备好两只聒噪鸟，来回切换，即可快速方便的增加帧数.</p>
<p>另外就是HgSs的广播也能增加帧数.
比较有用的就是博士的口袋广播，听一次会增加14~18帧.
在目标帧数成百上千的时候比较有用.
我个人没有尝试过，具体请参见外网资料.</p>
<p>存档一次也可以增加一帧，可以适用于初始乱数。</p>
<h1 id="蛋乱数">蛋乱数</h1>
<p>想要乱数蛋，首先还是要弄清蛋相关的乱数的机制.
在游戏里，每走255步就会判定是否出蛋，并且同时判定蛋的性格值，性格，特性，性别，是否闪光.
一旦确定，除非从老爷爷那里收掉或者拒绝掉这个蛋，否则不会更改；这里用来判定的PID，并非是前文所说的那些，而是用的一个叫做Egg
PID的东西；Egg
PID所用到的随机数是由我们所熟知的随机数序列的种子，经过另一个随机数算法得来的.
从老爷爷拿蛋的时候会根据当前的PID(这个PID即为我们在乱定点/游走/野生时候所说的PID)来决定</p>
<figure>
<img data-src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure19.jpg"
alt="Figure19" />
<figcaption aria-hidden="true">Figure19</figcaption>
</figure>
<ol type="1">
<li>打开4th Gen Time Finder，进入Shiny Egg选项卡.</li>
<li>按自己的需求选上对应的性格，特性，性别，是否闪光.
如果是异国婚姻，记得勾上左边的 International Parents.
都弄好之后generate.</li>
<li>强烈建议选Frame为1的作为目标，这样我们可以省去增加Egg
Pid的步骤.</li>
<li>选中目标之后，将宝可梦存入，记下先存入的为Parent A，后存入的为Parent
B. 不要带不变石or项圈什么的. 都弄好之后到屋外存档.</li>
<li>之后的操作和前文乱数类似，将我们的目标Seed用seed to
time工具换算成时间，用eontimer辅助进入击中seed.</li>
<li>用游走神兽确认击中之后，在老爷爷面前来回跑动直到出蛋.</li>
<li>出蛋之后在老爷爷面前存档，拿蛋，验证一下是否是我们的目标.
如果闪光，性格，特性，性别不正确，回到步骤5 <img
src="/images/body/Pokemon-RNG-Abuse-Gen4/Figure20.jpg"
alt="Figure20" /></li>
<li>用 EggIVs
选项卡，ParentA/B里分别填入对应的个体，右边选上自己的目标个体.
都填好之后generate.</li>
<li>目标结果会非常多，随便选一个帧数在10以上的吧(因为需要电话确认帧位置，所以不建议选太小的).
蓝色高亮的是我们这次例子的目标. 右边还贴心的列出了直到目标前的电话回复.
这里是(E E E) K P E P P P K E P K. 注意如果地图上有三只游走神兽的话， EE
E这三帧会被消耗掉. 再加上周围有NPC的原因，我们打的第一个电话可能是 K
也可能是 P E P.
所以多打几个电话，确认我们帧的位置，不过记住，打完最后的K之后，就可以退出菜单和老爷爷对话拿蛋了.
例如，我打的前三个电话是 P P P，那么我还需要打 K E P K
4个电话，就可以和老爷爷拿蛋了.</li>
</ol>
<h1 id="礼物特别篇----玛娜菲的蛋">礼物特别篇----玛娜菲的蛋</h1>
<p>从Ranger联动过来的玛娜菲的蛋不同于普通的礼物，是<strong>method
1</strong>生成的.
系统为了‘防止’玩家获得闪光的玛娜菲，在生成蛋的PID的时候，会用当前玩家的ID/SID判定是否闪光，如果闪光，就用下一个PID，直到不闪光为止.
然而，蛋里的宝可梦是否闪光，是孵出来的那一刻判定的，这就给了我们钻空子的机会.
假设我有A，B两张四代卡. 我在A卡里乱一只PID能和B的
ID/SID判定闪光的玛娜菲，传到B卡里孵化，那么就可以成功获得闪光的玛娜菲了！</p>
<p>具体的操作方法，就留一个小小的尾巴，让各位自行尝试吧.
不过有一点建议，因为通信会强制存档，所以乱闪光玛娜菲我们只有一次机会.
建议在HgSs里乱玛娜菲(<strong>因为没有随机NPC</strong>)，然后再传到其他卡带里孵化，如果对乱数熟练掌握的话，成功率几乎是100%.</p>
<h1 id="reference">Reference</h1>
<ul>
<li><a
href="https://tieba.baidu.com/p/6552613197?pid=130747309042&amp;cid=0#130747309042">【转载】四代乱数教程及工具</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc21vZ29uLmNvbS9pbmdhbWUvcm5nLw==">Smogon RNG
教程<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Pokemon</category>
      </categories>
      <tags>
        <tag>Pokemon</tag>
        <tag>Pokemon-Gen4</tag>
        <tag>Pokemon-RNG-Abuse</tag>
      </tags>
  </entry>
  <entry>
    <title>间谍伞日记</title>
    <url>/Game/Undercover-Brella-Diary/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Invalid Password. Check And Try Again! (♯｀∧´)" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ee1d2eeb4aae9d53e5241d3b782e2073b909260145eedd012aa2bc99b685d959">bbb16d5eb5d590483619b745c2ff015e5bbdb9d16a931534ef63064b108c46faf5563aecf220e5d82ee06593fed8d58555699f90faed43797181c1c86add51c7e5c75a62160bd96fc51afe33b3030fb61d4ed9e713d5be5ff3d1e607e56fdd19f3fb1079853e775d841c1dafbc2ec9d8e432c65bf2dc94596270dd85cf20a3fc186604e987b307e2863e314dfdf84c9773a5cb28a824d77ce229733e3093448de1f81d8c7d233bb4aaf4000b1a4f9f890b854d4d9ee1478c6a0cdde50e607841d7f8b3d0576b628050994ebacdd9a377ed7edaec25d9c9ab5f2d8789cda4b0cd5057553f078f249dfa4066b63a040d58a8e84573b81b85d39a8e5963c9444d5c19551a26dbe7c5107f83b11017ff76f5ed9581a78e7f7301e864be54517105c74f64a780b1b32c7a9de2f32f051965cb27eaac2b62e898cd169944fef675439f3b27e5709b6942b0b94e7f32df8bda7eff2e17e3494cd25d7d86105542cb3f5a62726082cf2ce9106561eec05cacbb7ac04d73fb5460ce48e8d073e7b4924164d4dee79cf7f5129c654282700db028043b1a9b716c9d69718c01c9c9c905d2398295566b751b6062daed3a2be618e4d4f52f1fdf3a1b6d50dc75f619a4e5acaeea2befa621c7603138410f4b3fe216fba1832fc1ff5611ee57bfcb0e60f8bce00557bc5971895c3e54915c4f55511678443c34c16eec1a575dda2ea5193ac10bde12df35287959f7fc9263e247ef28ce25805b56bc14415c83f1728de247330fdaa1436da12fe8d73ef2acecf20b69620f1d080246e1539b095ee975b6ee9a9c4f1c95d3b7301e43d0732210f6fdd344c357b6d24c00007c519f493b25a14031898202a61fd0272afeb015fdd5c24e7476e898a27df919a5393250a1527eb75bbfe334e4582a26ac827f8b59fc6eeb40c80f58fe457b922661b4182fe0a7bc7d356d7bc469ae8e6b5baf2b07109670a05dae254a3bd421f0a3b7e452adc061e2272a318a393936b9748eb69ed198b443f0ef187f825dcff3ebc00f9f71216e99a47233fdaad198331b29aefef53fb2894a8b8bae82838b067a261247914d3a19878a62937f1932f485c645b08e892fca35483c345896b50e9cc66cf7d712faaa2e6ffacce60bbba2d08560890766ccb20eff6415a5bae05ba007569e5198d08d5721e0806fccb4ea0b5566a26db3807a85d6dd1ba2ed7f3b4a8a1327055323523afd0d354b61e20a381abf85d5a87ab17f7add5fe714aa1c0fb34dfbb0fd7fdf0ede075b49737821362846e6e03bea9262b7ada1696d841004a57ae805296df951f9ce9076fa5068702a7e62bf5aacd5cdd47f9ed1e6150c4a145a80c6e33db80d98e6cbe4539918a8a04ef4121e540c97a6b4f399dcbc9dc069d523cc0d2c463398156952c9362b8b47a4776a16fed3703d2d62572f2a953663d350de8d3a735aa56f2fd675c465a72873dae149862db6644ec751144779ffd7bc07e13977dccb782135258e99343a81317189deb74dfc47060f2d91fb56c9abe04c02a1f005516091678f481a531259749540911f0c464d799ced56399ddd24312b486854d692a7e9062e1bac61d5313bce59944736fd9cff69a1c794c0bde2fbf2ff63a444afc4da935d52555470714fbdbc0f9de376fbd51d561fd96718cab52b55a7f70c5987af3a52bdb0476a6cbe8d28d1f5a4900b089a1f909bda4a898debe02d6a3e33427551dde5571954035546d8d553d0110e813b1f4459c81c1be61992d8dd7ef79d6372a389924e41d4f4d74d26124ad60b418dfb2adf6e5668ea2bfe6772056b9a699ba44961fbf343da43df1edc52a866a9b2e19f7c74c49a7eefd60f351503c7a4f5f8ed2bb7de8cc0dc965056c8d832b750e6ce91ec895be1d1e0bee306bbb08d2b9a90e365e76e1d196e1c01c6d8410dfd61c3508bc3a192d03312b6ff9883f4053e94aa1b8f8c3c0ca399aa6e958dc0a0612990f8daec5d31bd98d66f7995b12a4cc6b300b6285eb96ad1e37579aa84854c6978024cd86dad11f2ed456e80ef876e8229ae35a15895551f83d8b2174b9c8e15a7df996420b7a7735b92a4eb0c3074d0c05e4d51f50ac49d53a7a75ce092345404eb8e09a6dd22ea88b1d8be33131e44784102cade57457a811287438394cf69a68f809e04319c085b2f58f193bb179e34bab17d929c2a46f0d3bdf90a879dc4d15327fce5537bd6de10deb9d31f45a8de866eb83117bc16398ad287e5d17b71853212aa69ab4396cd4d961d9ac0189c65a10af2c098e2e07dfc72667da3e531e936f1cde5f5e03d63a98eaded3e910da448d88fb369bdb1a752e79e96c130be5416cd709f188102e7bf20b20e61eadaee3d7a7e9ca84f96aed92c5ee3f349752bdaee38146040a7cff2a7fae48f7c2c38262102fa32f37c2041205dbce37f0f33c1b169bc0d38de65282fba322e526aacb42eb25ec1320cf334f50caa0623402a71a73bda2de022443b171fcf9232a83e45ab05c16ebb39c593451cc5db25bc20d9d91b7c97c17ae264607bf4f9a8ffc23bb275932b811ac91cc0edad6adc976f9a744cb6ef31d3ebc7e06239e9a156658027daf63bf094fbdfea5b43acd6b60d71b1f78034cb1e2e9c37ad157647e4e0135419c21a66f76af7c6cab283397b8ff09a10a837d0cbd0c51a063c53dea50a225352a2213461d7c056a94f413d3ed74147297e0225087fafa536d11f6adf3fb8c60c6c2d0b5fb4153d74f0ff2bdf76cb13744249e212ed14c51aa197afb3f1a15efbc54f647bd430c4ae89486505c826b22d903160ad070034158a5a6e01ac1201020b3561e024c78e022270ab49ab219f6c680d3ff0a0f361710081056046fea20c76185859c22c2609e93a6ed1a373d3aa7abaab1b5d6021ad7a5de69fc1247c9bf81bd13a574df86a1cfdcc9283b0b6c36cd0596d5138ba19a3e1df83846cac61f7e24e1a7285a3d9179c631028fa5ea6f7df136660a2f8b4a12a037ec4073c14b42ab9830cb28ef82f17907d869bb2b00e67ac0e25da232c8ae9035c4465eba482312eada62a676150132bd35fef6ad4fea1ab41104bc5de8f4a973cce0bf4f3efd7285d123d0f8e5d7ae7af7b99caefe2b37f4810a028560d5883ca1d2ee6959d75454ef0d289b0b60d5fb61909a3f16b9a41030cbaf95450937545620bf56b592b96f9488a0d939c012569e86544c35affb1e859650f60545fa25fd26d85be66f37c5851fd6834fb10eed61ff645b30b39534a4ca40aafe33000426c5c2701818e0baba9a509559632fde257439e0c35f36eed141f8d58d2cbb44cef1cc5bc0ec6641f1222b5b4819c96adc6f69031acc57da5fcb934e551a8bfaddeb8eb238fe911ce4ab751355899c1d851c4dab348f7cb31e3b90a439cba0dd3bb977603c25ff39ab5b1a2a2110a477b6c4e0370eb7ccfa1f1c71c045cd3cf7d61f5677b55ea6c0dafe2c5c7759ab3fbfa3d2b7330c149a6e20541d837d7d7161b87b4ccf77a90ac0fb4923290261e887c7638792846971567e9873bae97cd17e9b036116fb834b0cdf67192d6a3b34e77f159670d0f0e26f78b6012b96bf443c8e56d4c79a374ec6e67e1a1ee99c3572cc48dc3081e4ea8feca0f2ef1e80aa934bba20f9b68f285d354c7832a3f95373781a29fe827cbb02d72ece63bc298ab197c35e1cfdd46581feb73b8c5be928af52a9b4da8f5780b7469544f968b1c64d10ed11127afbd6e65f5f468cf9651be91bc9d85601b99fcf5dc680f6d1c5dc0416c418d1fe439a255f8062801df12b0371803d35122ed7cc0c988a7b0140aec956e9b95d1603bc5fb553a617107ddbf4d6785800f62f8a57c8d3fb70d98c89095decde9196650136f7b525a65466bb775cd51a65e4b27a57442db48435d37454d7782cd88aea8e50d3ea16b9a0b9eb6812852f5b6911a3241a8f301b39ebb22d0ccc2eff9e9130d915c5d37d65df619cb5b004490c0beba2605ebc56114d963549b263783ab12a1e104acdc4d4ccb9fb82a4c9c1c43850f21fb40ac3e9ef4f7b1baac2f5550960807bb57715580f4db525911cd389f7c7ec3656adfeb1b946c66ebdad8fbb808f0ee29cd36b99554017beb651bc74b7594d9ba4c9ff99876a900fa9ac4e86bf8afe075b3a4e4033acafabf70dd98d3684d41f875483f633546444eea80bedea85b98d553a22de7698548b50cc11e8a94affd978eb9440e6797ce021d2c4f86a8b750d40b1759c70d11e38e05d9a9a1a8c2d19435e1b7155aa4eedf05e87d50cfc5ca39759180be90b450e11529cc5119b1c087d0163c5c5d926689a3ee21b7fb30796eff59fe9a4dca0f4a5794b43f1254aa1276c042876a7a321a415df7bcabb4777afde11b87bef31eb54b8622c6c2fae6806418a9f967c2a56912d0a9138de9940ae51629e2fa11b15c7f14980764c78762f61a03adf847466ab42b1d4c0855ab5239d3e39912094498f1a8ae9dbbfdadfeed7c5f62ceb534628604e29df6cfd5d01b03a1919ae2d48a8ae6033fb5e44e0a9f2a687b625749b3ba76e59a32410eaf6581dc491397c29351ff83588a174eb149f0f282bc8fb3d8546ae378af26597dd76160cf4efcc28cbe01b646f080de58512531234c538f5e03b1ebb0ec19d8869ae341e5621d8aef99471d5cd2ffe2733bbf8b33dcd23c7fd5eb5f62c324ebf2b7871ff2edf0813fcbe6e3e73c29466c3b0509c0c37e24e1a0291c239f13bb9e7319d57599585f88091983746f4583ebf32964734a4823d9563af15d099b5fa5bf2ed32db0939d9ba9467788de02a36d63e80eca37dbfcf189ec6b9539e9a97104ac3c1702ac6d9a14542531a25ef64dfd7f130dbe9252ee4625e93d846f09b86ae3a39b09fe101c851905391f58f94bd3c2a04424513ba101c97f8b373c3ca0ba570eef1a98ffa86e7af027caf9394b3d59990b5b043819805add34a38c9240dd9d5250e0a21b747e9a17edb1568a213a37bea2a2c850b69ba076f8a42b54b9e45afae2911441621877504d6c3ab8ca2bd5ce8dae5302744e485aa3a8fdba5a634d31a0870f44fe75a66ef9709d8089a067810bc78122302465346d40b603be01f360e6ecb591d0b11350be65ed9bf480f876ad454ebc22ecfda553cc3754211424575e9d0e5f43a784a0591482557a171fdcafa26feebe45d347e9fe4b7bda681fea1ef219db27e2cd4fc1d11349bfcc9db65e33a0dc324674eea8d706782aacbc6e024d3341ae5ef47a40881684c20dc71b67be5f82314c5a36d0cc3d5989</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>Game</tag>
        <tag>Splatoon</tag>
      </tags>
  </entry>
  <entry>
    <title>战斗金字塔刷闪教程</title>
    <url>/Pokemon/Strategies/In-Game/Battle-Pyramid-Shiny/</url>
    <content><![CDATA[<p>对战金字塔中会出现很多平时抓不到的（闪光）宝可梦，但却没有办法抓，是不是很不甘心呢？这篇攻略为你带来了捕捉方法！（<strong>当然很难也有副作用</strong>）</p>
<p>本篇文章为个人译制，可能有些许地方措辞不当，请多包涵！</p>
<p>封面 [ID:91220788].</p>
<span id="more"></span>
<p>这篇在2021-06-10日完成，最近翻出来稍微修正了一些，顺便再发一遍好了.
原篇请见<a
href="https://www.bilibili.com/read/cv11658440">我的b站专栏</a>.</p>
<p>感谢老金的小校对、XXC的怂恿、卧看微尘的模拟器协助与各位群友的支持！</p>
<h1 id="acknowledgement">Acknowledgement</h1>
<ul>
<li>原作者：olig</li>
<li>技术基础：Metarkrai</li>
<li>翻译：willkyu</li>
<li>补充、后期测试与加工：willkyu</li>
<li>校对：willkyu、老金</li>
</ul>
<p>授权图： <img
src="/images/body/Battle-Pyramid-Shiny/Authorization.webp"
alt="Authorization" /></p>
<p><br></p>
<h1 id="战斗金字塔刷闪教程">战斗金字塔刷闪教程</h1>
<p>————或者说是一个让你得到日思夜想的FLoYT的教程</p>
<blockquote>
<p>译者注：FLoYT是First Live on YouTube的缩写<br>
已将作者上传的内容包括原文与存档放在了百度网盘，需要请自取. <br>
百度网盘：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXZwTEM4Vi12Q3Q1dVFoY0lYXzB5VlE=">https://pan.baidu.com/s/1vpLC8V-vCt5uQhcIX_0yVQ<i class="fa fa-external-link-alt"></i></span>，提取密码：will</p>
</blockquote>
<p><img data-src="/images/body/Battle-Pyramid-Shiny/Head.png" /></p>
<p><br></p>
<h2 id="简介">简介</h2>
<p>我整理了一个在宝可梦绿宝石的战斗金字塔中捕捉闪光宝可梦的简化教程，这种方法利用了榴石果漏洞（然后连锁二次崩溃（double
corruption）），但这个漏洞没有那么一无是处.
不过，这确实要花点时间，所以请坚持下去.
你只需要一张绿宝石卡带和一台Nintendo DS (Lite
或者初代饭盒)，但如果你想准备得更充分一些，我建议再准备一张烧录卡.</p>
<p>我并不是这方面的专家，但在我成功实现这个漏洞后，我想我应该做一个教程.
有比我更了解的人提供了更深入的指南，但是我发现的相关的 Pastebin
都有些难懂，并且真正有帮助的视频是法语的. 如果你确实想看看这些 Pastebin
和视频来参考的话，我把链接放在了下面. 不过我建议只看最下面的视频，因为
YouTube 上的其他视频都不完整的.</p>
<blockquote>
<p>译者注：Pastebin是国外一个存储、分享代码或文字的网站.</p>
</blockquote>
<ul>
<li><a
href="https://bulbapedia.bulbagarden.net/wiki/Battle_Pyramid">战斗金字塔有什么</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wYXN0ZWJpbi5jb20vdS9NZXRhcmtyYWk=">Metarkrai 的 Pastebin
hub<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wYXN0ZWJpbi5jb20vWWFaYU1RNEc=">Metarkrai 关于榴石果漏洞的
Pastebin<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wYXN0ZWJpbi5jb20vUjVwcFI5MXg=">Metarkrai
关于战斗金字塔刷闪的 Pastebin<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9fWTZnZmMzeEJ2Yw==">Metarkrai
的战斗金字塔刷闪视频<i class="fa fa-external-link-alt"></i></span>（强烈推荐，尽管仅作参考）</li>
</ul>
<blockquote>
<p>译者注：第一个链接可以参考神百的对战金字塔词条.</p>
</blockquote>
<p>在这里十分感谢 <strong>Metarkrai M</strong> 和
<strong>Speed0373</strong>
——这篇教程背后的两位天才，后者也是位很棒的shiny hunter，请关注<a
href="https://www.youtube.com/user/IIDarkMII">他的YouTube</a></p>
<p><strong>【请注意】Double
Corruption可能会不经意间导致一些问题，我建议尝试任何事情前备份好你的存档！</strong></p>
<blockquote>
<p>译者注：这个漏洞会产生大量坏蛋，暂时还没有很好的清除坏蛋的方法，请自行斟酌.
<br> 此外，由于每个人接受程度不同，文章中出现了如使用各类漏洞，<br>
或是借助烧录卡备份存档等做法，请根据自身情况来决定. <br>
又注：可能绿宝石对战塔的复制bug可以覆盖坏蛋，有待测试</p>
</blockquote>
<p><br></p>
<h2 id="前期准备">前期准备</h2>
<p>在尝试这个漏洞并进行战斗金字塔挑战时，我在每一轮之前进行了多次存档备份，并且将这些备份存档上传到了我的Google
Dive（谷歌云盘）.
因此，如果你不想做这些准备工作，只想刷闪，我十分欢迎你下载我的存档并导入到自己的卡带里进行游戏，当然，这会使你之后刷的闪光宝可梦不是自id.
但如果你想要在之后的场次中刷闪，这会帮你节省下两周左右的准备时间.
如果你使用了这些存档，你可以直接跳到本攻略的 <strong>Step
6：G</strong>.</p>
<p>尽管我正在寻找特定的场次，但我计划上传所有场次的存档.</p>
<blockquote>
<p>译者注：截止至翻译时，作者已上传了18轮的存档，虽然作者分享了自己的存档，<br>
但我个人还是不建议使用他人的存档刷闪. 当然，这看个人的想法，因人而异<br>
作者的谷歌云盘：<a
href="https://drive.google.com/drive/folders/15RNkGdAzbalwlzwijt1E8SnnMX9lHM8i?usp=sharing"
class="uri">https://drive.google.com/drive/folders/15RNkGdAzbalwlzwijt1E8SnnMX9lHM8i?usp=sharing</a></p>
</blockquote>
<p><br></p>
<h3 id="一些准备">一些准备</h3>
<ol type="1">
<li>需要的道具：
<ul>
<li>大师球x4+</li>
<li>烟雾球</li>
<li>榴石果 x2 <img data-src="/images/body/Battle-Pyramid-Shiny/Figure1.png"
alt="Figure1" /></li>
<li>大量喷雾</li>
<li>营养饮料（HP增强剂、攻击增强剂等） <img
src="/images/body/Battle-Pyramid-Shiny/Figure2.png"
alt="Figure2" /></li>
<li>强制锻炼器（竞争背心） <img
src="/images/body/Battle-Pyramid-Shiny/Figure3.png"
alt="Figure3" /></li>
<li>白色玻璃哨</li>
<li>至少500零花钱</li>
</ul></li>
<li>推荐的道具：
<ul>
<li>向尾喵的尾巴（只是防止你忘记续喷雾）</li>
<li>放进你金字塔包包里的额外的精灵球</li>
<li>讲究围巾 /
讲究头带和剩饭——让你通过金字塔更容易一些，尽管这些可以在金字塔里捡到</li>
</ul></li>
</ol>
<blockquote>
<p>译者注：讲究围巾首次出现于第四世代，可能原作者弄错了.</p>
</blockquote>
<ol start="3" type="1">
<li>需要的宝可梦：
<ul>
<li>游戏内与npc交换的橡实果</li>
<li>游戏内与npc交换的正点拍拍</li>
<li>会甜甜香气的宝可梦（10号道路的走路草自带甜甜香气）</li>
<li>同行的队伍来实现榴石果漏洞</li>
<li>一只濒死的宝可梦</li>
</ul></li>
</ol>
<p><br></p>
<h3 id="确定目标">确定目标</h3>
<p>战斗金字塔有很多不错的刷闪目标使得这个漏洞有了他的价值，下面的两个链接包含了每轮可以遇到的野生宝可梦种类与概率.
我把两个链接都列出来了，因为尽管Smogon更详细，但Bulbapedia（种子百科）更加直观，我建议两个结合起来看.</p>
<ul>
<li><a
href="https://bulbapedia.bulbagarden.net/wiki/List_of_wild_Pok%C3%A9mon_in_the_Battle_Pyramid"
class="uri">https://bulbapedia.bulbagarden.net/wiki/List_of_wild_Pok%C3%A9mon_in_the_Battle_Pyramid</a><br></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc21vZ29uLmNvbS9pbmdhbWUvYnQvYmF0dGxlX3B5cmFtaWQ=">https://www.smogon.com/ingame/bt/battle_pyramid<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><br></p>
<h3 id="比较强力的队伍">比较强力的队伍</h3>
<p>这在漏洞实现前后都可以进行准备.
尽管你将会把烟雾球、讲究围巾等道具放入你的对战金字塔包包里，我仍然建议考虑组建一个强有力的队伍，特别是你还要游玩之后的场次的话.
我的队伍如下：</p>
<ul>
<li>巨金怪（固执；252 物攻，252 速度，4 HP） <img
src="/images/body/Battle-Pyramid-Shiny/PM1.png" alt="PM1" />
<ul>
<li>燕返</li>
<li>大爆炸</li>
<li>彗星拳</li>
<li>地震</li>
</ul></li>
<li>赫拉克罗斯（怕寂寞；252 物攻，252 速度，4 HP） <img
src="/images/body/Battle-Pyramid-Shiny/PM2.png" alt="PM2" />
<ul>
<li>劈瓦</li>
<li>超级角击</li>
<li>地震</li>
<li>岩石封锁 / 岩崩（场次 4+）</li>
</ul></li>
<li>拉帝亚斯（悠闲；252 特攻，252 HP，4 物防） <img
src="/images/body/Battle-Pyramid-Shiny/PM3.png" alt="PM3" />
<ul>
<li>冥想</li>
<li>精神强念</li>
<li>冲浪</li>
<li>自我再生 / 十万伏特（场次 6+）</li>
</ul></li>
</ul>
<p>这里的个体并没有最优（比如巨金怪和赫拉克罗斯的速度很拉胯），但我在不作弊的情况下尽可能的让个体最大化（比如巨金怪和赫拉克罗斯有非常好的物攻个体）.</p>
<p>如果你不想花时间来组建一个强有力的队伍，你可以随意导入我的存档并将这些宝可梦传入你的存档.</p>
<p>如果你想要组建一个自己的强有力的队伍但不知道从何下手，请看下面的链接，里面有一些关于战斗金字塔的攻略：
<a
href="https://www.smogon.com/forums/threads/emerald-battle-pyramid-rmt.3488817/"
class="uri">https://www.smogon.com/forums/threads/emerald-battle-pyramid-rmt.3488817/</a><br>
<a
href="https://gamefaqs.gamespot.com/boards/921905-pokemon-emerald-version/52746591"
class="uri">https://gamefaqs.gamespot.com/boards/921905-pokemon-emerald-version/52746591</a><br>
<a
href="https://www.reddit.com/r/pokemon/comments/68t0uf/i_finally_got_all_7_gold_symbols_in_the_emerald/"
class="uri">https://www.reddit.com/r/pokemon/comments/68t0uf/i_finally_got_all_7_gold_symbols_in_the_emerald/</a><br>
<a
href="https://www.reddit.com/r/pokemon/comments/30npi5/emerald_battle_frontier_team/"
class="uri">https://www.reddit.com/r/pokemon/comments/30npi5/emerald_battle_frontier_team/</a><br>
<a
href="https://www.reddit.com/r/pokemon/comments/48mntm/pok%C3%A9mon_emerald_battle_frontier_guide_how_to_get/"
class="uri">https://www.reddit.com/r/pokemon/comments/48mntm/pok%C3%A9mon_emerald_battle_frontier_guide_how_to_get/</a></p>
<p><br></p>
<h3 id="烧录卡">烧录卡</h3>
<p>烧录卡确实是有些争议的，但如果你仅仅用其备份/导入你的存档的话，我不认为这有什么.
你需要一张烧录卡，一个SD卡读卡器，一台电脑和一台 Nintendo DS（Lite
或者初代饭盒）. 关于如何备份你的存档可以参见视频：<a
href="https://youtu.be/fWCDzpzAhsk"
class="uri">https://youtu.be/fWCDzpzAhsk</a>.</p>
<blockquote>
<p>译者注：贴吧等也有很多教程教你如何备份存档，活用搜索引擎.</p>
</blockquote>
<p><br></p>
<h2 id="step-1利用榴石果漏洞">Step 1：利用榴石果漏洞</h2>
<p>我不打算详细介绍这一步骤，因为Metarkrai找到了这个问题的关键点，而且比我能解释得更好（当然这个漏洞已经很出名了）.
如果你想要达成双重崩溃的话，我接下来讲的一些点你必须要做到.</p>
<p><br></p>
<h3 id="正电拍拍和橡实果的要求">正电拍拍和橡实果的要求：</h3>
<figure>
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure4.png"
alt="Figure4" />
<figcaption aria-hidden="true">Figure4</figcaption>
</figure>
<p>茵郁市与NPC交换来的正电拍拍： - 需要6个 - 只习得技能叫声 -
没有打努力/只打了很少的努力</p>
<p>卡那兹市与NPC交换来的橡实果： - 需要6只 -
习得四个技能，其中最后一个技能基于你的游戏语言： 闪光（美版或德版）/
无（法版）（原文是---，不确定是否是不带技能）/ 觉醒力量（西班牙版）/
自然之力（意大利版）/ 碎岩（日版） - 努力值基于你的游戏语言：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">语言</th>
<th style="text-align: center;">物攻努力值</th>
<th style="text-align: center;">HP努力值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">法版</td>
<td style="text-align: center;">41</td>
<td style="text-align: center;">200</td>
</tr>
<tr class="even">
<td style="text-align: center;">美版</td>
<td style="text-align: center;">41</td>
<td style="text-align: center;">192</td>
</tr>
<tr class="odd">
<td style="text-align: center;">西班牙版</td>
<td style="text-align: center;">148</td>
<td style="text-align: center;">140</td>
</tr>
<tr class="even">
<td style="text-align: center;">德版</td>
<td style="text-align: center;">41</td>
<td style="text-align: center;">201</td>
</tr>
<tr class="odd">
<td style="text-align: center;">日版</td>
<td style="text-align: center;">67</td>
<td style="text-align: center;">96</td>
</tr>
<tr class="even">
<td style="text-align: center;">意大利版</td>
<td style="text-align: center;">148</td>
<td style="text-align: center;">129</td>
</tr>
</tbody>
</table>
<blockquote>
<p>营养饮料 / 强制锻炼器 / 宝可病毒都可以帮助获得努力值</p>
</blockquote>
<p>这个漏洞在各个版本的绿宝石上都能触发，但我现在还不清楚欧版英文的所需要的努力值.
我猜测和美版是一样的，但是我不确定. 如果你知道更多信息，请<a
href="#结语">联系我</a>！</p>
<p><br></p>
<p>你需要一个正常蛋或好蛋（Good Egg, 下简称 GE），剩余的全是坏蛋（Bad
Egg, 下简称 BE）. 如果你找到了
GE，别碰它或移动它，这样你完成了第一步并可以保存了.
如果你没找到，重启游戏并重新操作直到你找到（如果你找到了复数个
GE，也需要重来）.</p>
<blockquote>
<p>译者补：作者没有将这一步具体步骤放出，请参阅以下补充的步骤.</p>
</blockquote>
<p><br></p>
<h3 id="榴石果漏洞译者补">榴石果漏洞（译者补）</h3>
<p>让有一定HP努力值的宝可梦的当前HP处于1点，再喂给该宝可梦一个榴石果（作用：降低HP努力提升亲密度），使其的HP下降两点以上，会使得该宝可梦的HP变成一个正常游戏中不可能出现的数字.</p>
<blockquote>
<p>举例来说，有一只80级的宝可梦有8点HP基础点数（努力值），HP是1/100.
对它使用榴石果后，它的HP基础点数变为0，实数值下降两点，这时它的HP变成了-1/98.
但因为游戏在这里使用的数据存储方式是无符号整数存储，HP会变成一个很大的数字，在这例子里就是65535，然后会显示为?35.</p>
</blockquote>
<p><br></p>
<h4 id="事先准备">事先准备</h4>
<p>一只级别足够高，有一些HP努力值的宝可梦，用以触发榴石果漏洞.
下面的叙述中简称A.</p>
<p>两箱子完全相同的某编号PM，以一定间隔置于1、2号两个箱子（作者使用了游戏中与npc交换得到的正电拍拍与橡实果，具体间隔参考上页图片）.
这样多数量的完全相同的宝可梦可以使用绿宝石战斗边疆的复制漏洞获得（当然也可以多开档传到同一张卡上）.
此外，箱子1、2中尽可能多地放入不重要的宝可梦，以提高GE出现率.
<strong>当然，箱子1、2中请不要放重要的宝可梦.</strong></p>
<p><br></p>
<h4 id="步骤">步骤</h4>
<ol type="1">
<li><p>将A置于队首，并控制它只剩1点HP.
带上若干只处于濒死状态的PM，最后再带上一只B. <img
src="/images/body/Battle-Pyramid-Shiny/Figure5.png"
alt="Figure5" /></p></li>
<li><p>喂给A一个榴石果(Pomeg Berry)，触发漏洞. <img
src="/images/body/Battle-Pyramid-Shiny/Figure6.png" alt="Figure6" />
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure7.png"
alt="Figure7" /> <img
src="/images/body/Battle-Pyramid-Shiny/Figure8.png"
alt="Figure8" /></p></li>
<li><p>触发与野生宝可梦的战斗，由A交换到B，然后逃跑.
（为了顺利逃跑，建议在PM等级较低的地方进行本步骤） <img
src="/images/body/Battle-Pyramid-Shiny/Figure9.png" alt="Figure9" />
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure10.png"
alt="Figure10" /> <img
src="/images/body/Battle-Pyramid-Shiny/Figure11.png"
alt="Figure11" /></p></li>
<li><p>将B存回电脑的任意一个箱子.</p></li>
<li><p>对A使用任意能够回复HP的道具，以高级伤药(Hyper Potion)为例. <img
src="/images/body/Battle-Pyramid-Shiny/Figure12.png" alt="Figure12" />
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure13.png"
alt="Figure13" /></p></li>
<li><p>再次去野外触发遇敌. <img
src="/images/body/Battle-Pyramid-Shiny/Figure14.png"
alt="Figure14" /></p></li>
<li><p>打开宝可梦菜单，查看A的状态.</p>
<p><img data-src="/images/body/Battle-Pyramid-Shiny/Figure15.png"
alt="Figure15" /> <img
src="/images/body/Battle-Pyramid-Shiny/Figure16.png"
alt="Figure16" /></p>
<blockquote>
<p>译者注：这里测试时使用的宝可梦是非法的，请不要在意</p>
</blockquote></li>
<li><p>按下方向键，直到光标正好指到“取消”（CANCEL）选项.
然后按住上方向键，直到出现下图所示的情形.
然后选择<strong>逃跑</strong>来退出战斗. <img
src="/images/body/Battle-Pyramid-Shiny/Figure17.png" alt="Figure17" />
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure18.png"
alt="Figure18" /> <img
src="/images/body/Battle-Pyramid-Shiny/Figure19.png"
alt="Figure19" /></p></li>
<li><p>如果足够幸运，你可以在1，2号箱子里的众多BE中找到一个GE，如果不够幸运，请读档重新尝试.
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure20.png"
alt="Figure20" /></p></li>
</ol>
<p><br></p>
<h3
id="绿宝石战斗边疆的复制漏洞译者补">绿宝石战斗边疆的复制漏洞（译者补）</h3>
<ol type="1">
<li>来到对战开拓区的对战塔.</li>
<li>来到电脑旁边，带上至少一只宝可梦并在电脑前存档.</li>
<li>取出要复制的宝可梦
<strong>（切忌把存档前身上带的PM换到电脑里，否则复制后那只被存到电脑里的宝可梦就会永久消失）</strong>，不要保存.</li>
<li>来到最右边的服务员前对话（实机会注意到一个明显的停顿），和她说话会有3次机会选是或否，在第三次选是否前关机或者SL.
再打开你就会发现电脑里和身上都有你想要复制的那只宝可梦.</li>
</ol>
<blockquote>
<p>注意：所有类似的柜台只有对战塔的柜台有此漏洞.</p>
</blockquote>
<p><br></p>
<h2 id="step-2二次崩溃double-corruption">Step 2：二次崩溃（Double
Corruption）</h2>
<p>a）一旦你获得了一个
GE，将这个箱子清空，留下GE和一个正电拍拍（记住！别碰
GE）坏蛋和剩下的宝可梦可以放到除了箱子1和箱子2以外的任何箱子.</p>
<p>b）将留下的那只正电拍拍放在正常的蛋 / 好蛋的左侧，并退出箱子.</p>
<figure>
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure21.png"
alt="Figure21" />
<figcaption aria-hidden="true">Figure21</figcaption>
</figure>
<p>c）保存.</p>
<p>d）再重复一遍榴石果漏洞——完全相同的方法（这会需要比第一次更多的时间，因为箱子里只有一只宝可梦来崩溃）.</p>
<p>e）最后，完成榴石果漏洞，查看PC，你会看到下面的图：</p>
<figure>
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure22.png"
alt="Figure22" />
<figcaption aria-hidden="true">Figure22</figcaption>
</figure>
<p>【这是一个在日版上成功的例子，性别与等级会根据你所玩的游戏的语言而不同】</p>
<p><img data-src="/images/body/Battle-Pyramid-Shiny/Figure23.png"
alt="Figure23" /> <img
src="/images/body/Battle-Pyramid-Shiny/Figure24.png" alt="Figure24" />
【两个失败的例子——你需要得到成功例子中的那个问号（Question Mark, 下简称
QM）——SL重来吧】</p>
<p>f）千万别拿起GE或者QM！</p>
<p>g）QM可以让你在任何地方触发及时榴石果漏洞（Instant Pomeg Glitch,
IPG），这就是我们所要的.</p>
<p>h）保存.</p>
<blockquote>
<p>译者注：经过测试，QM不能通过联机传给另外的存档，会导致另外一台游戏重启/卡死.</p>
</blockquote>
<p><br></p>
<h2 id="step-3去凯那市做好准备">Step 3：去凯那市做好准备</h2>
<p>a）按下SELECT键将PC盒子里的小手手切换成橙色（用来移动宝可梦）.</p>
<p>b）这能让你移动QM和GE
——<strong>记住只用橙色的小手手移动QM！否则你的游戏会卡住！</strong></p>
<figure>
<img data-src="/images/body/Battle-Pyramid-Shiny/Hand.png" alt="Hand" />
<figcaption aria-hidden="true">Hand</figcaption>
</figure>
<p>c）将QM和GE移到箱子1、箱子2以外的箱子里——拿起QM的方法：将橙色的手置于QM的右侧，按住A移向QM【翻译存疑，测试时发现正常拿起即可】.
如果你搞糟了或者盒子变得怪怪的，退出箱子重来一遍，这问题不大.</p>
<p>d）如果你拿起了看不到的东西，别怕 ，那是隐形的BE，而且很有用.
把它们放到你能记得住的地方.</p>
<p>e）我建议花点时间利用对战开拓区的复制漏洞多复制几个QM，因为它真的蛮有用.</p>
<p>f）这些做完后，飞去凯那市，然后去电脑前.</p>
<p>g）保存.</p>
<p>h）把QM拿出来放到队伍首位</p>
<p>i）把另外一只宝可梦拿出来放到队伍第二个位置
——<strong>你会失去它，所以斟酌选择哪只宝可梦.</strong></p>
<figure>
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure25.png"
alt="Figure25" />
<figcaption aria-hidden="true">Figure25</figcaption>
</figure>
<p>j）去宝可梦发烧友俱乐部找到记者</p>
<p><img data-src="/images/body/Battle-Pyramid-Shiny/Figure26.png"
alt="Figure26" /> <img
src="/images/body/Battle-Pyramid-Shiny/Figure27.png"
alt="Figure27" /></p>
<p>k）与她对话，然后QM会叮～【译者：?】</p>
<p>l）尽可能快地脱离对话，检查你的同行宝可梦，应该会像这样：</p>
<p><img data-src="/images/body/Battle-Pyramid-Shiny/Figure28.png"
alt="Figure28" /> <img
src="/images/body/Battle-Pyramid-Shiny/Figure29.png"
alt="Figure29" /></p>
<p>【重要：这里的显示会根据你游玩游戏的语言而不同.
日版游戏中，第二只宝可梦仍然存在，如左手边的图片.
其他版本则会显示为一个BE，如右手边的图片. 只要首位是空的，那就没问题.
】</p>
<p>m）如果不像这样，SL重试叭.</p>
<p>n）如果像这样，<strong>千万别查看详情（SUMMARY），请退出菜单</strong>.</p>
<p>o）从这里走到凯那市港口（译者注：原文是库斯诺吉造船厂）然后坐船去水静市.</p>
<p>p）到达水静市后，使用喷雾并走去狩猎地带.</p>
<p>q）保存.</p>
<p><br></p>
<h2 id="step-4ipg-time">Step 4：IPG Time</h2>
<p>a）进入狩猎地带然后走大约13步（<strong>你要尽可能地节省步数</strong>，因为狩猎地带的时间是基于你的步数的）或者至少让门口的那个NPC（门卫）在视野外.</p>
<figure>
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure30.png"
alt="Figure30" />
<figcaption aria-hidden="true">Figure30</figcaption>
</figure>
<p>b）打开宝可梦菜单，按住上键15秒——这很重要，我建议准备一个计时器.</p>
<figure>
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure31.png"
alt="Figure31" />
<figcaption aria-hidden="true">Figure31</figcaption>
</figure>
<p>【你会看到你的屏幕颜色变了（主要是红色和蓝色），别担心，按住15秒就好】</p>
<p>c）这部分的漏洞每个人耗时会不同，我尝试了4次就成功了，但实际上概率是1/32～3/32，所以耐心一些.</p>
<p>d）如果门卫没消失，SL并从Step 4：a）开始.</p>
<p>e）如果他消失了，打开你的背包.
如果你的招式学习器和树果消失了，SL并从<strong>Step
4：a）</strong>开始</p>
<p>f）如果你的招式学习器和树果没消失，但门卫消失了，那么你成功了！</p>
<figure>
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure32.png"
alt="Figure32" />
<figcaption aria-hidden="true">Figure32</figcaption>
</figure>
<p>g）从门卫消失的门那里进入狩猎地带的大厅.</p>
<p>h）当你路过的时候，工作人员会问你是否要玩狩猎地带，选否.</p>
<p>i）这会使你仍处于狩猎模式.</p>
<p>j）使用喷雾，并走（<strong>不准飞！</strong>）回水静市
——<strong>注意你的步数！</strong></p>
<figure>
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure33.png"
alt="Figure33" />
<figcaption aria-hidden="true">Figure33</figcaption>
</figure>
<p>k）坐船去对战开拓区.</p>
<p>l）走去战斗金字塔 ——<strong>再次强调，注意你的步数！</strong></p>
<figure>
<img data-src="/images/body/Battle-Pyramid-Shiny/Figure34.png"
alt="Figure34" />
<figcaption aria-hidden="true">Figure34</figcaption>
</figure>
<p>m）到达战斗金字塔后，取出三只宝可梦. 确保其中一只会甜甜香气.
（如果屏幕开始变得有些奇怪，而且你看到了漂浮着的蛋，无视这些，继续取出宝可梦）</p>
<p>n）进入战斗金字塔，选择50级或开放等级（选谁步骤都一样的），并选择刚刚取出的三只宝可梦.</p>
<p><br></p>
<h2 id="step-5该把道具骗进去了">Step 5：该把道具骗进去了</h2>
<p>a）当你打开菜单，应该会发现是狩猎地带的菜单.</p>
<p>b）如果你打开背包，你会发现是你平时的包包而不是战斗金字塔的包包，<strong>但别这么做，否则很有可能会卡死</strong>.</p>
<p>c）打开宝可梦菜单，选择“给予物品”，这会打开金字塔包包.</p>
<p>d）给两只不会甜甜香气的宝可梦随便两个金字塔包包里的物品.</p>
<p>e）然后使用甜甜香气碰三只宝可梦.</p>
<p>f）用狩猎球抓住这三只——这会填满你的队伍.</p>
<p>g）从菜单打开你平时的包包，并将第一个物品给你会甜甜香气的宝可梦.
然后你的其他五只宝可梦也是*——每次给完物品就选择关闭包包.</p>
<blockquote>
<p>作者注：如果你对此处有疑问，我推荐从<a
href="https://youtu.be/_Y6gfc3xBvc?t=1110">Metarkrai的视频</a>的18:30处开始看，这是法语视频但可以作为参考.
<br>
你如果正常按流程做下来，你的金字塔包包会有那些东西的，所以如果你有疑惑也不要紧.</p>
</blockquote>
<p>h）再给你的甜甜香气宝可梦一次物品. （应该是和c）一样的方法）</p>
<p>i）如果你尝试关闭背包，你会在金字塔包包和宝可梦菜单之间循环【？】</p>
<p>j）使用甜甜香气来跳出循环.</p>
<p>k）逃跑.</p>
<p>l）打开宝可梦菜单，将宝可梦身上的道具拿下来.</p>
<p>m）这会将物品放入你的金字塔包包.</p>
<p>n）重复上述步骤直至你把所有你想放进金字塔包包的东西都放进去.</p>
<p>o）不幸的是，你同种物品只能放入最多7个，再多的系统会自动移到原来的包包里.
（例如，你放了一轮7个大师球，你就不能再放了）</p>
<blockquote>
<p>译者注：Metarkrai对于这个原因的解释请参见原文</p>
</blockquote>
<p>p）结束前<strong>至少要放4个大师球</strong>进去.</p>
<p>我在前面列出了一些推荐放进去的物品，当然，你可以任意选择.
不过我不推荐放超过五种物品.
因为金字塔包包容量为10，而你之后还要通过金字塔，金字塔中的治疗物品又很重要.
所以留点空位叭.</p>
<p>q）当你对放进去的物品种类及数目满意之后，打开菜单选择“放弃”.</p>
<p>r）这会将你传送回狩猎地带.</p>
<p>s）走出去.</p>
<p>t）这时你金字塔包包里那些东西都在了，可以保存了.</p>
<p><br></p>
<h2 id="step-6开始刷闪">Step 6：开始刷闪！</h2>
<p>到这里你其实已经准备好了你的对战金字塔之旅. 不过注意以下几点：</p>
<ul>
<li>对战金字塔不同等级规则的包包是不同的，你放进50级规则就在50级规则的金字塔包包里，开放等级就在开放等级的金字塔包包里.</li>
<li>你每完成一轮就或者你选择休息，物品还会留在金字塔包包里.</li>
<li>你放弃或者输了，物品就会消失.</li>
<li>如果你玩的别的语言版本的游戏，记住<strong>在最后和向导说话前把你队伍中宝可梦身上的道具拿下来</strong>，否则你可能失去他们（我经常犯这个错误），然后不得不从第一轮重新来.</li>
</ul>
<p>这里我强烈推荐使用烧录卡备份存档.
当你在金字塔中输了，你不仅会失去你的物品，你还会丢失进度从第一轮重新开始.
尽管当你不用烧录卡到达了你想要刷闪的轮次，你仍要保持你的DS /
Gameboy一直开着.
因为就算你选择了休息（REST）能够保存当前进度和包包内物品，但你在一开始捕捉的三只宝可梦会丢失（下面会解释）.
如果你再用大师球抓新的宝可梦，大师球最终会用完，导致你的队伍不是满员.
这使得之前的准备毫无意义.
烧录卡还可以使得你能在每一轮结束备份你的存档，如果你输了，可以直接导回之前的存档，而不是从第一轮重新开始.
而且，你可以在你想要刷闪的轮次存档（在金字塔中途也可以备份存档），使得你不必每次都要从开始准备道具.</p>
<p>a）回到战斗金字塔并取出你要带的宝可梦.</p>
<p>b）选择之前你做了准备的等级规则（50级与开放等级）.</p>
<p>c）进去后你会发现你之前放进去的道具都在.</p>
<p>d）给你的首位宝可梦带上烟珠，其他宝可梦带上别的有用的道具.</p>
<p>e）一直玩到你想要刷闪的轮次.</p>
<p>f）备份存档. （如果你没有烧录卡或者不愿意，无视这一步）</p>
<p>g）进入你要刷闪的轮次.</p>
<p>h）选择“休息”（REST）并备份存档. （再一次，可以无视这一步）</p>
<p>i）先抓三只宝可梦——这会填满你的队伍，这样你之后抓的宝可梦都会被送去PC而不是同行.
<strong>注意，当你完成一轮 / 中途输掉 / 放弃 / 休息
都会使之后捕捉的三只宝可梦消失.</strong></p>
<p>j）注意，每当你开始刷闪，你都要导回存档重新抓三只宝可梦，这有点难受，但如果你有烧录卡备份存档的话就无所谓了.
记住要保存！如果向导强制你保存，这不会保存你后来捉到并传到箱子里的宝可梦！所以请手动存档，这样你的箱子里新的宝可梦才会被保存.</p>
<p><br></p>
<h2 id="结语">结语</h2>
<p>如果你需要任何帮助，我强烈推荐你看看Metarkrai的Pastebins和视频，因为里面会有所有你需要的信息.
不过需要的话，我也很乐意帮忙.
如果你发现了任何错误，请通过我的推特或者YouTube联系我！十分感谢！
YouTube：<span class="exturl" data-url="aHR0cHM6Ly95b3V0dWJlLmNvbS9jL29saWcx">https://youtube.com/c/olig1<i class="fa fa-external-link-alt"></i></span> 推特：<a
href="https://twitter.com/olig405"
class="uri">https://twitter.com/olig405</a></p>
<blockquote>
<p>译者注：也非常欢迎<a href="/about/">与我联系</a></p>
</blockquote>
<p><img data-src="/images/body/Battle-Pyramid-Shiny/Tail.png" /></p>
]]></content>
      <categories>
        <category>Pokemon</category>
      </categories>
      <tags>
        <tag>Pokemon</tag>
        <tag>Pomeg Glitch</tag>
        <tag>Double Corruption</tag>
      </tags>
  </entry>
  <entry>
    <title>宝可梦火红叶绿实机乱数（不包含 ID 或 Egg）</title>
    <url>/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part3/</url>
    <content><![CDATA[<p>这是宝可梦火红叶绿的实机乱数教程. 不包含 ID 与 Egg 的乱数教程.
如有纰漏，请<a href="/about/">与我联系</a>，万分感谢！</p>
<p>封面 [ID:94783450].</p>
<span id="more"></span>
<p><strong>注意，本教程仅支持：火红叶绿.</strong></p>
<p>如果你在找有电的红蓝宝石实机乱数教程，请点击<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part2/">这里</a>.
如果你在找绿宝石及没电红蓝宝石的红蓝宝石实机乱数教程，请点击<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part1/">这里</a>.</p>
<blockquote>
<p>成果展示: <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part3/Result.png"
alt="Result" /></p>
</blockquote>
<h1 id="准备工作">准备工作</h1>
<p>在开始之前，你要知道火叶乱数的难度很高，可能会花费你大几小时的时间.
请自行斟酌.</p>
<p>如果你想要乱数闪光宝可梦，你需要知道你的<a
href="https://wiki.52poke.com/wiki/ID_No.#.E9.87.8CID_No.">SID</a>.</p>
<blockquote>
<p>如果你想要乱数的是已经创建好的存档，这可能会需要你导出存档并使用
<em>PKHex</em>
等软件查看你的存档（不涉及修改与导入），请根据自身接受程度使用.（本教程默认读者使用<em>NDS</em>烧录卡进行存档提取来方便查看个体）</p>
</blockquote>
<blockquote>
<p>由于我没有怎么研究过乱数ID，所以如果你想要乱数ID，请参考：<a
href="https://www.smogon.com/ingame/rng/rs_nonbredrng#idsid">Smogon ID
乱数教程</a>.<br> 之后如果自己研究了一遍就会上传Blog.</p>
</blockquote>
<blockquote>
<p>不会导出存档？看看这篇博客：<a
href="/Pokemon/Strategies/In-Game/How-To-Back-Up-Your-Savefiles/">如何备份你的存档</a>.</p>
</blockquote>
<h2 id="硬件准备">硬件准备</h2>
<ul>
<li>能够游玩第三世代宝可梦卡带的<em>NDS</em>系列机器（初代 <em>NDS</em>
或 <em>NDS lite</em>，以下统称 <em>NDS</em>）.</li>
<li>电脑.</li>
<li><em>NDS</em>烧录卡与读卡器.</li>
</ul>
<blockquote>
<p>本教程默认读者使用<em>NDS</em>烧录卡进行存档提取来方便查看个体，如若抗拒，请参考
<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part1/">宝可梦绿宝石及没有电的红蓝宝石实机乱数（不包含
ID 或 Egg）</a> 中提及的方法（使用神奇糖果）.</p>
</blockquote>
<h2 id="下载乱数所需工具">下载乱数所需工具：</h2>
<ul>
<li>计时器<a
href="https://github.com/dylmeadows/EonTimer/releases">EonTimer</a>
如果因为国内 GitHub 下载速度原因不好下载，可以点击<a
href="/download/EonTimer.rar">这里</a>进行下载.</li>
<li>乱数工具<a
href="https://www.dropbox.com/sh/68qqg26op3uaymc/AAC8QFFKYxAqQjG80abgcHZ1a?dl=0">3genSearch</a>
国内需要科学上网，因原作者禁止二次发布所以这里不提供直接下载，可以通过各搜索引擎找到别人的分享.</li>
<li>乱数工具<a
href="https://github.com/Admiral-Fish/RNGReporter/releases">RNGReporter</a>
如果因为国内 GitHub 下载速度原因不好下载，可以点击<a
href="/download/RNGReporter.zip">这里</a>进行下载.</li>
<li>存档编辑软件<a
href="https://github.com/kwsch/PKHeX/releases">PKHex</a>
将使用其查看宝可梦的个体，不会涉及到存档修改. 如果因为国内 GitHub
下载速度原因不好下载，可以点击<a
href="/download/PKHeX(190705).zip">这里</a>进行下载（版本：19.07.05）.</li>
<li>seed查找工具<a
href="https://www.smogon.com/forums/threads/rng-manipulation-in-firered-leafgreen-wild-pok%C3%A9mon-supported-in-rng-reporter-9-93.62357/">FRLGSeedFinder</a>
如果选用3genSearch可以不用此工具. 也可以点击<a
href="/download/FRLGSeedFinder.zip">这里</a>进行下载.</li>
</ul>
<blockquote>
<p>两个乱数工具选择任意一个都可以，本教程使用的是 <em>RNGReporter</em>.
3genSearch的使用与之类似，还请读者自行探索.</p>
</blockquote>
<h2 id="了解乱数机制">了解乱数机制</h2>
<p>请参考<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part1/#了解乱数机制">宝可梦绿宝石及没有电的红蓝宝石实机乱数（不包含
ID 或 Egg）</a> 中的相应部分. 这里不同的是，火红叶绿（以下简称
<strong><em>FRLG</em></strong>）的初始 seed
极难控制，它根据进入游戏到标题画面出现 <em>PRESS START</em>
的那段时间有三次按键判定，然后根据时间、按键等因素决定初始 seed
组，最后从中选择一个初始 seed（可能有些偏差，但大体上是这个意思）.
我们需要通过等待（不进行按键操作）至游戏自动到达 <em>PRESS START</em>
界面后再按键操作，这样会跳过前两次按键判定，使得我们更容易控制初始 seed.
此外，当你在 <em>PRESS START</em> 界面按下按键 <strong>A</strong> 或
<strong>START</strong> 后，不仅初始 seed
决定了，游戏也将开始推进帧数.</p>
<h2 id="确定乱数目标">确定乱数目标</h2>
<p>请参考<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part1/#确定乱数目标">宝可梦绿宝石及没有电的红蓝宝石实机乱数（不包含
ID 或 Egg）</a> 中的相应部分. 这里我以 <em>Method 1</em>
的游戏厅宝可梦为例，甜甜香气等的 Method 没有测试，如果你测试了，还请<a
href="/about/">与我联系</a>，十分感谢.</p>
<h1 id="开始乱数">开始乱数</h1>
<h2
id="确定初始seed组并选择备用初始seed">确定初始seed组并选择备用初始seed</h2>
<ol type="1">
<li>打开 <em>EonTimer</em>
，点击红色框来选择第三世代，在蓝色框中填入游戏等待时间.
（大于等于35000，1000每秒. 即如果填入37000，计时器会在第37秒归零.
不建议过长，游戏会自动重启.） 其他部分不需要修改. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part3/Figure1.png"
alt="Figure1" /></li>
<li>点击 <strong><em>Start</em></strong>
按钮的同时开始游戏(gba系列和设置过的nds是直接开机，未设置过的nds系列是在主页面点击GBA游戏图标).</li>
<li>在倒计时归 0 的同时按下 <strong>A</strong> 或 <strong>START</strong>
键. （这时应该进入 游戏选择存档进入界面）</li>
<li>进入游戏，任意获得一只宝可梦后存档并关机（越快越好），这里建议在游戏厅内兑换凯西.</li>
<li>重复步骤2~4，重复的次数建议在30次左右.</li>
<li>使用 NDS烧录卡 提取游戏存档后使用 PKHex 打开.</li>
<li>选择一只你获得的宝可梦，右击选择 <em>查看</em> 并选择左侧选项卡的
<em>数值</em>. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part3/Figure2.png"
alt="Figure2" /></li>
<li>打开乱数工具<em>RNGReport</em>，选择顶部 <strong>4th Gen
Tools</strong> 菜单栏，选择第一项 <em>Calculate PID from IVs</em>.</li>
<li>输入个体性格与你的ID，点击<em>Find</em>，选择<strong>PID</strong>对应的一栏.
<img data-src="/images/body/Pokemon-RNG-Abuse-Gen3-Part3/Figure3.png"
alt="Figure3" /></li>
<li>将得到的seed输入工具<em>FRLGSeedFinder</em>中，得到初始seed（4位16进制数）.
<img data-src="/images/body/Pokemon-RNG-Abuse-Gen3-Part3/Figure4.png"
alt="Figure4" /></li>
<li>将得到的seed记录下来.</li>
<li>重复步骤7~11，直到获取所有你在步骤5中得到的宝可梦的初始seed.</li>
<li>这样你就得到了步骤1中确定的游戏等待时间所对应的初始seed组.</li>
<li>从中选择出现频率最高的几个初始seed作为备用初始 seed.
（如果第n高与第n+1高的seed出现频率差别较大，那么就选择到第n个）</li>
</ol>
<blockquote>
<p>我在测试时记录的草稿，见<a href="#Appendix">附录</a>.</p>
</blockquote>
<h2 id="搜索目标宝可梦">搜索目标宝可梦</h2>
<p>回到乱数工具首页，选择/填入图中红框中内容： <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part3/Figure5.png"
alt="Figure5" /></p>
<ol type="1">
<li><p><em>Method</em> 选择之前确定的 <em>Method</em>.</p></li>
<li><p>根据你想要的宝可梦个体、性格、性别等填入信息，如果想要闪光请填入你的
<strong>ID</strong> 与 <strong>SID</strong>，并勾选 <em>Shiny Only</em>.
如果你使用甜甜香气，你还需要选择 <em>Encounter Slot</em>
项，点击顶部菜单项 <strong>3th Gen Tools</strong> 选择对应游戏版本的
<em>Encounter Table</em>，来查看你想要的宝可梦属于什么 <em>Encounter
Slot</em>.（可能需要科学上网） 你也可以借助 <em>3genSearch</em>
工具来查看.</p></li>
<li><p>输入之前得到的初期 seed.</p></li>
<li><p><em>Start Frame</em>为开始帧，<em>Max
Results</em>为显示的结果数，即你的搜索范围是<em>Start Frame</em> ~
<em>Start Frame</em> + <em>Max
Results</em>.（强烈建议选择两分钟以内的，即7200帧以内）</p></li>
<li><p>点击<em>Generate</em>，得到结果.</p></li>
<li><p>重复步骤1~5，将所有备用初始 seed 全部检索完后选择最合适的 seed 与
Frame 作为目标初始 seed 与目标帧.（这里以 seed: AAA2，Frame:
1499为例）</p></li>
<li><p>注意，<em>RNGReporter</em>的起始Frame与<em>FRLGSeedFinder</em>不同，请-1后当作结果（即这里目标帧不是1499，而是1498）</p>
<blockquote>
<p>没有想要的宝可梦或者闪帧太靠后了怎么办？<br> 回到 <a
href="#确定初始seed组并选择备用初始seed">确定初始seed组并选择备用初始seed</a>步骤，并在第一步选择一个不同的游戏等待时间（或者赌一下初始
seed 组中备用初始 seed 以外的 seed）.</p>
</blockquote></li>
<li><p>将目标帧填入 <em>EonTimer</em> 中的 <strong>Target Frame</strong>
栏.</p></li>
</ol>
<h2 id="校准误差">校准误差</h2>
<p><strong><em>如果你的目标宝可梦不是野外宝可梦（如定点宝可梦），那么要在步骤1结束后，将存档备份</em></strong></p>
<ol type="1">
<li><p>在游戏中你应该存档的位置存档（如果你准备在洞穴或是能出现宝可梦的建筑中使用甜甜香气，请往深处走一些距离，否则甜甜香气可能会失效），存档完成后关机.</p></li>
<li><p>点击计时器 <strong><em>Start</em></strong>
按钮的同时开始游戏(设置过的nds是直接开机，未设置过的nds系列是在主页面点击GBA游戏图标).</p></li>
<li><p>在计时器的第一次倒计时归零的瞬间按下机器的
<strong><em>A</em></strong> 或 <strong><em>Start</em></strong>
键，然后快速到达目标帧的确定位置（如：在选择宝可梦使用甜甜香气的界面）.</p></li>
<li><p>在计时器的第二次倒计时归零的瞬间按下机器的
<strong><em>A</em></strong>
键，然后等待进入战斗界面后捕捉这只宝可梦，保存并关闭游戏.
（游戏厅等是直接获取）</p></li>
<li><p>执行<a
href="#确定初始seed组并选择备用初始seed">确定初始seed组并选择备用初始seed</a>中的步骤6~10，你在得到的
seed 前还会得到该 seed 前的一串数字，那是你击中的帧数，记为
<em>击中帧</em>.
（如果seed不是你的初始seed也没关系，这很正常，我们这一步只为了校准误差）</p></li>
<li><p>回到计时器，计算<em>目标帧</em>减去<em>击中帧</em>的值，将其加上<em>目标帧</em>的值得到新的目标帧，将其替换计时器的
<strong>Target Frame</strong> 栏.</p>
<blockquote>
<p>例如 目标帧 是1498，击中帧是1398，1498 - 1398 = 100，那么将 Target
Frame 中的值更新为 1498 + 100 = 1598.</p>
</blockquote></li>
</ol>
<p>误差校准完成.</p>
<blockquote>
<p>注意，如果你更换了目标，即目标帧有较大变动或者宝可梦获得方式改变（如Method不同
或 由游戏厅切换为卡比兽），请重新进行误差校准！</p>
</blockquote>
<h2 id="乱数">乱数</h2>
<p><strong><em>如果你的目标宝可梦不是野外宝可梦（如定点宝可梦），那么要先将备份存档恢复</em></strong>
和校准误差的3、4步类似： 1. 在计时器的第一次倒计时归零的瞬间按下机器的
<strong><em>A</em></strong> 或 <strong><em>Start</em></strong>
键，然后快速到达目标帧的确定位置（如：在选择宝可梦使用甜甜香气的界面）.
2. 在计时器的第二次倒计时归零的瞬间按下机器的
<strong><em>A</em></strong>
键，然后等待进入战斗界面（游戏厅等是直接获取）. 3.
如果得到的不是<em>目标帧</em>，不要保存，关闭游戏重复步骤1~2. 4.
尝试较多次数仍失败的话，可以选择再次进行误差校准.</p>
<blockquote>
<p>因为手工操作的误差与火叶机制的特殊性，建议尝试大几十次，再考虑重新校准误差.</p>
</blockquote>
<ol start="5" type="1">
<li>乱数成功，得到目标！</li>
</ol>
<h1 id="写在后面">写在后面</h1>
<ul>
<li><p>还有一种比较麻烦的方法，在这里描述一下，十分费时费力，就不展开说了：</p>
<ul>
<li>准备大量的神奇糖果.</li>
<li>使用玩家自制的软件 <a
href="https://www.smogon.com/forums/threads/fr-lg-rng-timer.3554964/">FR/LG
RNG Timer</a>. 也可以点击<a
href="/download/FRLG_RNG_Timer.jar">这里</a>进行下载.</li>
<li>进入游戏的同时开始计时器.</li>
<li>捕捉一只宝可梦并通过糖果确定个体.</li>
<li>使用个体查出初始seed.</li>
<li>查找该seed下满意的宝可梦，将目标帧数输入 FR/LG RNG Timer 点击
Submit.</li>
<li>游戏推进到等待生成帧.</li>
<li>倒计时结束触发生成帧.</li>
<li>捕捉并通过糖果确认个体.</li>
<li>利用个体查找击中帧数，记录校准值.</li>
<li>利用校准值再来一次.</li>
</ul></li>
</ul>
<p><strong><em>十分不建议使用这种方法，在FRLG中，经常出现跳过奇数帧或偶数帧的情况，触发条件暂时还未知（不操作不影响），所以这个方法极难成功.</em></strong></p>
<h1 id="reference">Reference</h1>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc21vZ29uLmNvbS9pbmdhbWUvcm5nLw==">Smogon RNG
教程<i class="fa fa-external-link-alt"></i></span></li>
<li><a
href="https://www.smogon.com/forums/threads/rng-manipulation-in-firered-leafgreen-wild-pok%C3%A9mon-supported-in-rng-reporter-9-93.62357/">RNG
Manipulation in FireRed/LeafGreen: Wild Pokémon Supported in RNG
Reporter 9.93</a></li>
<li><a
href="https://www.smogon.com/forums/threads/fr-lg-rng-timer.3554964/">Programming
- FR/LG RNG Timer</a></li>
</ul>
<h1 id="appendix">Appendix</h1>
<ul>
<li>Draft <img data-src="/images/body/Pokemon-RNG-Abuse-Gen3-Part3/Draft.png"
alt="Draft" /></li>
</ul>
]]></content>
      <categories>
        <category>Pokemon</category>
      </categories>
      <tags>
        <tag>Pokemon</tag>
        <tag>Pokemon-RNG-Abuse</tag>
        <tag>Pokemon-Gen3</tag>
      </tags>
  </entry>
  <entry>
    <title>willkyu的宝可梦计划</title>
    <url>/Pokemon/PokeSchedule/</url>
    <content><![CDATA[<p>使用 <em>CheckBox</em> 记录宝可梦各世代的目标以及完成情况.
你可以将这篇当作<strong>各版本要素整理</strong>.
如果还有什么有意思的要素欢迎<a href="/about/">与我联系</a>.</p>
<p>封面 [ID:94230956].</p>
<span id="more"></span>
<blockquote>
<p>未完成. 之后将细化正作部分与补充旁支部分.</p>
</blockquote>
<h1 id="总览">总览</h1>
<h2 id="第三世代">第三世代</h2>
<h3 id="宝可梦红宝石">宝可梦红宝石</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
喜欢的ID: 02233</li>
<li><input type="checkbox" disabled="" checked="" />
通关联盟</li>
<li><input type="checkbox" disabled="" checked="" />
50级对战塔50+连胜: 当前63，最高63</li>
<li><input type="checkbox" disabled="" />
100级对战塔50+连胜</li>
<li><input type="checkbox" disabled="" checked="" />
研究华丽大赛</li>
<li><input type="checkbox" disabled="" />
研究制作宝可方块</li>
<li><input type="checkbox" disabled="" />
盒子皮肤全收集</li>
<li><input type="checkbox" disabled="" />
完成丰缘图鉴</li>
<li><input type="checkbox" disabled="" />
完成全国图鉴</li>
<li><input type="checkbox" disabled="" />
装饰秘密基地</li>
<li><input type="checkbox" disabled="" />
满级训练师卡片</li>
<li><input type="checkbox" disabled="" />
游戏时间999:59</li>
</ul>
<hr />
<h3 id="宝可梦蓝宝石">宝可梦蓝宝石</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<h3 id="宝可梦火红">宝可梦火红</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<h3 id="宝可梦叶绿">宝可梦叶绿</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
喜欢的ID: 07411</li>
<li><input type="checkbox" disabled="" checked="" />
通关联盟</li>
<li><input type="checkbox" disabled="" />
给宝可梦拍照</li>
<li><input type="checkbox" disabled="" />
盒子皮肤全收集</li>
<li><input type="checkbox" disabled="" />
完成关都全图鉴</li>
<li><input type="checkbox" disabled="" />
完成全国图鉴</li>
<li><input type="checkbox" disabled="" />
游玩小游戏</li>
<li><input type="checkbox" disabled="" />
游玩训练家之塔</li>
<li><input type="checkbox" disabled="" />
满级训练师卡片</li>
<li><input type="checkbox" disabled="" />
游戏时间999:59</li>
</ul>
<hr />
<h3 id="宝可梦绿宝石">宝可梦绿宝石</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<hr />
<hr />
<h2 id="第四世代">第四世代</h2>
<h3 id="宝可梦珍珠">宝可梦珍珠</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<h3 id="宝可梦钻石">宝可梦钻石</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
喜欢的ID</li>
<li><input type="checkbox" disabled="" />
通关联盟</li>
<li><input type="checkbox" disabled="" />
研究华丽大赛</li>
<li><input type="checkbox" disabled="" />
研究连锁机制</li>
<li><input type="checkbox" disabled="" />
研究地下世界</li>
<li><input type="checkbox" disabled="" />
研究宝芬</li>
<li><input type="checkbox" disabled="" />
集齐饰品</li>
<li><input type="checkbox" disabled="" />
盒子皮肤全收集</li>
<li><input type="checkbox" disabled="" />
绘制签名，更换联机形象</li>
<li><input type="checkbox" disabled="" />
对战塔100+连胜</li>
<li><input type="checkbox" disabled="" />
完成神奥图鉴</li>
<li><input type="checkbox" disabled="" />
完成全国图鉴</li>
<li><input type="checkbox" disabled="" />
满级训练家卡片</li>
<li><input type="checkbox" disabled="" />
游戏时间999:59</li>
</ul>
<hr />
<h3 id="宝可梦白金">宝可梦白金</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<h3 id="宝可梦心金">宝可梦心金</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
喜欢的ID</li>
<li><input type="checkbox" disabled="" />
给宝可梦拍照（别忘了火箭队的衣服）</li>
<li><input type="checkbox" disabled="" />
通关城都联盟</li>
<li><input type="checkbox" disabled="" />
通关关都联盟</li>
<li><input type="checkbox" disabled="" />
收集闪耀的叶片</li>
<li><input type="checkbox" disabled="" />
通关宝可全能竞技赛</li>
<li><input type="checkbox" disabled="" />
绘制签名，更换联机形象</li>
<li><input type="checkbox" disabled="" />
盒子皮肤全收集</li>
<li><input type="checkbox" disabled="" />
计步器路线全收集</li>
<li><input type="checkbox" disabled="" />
对战塔100+连胜</li>
<li><input type="checkbox" disabled="" />
完成城都图鉴</li>
<li><input type="checkbox" disabled="" />
完成全国图鉴</li>
<li><input type="checkbox" disabled="" />
游玩对战开拓区</li>
<li><input type="checkbox" disabled="" />
游玩训练家之屋</li>
<li><input type="checkbox" disabled="" />
游玩格斗道场</li>
<li><input type="checkbox" disabled="" />
收集所有宝可装置号码</li>
<li><input type="checkbox" disabled="" />
满级训练家卡片</li>
<li><input type="checkbox" disabled="" />
游戏时间999:59</li>
</ul>
<hr />
<h3 id="宝可梦魂银">宝可梦魂银</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<hr />
<hr />
<h2 id="第五世代">第五世代</h2>
<h3 id="宝可梦黑">宝可梦黑</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
喜欢的ID</li>
<li><input type="checkbox" disabled="" checked="" />
通关联盟</li>
<li><input type="checkbox" disabled="" />
C装置皮肤全收集</li>
<li><input type="checkbox" disabled="" />
盒子皮肤全收集</li>
<li><input type="checkbox" disabled="" />
完成合众图鉴</li>
<li><input type="checkbox" disabled="" />
完成全国图鉴</li>
<li><input type="checkbox" disabled="" />
绘制签名，更换联机形象</li>
<li><input type="checkbox" disabled="" />
达到试炼屋<strong>大师</strong>等级</li>
<li><input type="checkbox" disabled="" />
研究释出之力</li>
<li><input type="checkbox" disabled="" />
研究宝可梦音乐剧</li>
<li><input type="checkbox" disabled="" />
获得所有宝可梦装扮道具</li>
<li><input type="checkbox" disabled="" />
研究连入</li>
<li><input type="checkbox" disabled="" />
满级训练家卡片</li>
<li><input type="checkbox" disabled="" />
游戏时间999:59</li>
</ul>
<hr />
<h3 id="宝可梦白">宝可梦白</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<h3 id="宝可梦黑2">宝可梦黑2</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<h3 id="宝可梦白2">宝可梦白2</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
喜欢的ID</li>
<li><input type="checkbox" disabled="" checked="" />
通关联盟</li>
<li><input type="checkbox" disabled="" />
C装置皮肤全收集</li>
<li><input type="checkbox" disabled="" />
盒子皮肤全收集</li>
<li><input type="checkbox" disabled="" checked="" />
完成合众图鉴</li>
<li><input type="checkbox" disabled="" checked="" />
完成全国图鉴</li>
<li><input type="checkbox" disabled="" />
绘制签名，更换联机形象</li>
<li><input type="checkbox" disabled="" />
达到试炼屋大师等级</li>
<li><input type="checkbox" disabled="" />
获得所有宝可梦装扮道具</li>
<li><input type="checkbox" disabled="" />
宝可梦好莱坞</li>
<li><input type="checkbox" disabled="" checked="" />
通关白色树洞</li>
<li><input type="checkbox" disabled="" />
奖牌全收集</li>
<li><input type="checkbox" disabled="" />
游玩PWT，收集PWT活动赠送锦标赛</li>
<li><input type="checkbox" disabled="" />
对战地铁连胜8+轮</li>
<li><input type="checkbox" disabled="" />
经营乔英大道</li>
<li><input type="checkbox" disabled="" />
满级训练家卡片</li>
<li><input type="checkbox" disabled="" />
游戏时间999:59</li>
</ul>
<hr />
<hr />
<hr />
<h2 id="第六世代">第六世代</h2>
<h3 id="宝可梦x">宝可梦X</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
喜欢的ID</li>
<li><input type="checkbox" disabled="" checked="" />
通关联盟</li>
<li><input type="checkbox" disabled="" />
盒子皮肤全收集</li>
<li><input type="checkbox" disabled="" />
完成卡洛斯中央图鉴</li>
<li><input type="checkbox" disabled="" />
完成卡洛斯海岸图鉴</li>
<li><input type="checkbox" disabled="" />
完成卡洛斯山岳图鉴</li>
<li><input type="checkbox" disabled="" />
完成全国图鉴</li>
<li><input type="checkbox" disabled="" />
集齐所有宝可梦种类的后花园</li>
<li><input type="checkbox" disabled="" />
达到对战城堡称号<strong>大公 / 女大公</strong></li>
<li><input type="checkbox" disabled="" />
达到试炼屋<strong>大师</strong>等级</li>
<li><input type="checkbox" disabled="" />
游玩对战屋</li>
<li><input type="checkbox" disabled="" />
游玩反转对战服务</li>
<li><input type="checkbox" disabled="" />
满级训练家卡片</li>
<li><input type="checkbox" disabled="" />
游戏时间999:59</li>
</ul>
<hr />
<h3 id="宝可梦y">宝可梦Y</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<h3 id="宝可梦欧米伽红宝石">宝可梦欧米伽红宝石</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
喜欢的ID: 40411</li>
<li><input type="checkbox" disabled="" />
通关联盟</li>
<li><input type="checkbox" disabled="" />
研究华丽大赛</li>
<li><input type="checkbox" disabled="" />
研究制作宝可方块</li>
<li><input type="checkbox" disabled="" />
达到试炼屋<strong>大师</strong>等级</li>
<li><input type="checkbox" disabled="" />
游玩对战屋</li>
<li><input type="checkbox" disabled="" />
游玩反转对战服务</li>
<li><input type="checkbox" disabled="" />
盒子皮肤全收集</li>
<li><input type="checkbox" disabled="" />
完成丰缘图鉴</li>
<li><input type="checkbox" disabled="" />
完成全国图鉴</li>
<li><input type="checkbox" disabled="" />
装饰秘密基地</li>
<li><input type="checkbox" disabled="" />
满级训练师卡片</li>
<li><input type="checkbox" disabled="" />
游戏时间999:59</li>
</ul>
<hr />
<h3 id="宝可梦阿尔法蓝宝石">宝可梦阿尔法蓝宝石</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<hr />
<hr />
<h2 id="第七世代">第七世代</h2>
<h3 id="宝可梦日">宝可梦日</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
喜欢的ID</li>
<li><input type="checkbox" disabled="" />
完成诸岛巡礼</li>
<li><input type="checkbox" disabled="" />
图章全收集</li>
<li><input type="checkbox" disabled="" />
将宝可梦搜寻镜升级到Ver.5</li>
<li><input type="checkbox" disabled="" />
完成美乐美乐图鉴</li>
<li><input type="checkbox" disabled="" />
完成阿卡拉图鉴</li>
<li><input type="checkbox" disabled="" />
完成乌拉乌拉图鉴</li>
<li><input type="checkbox" disabled="" />
完成波尼图鉴</li>
<li><input type="checkbox" disabled="" />
完成阿罗拉地区图鉴</li>
<li><input type="checkbox" disabled="" />
对战树50+连胜</li>
<li><input type="checkbox" disabled="" />
游玩皇家巨蛋</li>
<li><input type="checkbox" disabled="" />
将圆庆广场升级到Level 100+</li>
<li><input type="checkbox" disabled="" />
游戏时间999:59</li>
</ul>
<h3 id="宝可梦月">宝可梦月</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<h3 id="宝可梦究极之日">宝可梦究极之日</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<h3 id="宝可梦究极之月">宝可梦究极之月</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<h3 id="宝可梦lets-go皮卡丘lets-go伊布">宝可梦Let's Go！皮卡丘／Let's
Go！伊布</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
不玩</li>
</ul>
<hr />
<hr />
<hr />
<h2 id="第八世代">第八世代</h2>
<h3 id="宝可梦剑">宝可梦剑</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
通关联盟</li>
<li><input type="checkbox" disabled="" checked="" />
完成伽勒尔图鉴</li>
<li><input type="checkbox" disabled="" />
完成铠岛图鉴</li>
<li><input type="checkbox" disabled="" />
完成王冠雪原图鉴</li>
<li><input type="checkbox" disabled="" />
对战塔33+场连胜</li>
<li><input type="checkbox" disabled="" />
级别对战大师球级</li>
</ul>
<hr />
<h3 id="宝可梦盾">宝可梦盾</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
开始游戏</li>
</ul>
<hr />
<h3 id="晶灿钻石明亮珍珠">晶灿钻石／明亮珍珠</h3>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
不玩</li>
</ul>
]]></content>
      <categories>
        <category>Pokemon</category>
      </categories>
      <tags>
        <tag>Pokemon</tag>
        <tag>Schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>博客个性化笔记----基于Ocean</title>
    <url>/Learning/Blog/Blog-Personalization/</url>
    <content><![CDATA[<p>记录博客在使用 <a
href="https://github.com/zhwangart/hexo-theme-ocean">Oceon</a>
主题时进行的各项改动， 根据<a
href="/Archive/The-First-Blog/">置顶◇代办◇与更新记录</a>记录的更新顺序排序.</p>
<p>封面 [ID:89138905].</p>
<span id="more"></span>
<div class="note warning"><p>注意，本博客已更换为 <a
href="https://theme-next.js.org/">NexT主题</a>.</p>
</div>
<h1 id="更新首页视频">更新首页视频</h1>
<p>在<code>/themes/ocean/source/images/ocean</code>中替换相关视频.
如果想替换文件名，打开<code>/themes/ocean/layout/_partial/ocean.ejs</code>，修改对应代码：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;video-media&quot;&gt;</span><br><span class="line">  &lt;video playsinline=&quot;&quot; autoplay=&quot;&quot; loop=&quot;&quot; muted=&quot;&quot; data-autoplay=&quot;&quot; poster=&quot;&lt;%- theme.ocean.path %&gt;ocean.png&quot;</span><br><span class="line">    x5-video-player-type=&quot;h5&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;&lt;%- theme.ocean.path %&gt;ocean.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;&lt;%- theme.ocean.path %&gt;ocean.ogv&quot; type=&quot;video/ogg&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;&lt;%- theme.ocean.path %&gt;ocean.webm&quot; type=&quot;video/webm&quot;&gt;</span><br><span class="line">    &lt;p&gt;Your user agent does not support the HTML5 Video element.&lt;/p&gt;</span><br><span class="line">  &lt;/video&gt;</span><br><span class="line">  &lt;div class=&quot;video-overlay&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure> 将其中的文件名改为自己的文件名即可.</p>
<h1 id="开启gallery功能">开启Gallery功能</h1>
<p>按照<a
href="https://zhwangart.com/2018/11/30/Ocean/#%E7%9B%B8%E5%86%8C">官方文档相关部分</a>进行设置.</p>
<p>添加照片:</p>
<p>打开<code>/source/gallery/index.md</code>，修改<strong>Front-matter</strong>部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Gallery</span><br><span class="line">author: YourName</span><br><span class="line">albums: [</span><br><span class="line">        [&quot;address of image1&quot;,&quot;description&quot;],</span><br><span class="line">        [&quot;address of image2&quot;,&quot;description&quot;],</span><br><span class="line">        [&quot;address of image3&quot;,&quot;description&quot;],</span><br><span class="line">        ]</span><br><span class="line">#date: Date</span><br><span class="line">#type: gallery</span><br><span class="line">#layout: &quot;gallery&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>如果操作完后无法正常显示照片，参考官方文档中的<a
href="https://zhwangart.com/2019/07/02/Ocean-Issues/#2-9-%E7%9B%B8%E5%86%8C%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%85%A2">改进图片加速方法</a>.</p>
<h1 id="新增favorites页面">新增Favorites页面</h1>
<ul>
<li><p>创建一个 <em>page</em> 命名 <em>favorites</em>：
<code>$ hexo new page favorites</code></p></li>
<li><p>在 <code>/themes/_config.yml</code> 文件新增一个菜单：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">收藏: /favorites</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>-修改 <code>/themes/ocean/source/css/_partialnavbar.styl</code>
文件中应该是第 35 行，<em>favorites</em>
，展示收藏图标，注意顺序，如果对菜单顺序不理解，看<a
href="https://zhwangart.com/2019/07/02/Ocean-Issues/#2">这里</a>. 编辑
favorites 页面，格式如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 样机 Mockups</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;card-quote&quot;&gt;</span><br><span class="line"></span><br><span class="line">&gt; ![Graphics](/images/logos/lstoreLogo.svg)</span><br><span class="line">&gt; ## Graphics</span><br><span class="line">&gt; 高质量的样机素材</span><br><span class="line">&gt; [https://www.ls.graphics](https://www.ls.graphics)</span><br><span class="line"></span><br><span class="line">&gt; ![sketchsheets](/images/logos/sketchLogo.svg)</span><br><span class="line">&gt; ## Sketchsheets</span><br><span class="line">&gt; Sketch 稿件的样机素材</span><br><span class="line">&gt; [https://sketchsheets.com](https://sketchsheets.com)</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="更新icon">更新icon</h1>
<p>修改 <code>/themes/_config.yml</code> 文件，大约第10行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Miscellaneous</span><br><span class="line">favicon: /filename.ico          #这里</span><br><span class="line">brand: /images/filename.png     #这里</span><br><span class="line"></span><br><span class="line"># Ocean Video</span><br><span class="line"># Because I put videos in multiple formats on the same path, I just labeled the path here.</span><br><span class="line">ocean:</span><br><span class="line">  overlay: true</span><br><span class="line">  path: /images/ocean/</span><br><span class="line">  brand: /images/filename.png   #这里</span><br></pre></td></tr></table></figure>
<p>分别将对应图片/图标放在<code>/themes/ocean/source</code>、<code>/themes/ocean/source</code>、<code>/themes/ocean/source/images</code>中.</p>
<h1 id="更新404页面.">更新404页面.</h1>
<p>直接更换<code>/themes/ocean/source/404.html</code>即可.
如果只想更换改主题404页面的图片，替换
<code>/themes/ocean/source/images/forrestgump.png</code>图片即可.</p>
<h1 id="背景添加动态线条效果">背景添加动态线条效果</h1>
<p>在<code>/Hexo/themes/ocean/layout/layout.ejs</code>文件中添加如下代码：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--动态线条背景--&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;</span><br><span class="line">color=&quot;220,220,220&quot; opacity=&#x27;0.7&#x27; zIndex=&quot;-2&quot; count=&quot;200&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0）
opacity：表示线条透明度（0~1），默认：0.5 -
count：表示线条的总数量，默认：150
zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1</p>
<ul>
<li><p>如果想要实现随机线条颜色效果，将上述代码中的链接内的代码拷贝至本地，将其中添加随机生成颜色代码后引用.
然后将color参数删除. 下面是我修改的随机颜色代码.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function l() &#123;</span><br><span class="line">      var randomColor = Math.floor(Math.random() * 256) + &#x27;, &#x27; + Math.floor(Math.random() * 256) + &#x27;, &#x27; +Math.floor(Math.random() * 256)</span><br><span class="line">      var i = j(&quot;script&quot;),</span><br><span class="line">          w = i.length,</span><br><span class="line">          v = i[w - 1];</span><br><span class="line">      return &#123;</span><br><span class="line">          l: w,</span><br><span class="line">          z: o(v, &quot;zIndex&quot;, - 1),</span><br><span class="line">          o: o(v, &quot;opacity&quot;, 0.5),</span><br><span class="line">          c: o(v, &quot;color&quot;, randomColor),</span><br><span class="line">          n: o(v, &quot;count&quot;, 99)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="添加点击特效">添加点击特效</h1>
<p>参考文章<a
href="https://blog.csdn.net/qq_43562785/article/details/109511585">纯Javascript实现鼠标点击特效（烟花特效）</a>.</p>
<p>在<code>/Hexo/themes/ocean/layout/layout.ejs</code>文件中添加如下代码：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击特效--&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/click.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
在目录<code>/themes/ocean/source/js</code>中新建文件<code>click.js</code>，填入参考文章中的代码.</p>
<ul>
<li>如果想要自定义颜色，修改代码中数组<code>const colours = ["色值1", "色值2", "色值3", "色值4", "色值5"];</code>中色值即可.</li>
</ul>
<h1 id="添加博客隐藏功能">添加博客隐藏功能</h1>
<p>参考<a
href="https://github.com/prinsss/hexo-hide-posts/blob/master/README_ZH.md">hexo-hide-posts官方文档</a></p>
<h1
id="修复category页面无法正确显示标题的错误">修复Category页面无法正确显示标题的错误</h1>
<p>研究完才发现有人已经pr过了，详见<a
href="https://github.com/zhwangart/hexo-theme-ocean/pull/35/files">修复主题关于catefories和tags页显示网页标题为underfine问题</a>.</p>
<h1 id="加入博客评论功能">加入博客评论功能</h1>
<p>详见<a
href="https://zhwangart.com/2018/11/30/Ocean/#%E8%AF%84%E8%AE%BA">Ocean官方文档相关部分</a>.
此博客仅使用了Gitalk.</p>
<h1 id="实现图片懒加载">实现图片懒加载</h1>
<p>使用Hexo插件<a
href="https://github.com/Troy-Yang/hexo-lazyload-image">hexo-lazyload-image</a>实现.
- 运行代码<code>$ npm install hexo-lazyload-image --save</code> - 在
<code>/themes/_config.yml</code> 文件末尾加上以下代码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lazyload:</span><br><span class="line">enable: true</span><br><span class="line">onlypost: false # optional</span><br><span class="line">loadingImg: # optional eg ./images/loading.gif 这里填写你的懒加载图片地址，请提前将其放在博客图片库中.</span><br><span class="line">isSPA: false # optional</span><br><span class="line">preloadRatio: 3 # optional, default is 1</span><br></pre></td></tr></table></figure> -
配置相关参数： - onlypost If true, only the images from post or page
will support lazy-load. If false, the whole images of your site will use
lazy-load, including the images dist from your theme, but not including
the background images from CSS style.</p>
<ul>
<li><p>loadingImg If you keep the value nothing (by default), then it
will use the default loading image. If you want to customize the image,
then you need to copy your loading image to your current theme image
folder and then change this path to find it.</p></li>
<li><p>isSPA For performance considering, isSPA is added. If your theme
is a SPA page, please set it as true to make the lazy loading works, If
true, searching for each image during scrolling to support SPA page, If
false (default value), the performance would be the best.</p></li>
<li><p>preloadRatio This option is for a better experience and default
value is 1. This ratio means to pre-load the images where is within how
many ratios than current screen size, even these images are not in
current view point.</p></li>
<li><p>取消不需要的图片懒加载 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img no-lazy src=&quot;abc.png&quot; /&gt;</span><br></pre></td></tr></table></figure> 以 Ocean 主题为例，
修改<code>/themes/ocean/layout/_partial/ocean.ejs</code>中所有<code>&lt;img&gt;</code>标签,
修改<code>/themes/ocean/layout/_partial/sidebar.ejs</code>中所有<code>&lt;img&gt;</code>标签.</p></li>
</ul>
<h1 id="增加博客加密功能">增加博客加密功能</h1>
<p>参考<a
href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt官方文档</a>.
按钮样式修改在<code>/node_modules/hexo-blog-encrypt/lib/hbe.style.css</code>中.</p>
<h1 id="end">END</h1>
<p>如果你有什么别的更好的个性化方案，请<a
href="/about/">与我联系</a>，一同进步！</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Practical-Tips</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Ocean</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch笔记10----激活函数与常见Loss</title>
    <url>/Learning/Notes/PyTorch/PyTorch10/</url>
    <content><![CDATA[<p>梯度下降，激活函数，与常见Loss</p>
<span id="more"></span>
<h1 id="梯度下降">梯度下降</h1>
<p>新值 = 当前值 - 学习率 * 梯度</p>
<ul>
<li>可能会收敛到局部极小值</li>
<li>学习率不能太大</li>
<li>逃离局部最小值：添加一个动量（惯性）</li>
<li>使用sigmoid函数当x很大的时候导数趋向于0，数据会得不到更新，这种现象叫做梯度弥散</li>
</ul>
<h1 id="一些激活函数">一些激活函数</h1>
<h2 id="sigmoid">Sigmoid</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">z = torch.linspace(-100, 100, 10)</span><br><span class="line">z   #tensor([-100.0000, -77.7778, -55.5556, -33.3333, -11.1111, 11.1111, 33.3333, 55.5556, 77.7778, 100.0000])</span><br><span class="line">torch.sigmoid(z)</span><br><span class="line">#tensor([0.0000e+00, 1.6655e-34, 7.4564e-25, 3.3382e-15, 1.4945e-05, 9.9999e-01, 1.0000e+00, 1.0000e+00, 1.0000e+00, 1.0000e+00])</span><br></pre></td></tr></table></figure>
<h2 id="tanh">tanh</h2>
<p><code>tanh(x) = 2sigmoid(2x) - 1</code> 类似sigmoid，值域(-1, 1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.linspace(-1, 1, 10)</span><br><span class="line">torch.tanh(a)</span><br></pre></td></tr></table></figure>
<h2 id="relu-rectified-linear-unit">ReLU (Rectified Linear Unit)</h2>
<ul>
<li>使用很多，奠基石</li>
<li>减少了梯度弥散和梯度爆炸的出现</li>
<li>使用<code>torch.relu(a)</code>或<code>F.relu(a)</code>（<code>import torch.nn.functional as F</code>）</li>
</ul>
<h2 id="softmaxsoft-version-of-max">Softmax（soft version of max）</h2>
<p>输入y: [y1, y2, ..., yn] ，输出p: [p1, p2, ..., pn]且sum(p) = 1
<code>S(yi) = exp(yi) / sum(exp(y))</code> 如y:[2.0, 1.0, 0.1] ---&gt;
p: [0.7, 0.2, 0.1] 会让大的更大，小的压缩在一个更密集的空间
梯度<code>dpi_daj</code>： - i = j: <code>dpi_dai = pi * (1 - pi)</code>
&gt; 0 - i != j:<code>dpi_daj = - pj * pi</code> &lt; 0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(3)</span><br><span class="line">a.requires_grad_()</span><br><span class="line"></span><br><span class="line">p = F.softmax(a, dim = 0)</span><br><span class="line">#每次求导会将梯度信息清除</span><br><span class="line">#应该在第一次函数内加入retain_graph = True参数</span><br><span class="line"></span><br><span class="line">p = F.softmax(a, dim = 0)</span><br><span class="line">torch.autograd.grad(p[1], [a], retain_graph = True)</span><br><span class="line">#tensor([-0.0828, 0.2274, -0.1447]) 索引1为正</span><br><span class="line">torch.autograd.grad(p[2], [a])</span><br><span class="line">#tensor([-0.0979, -0.1447, 0.2425]) 索引2为正</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.backward()</span><br><span class="line">--------ERROR--------</span><br><span class="line">#p是向量，这样.backward()会报错</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="loss及其梯度">Loss及其梯度</h1>
<h2 id="均方差msemean-squared-error">均方差MSE（Mean Squared
Error）</h2>
<p><code>loss = sum((y - y_pred) ** 2)</code> 不是L2-norm
<code>L2-norm = sqrt(sum((y - y+pred) ** 2))</code> 可以使用norm()函数
<code>loss = norm.norm(y - y_pred, 2).pow(2)</code>
梯度：<code>dloss_dx = 2 * sum(y - y_pred) * dy_pred_dx</code></p>
<p>使用PyTorch求导 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.ones(1)</span><br><span class="line">w = torch.full([1], 2)</span><br><span class="line">mse = F.mse_loss(x * w, torch.ones(1))  #第一个参数为predict值，第二个参数为label</span><br><span class="line">#tensor(1.)</span><br><span class="line"></span><br><span class="line">torch.autograd.grad(mse, [w])</span><br><span class="line">#第一个参数y，第二个参数[x1, x2, ...]</span><br><span class="line">#tensor定义时默认不需要求导信息，所以w无法求导 </span><br><span class="line">--------ERROR--------</span><br><span class="line"></span><br><span class="line">#对w进行更新或者在定义w时加入参数requires_grad = True</span><br><span class="line">w.requires_grad_()</span><br><span class="line">    #tensor([2.], requires_grad = True)</span><br><span class="line">    #这时求梯度仍然会报错，因为PyTorch是动态图（做一步计算一步图），要先更新一下mse</span><br><span class="line">mse = F.mse_loss(x * w, torch.ones(1))</span><br><span class="line"></span><br><span class="line">torch.autograd.grad(mse, [w])   #tensor([2.])                                                                                                                 </span><br><span class="line"></span><br><span class="line">mse.backward()</span><br><span class="line">mse.grad            #tensor([2.])</span><br></pre></td></tr></table></figure></p>
<h1 id="cross-entropy-loss">Cross Entropy Loss</h1>
<p>之后介绍</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch笔记09----高阶OP</title>
    <url>/Learning/Notes/PyTorch/PyTorch09/</url>
    <content><![CDATA[<p>记录了PyTorch中两个高阶操作：<code>Where</code>与<code>Gather</code></p>
<span id="more"></span>
<h2 id="where">Where</h2>
<p><code>torch.where(condition, x, y)</code></p>
<p>满足condition的 返回x，否则返回y</p>
<p>x、y、condition的shape相同</p>
<p>condition矩阵: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([[1, 0],</span><br><span class="line">        [0, 1]])</span><br></pre></td></tr></table></figure>
那么A的地方取x对应元素，B的地方取y对应元素</p>
<h2 id="example">example</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cond        #tensor([[0.6769, 0.7271],</span><br><span class="line">                     [0.8884, 0.4163]])</span><br><span class="line">a           #tensor([[0., 0.],</span><br><span class="line">                     [0., 0.]])  </span><br><span class="line">b           #tensor([[1., 1.],</span><br><span class="line">                     [1., 1.]])</span><br><span class="line">                     </span><br><span class="line">torch.where(cond &gt; 0.5, a, b)</span><br><span class="line">#tensor([[0., 0.],</span><br><span class="line">         [0., 1.]])</span><br></pre></td></tr></table></figure>
<h2 id="gather">Gather</h2>
<p><code>torch.gather(input, dim, index, out = None)</code> &gt;
index是表，dim是查表的维度，index是需要查的index</p>
<p>查表操作，如：表[x1, x2, x3]，那么我们gather需要查的index：[0, 1, 0,
2]得到[x1, x2, x1, x3]</p>
<p>四条数据输入神经网络得到一个输出：[4, 10]
取出每条数据概率最大的index:[[1], [2], [0], [9]]
使用gather查表得到对应的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prob = torch.rand(4, 10)</span><br><span class="line">idx = prob.topk(dim = 1, k = 3)[1]</span><br><span class="line">idx</span><br><span class="line">#tensor([[7, 4, 9],</span><br><span class="line">         [8, 1, 3],</span><br><span class="line">         [2, 8, 4],</span><br><span class="line">         [8, 6, 0]])</span><br><span class="line">label = torch.arange(10) + 100</span><br><span class="line">label</span><br><span class="line">#tensor([100, 101, ..., 109])</span><br><span class="line"></span><br><span class="line">torch.gather(label.expand(4, 10), dim = 1, index = idx.long())</span><br><span class="line">#tensor([[107, 104, 109],</span><br><span class="line">         [108, 101, 103],</span><br><span class="line">         [102, 108, 104],</span><br><span class="line">         [108, 106, 100]])</span><br><span class="line">#.long()转化为LongTensor类型，不加也可以得到相同结果</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch笔记08----统计属性</title>
    <url>/Learning/Notes/PyTorch/PyTorch08/</url>
    <content><![CDATA[<p>记录了PyTorch一些常见统计属性.</p>
<span id="more"></span>
<p>常见统计属性： - norm 范数 - mean sum - prod 累乘 - min max argmin
argmax 最小/大值的位置 - kthvalue topk</p>
<h1 id="norm">norm</h1>
<p><em>不是normalize正则化</em> <em>矩阵范数与向量范数有区别的</em></p>
<p>norm-p p范数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.full([8], 1)</span><br><span class="line">b = a.review(2, 4)</span><br><span class="line">c = a.review(2, 2, 2)</span><br><span class="line"></span><br><span class="line">a.norm(1), b.norm(1), c.norm(1)</span><br><span class="line">#tensor(8.), tensor(8.), tensor(8.)</span><br><span class="line"></span><br><span class="line">a.norm(2), b.norm(2), c.norm(2)</span><br><span class="line">#tensor(2.8284), tensor(2.8284), tensor(2.8284)</span><br><span class="line"></span><br><span class="line">b.norm(1, dim = 0)</span><br><span class="line">#tensor([4., 4.])</span><br><span class="line"></span><br><span class="line">c.norm(1, dim = 0)</span><br><span class="line">#tensor([[2, 2],</span><br><span class="line">         [2, 2]])</span><br></pre></td></tr></table></figure></p>
<h1 id="mean-sum-min-max-prod-argmax-argmin">mean / sum / min / max /
prod / argmax / argmin</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.arange(8).view(2, 4).float()</span><br><span class="line">#tensor([[0, 1, 2, 3],</span><br><span class="line">         [4, 5, 6, 7]])</span><br><span class="line">         </span><br><span class="line">a.min(), a.max(), a.mean(), a.prod(), a.sum()</span><br><span class="line">#tensor(0.), tensor(7.), tensor(3.5000), tensor(0.), tensor(28.)</span><br><span class="line"></span><br><span class="line">a.max(dim = 1)</span><br><span class="line">#tensor([3., 7.]), tensor([3, 3])</span><br><span class="line"></span><br><span class="line">a.argmax(), a.argmin()</span><br><span class="line">#tensor(7), tensor(0) 会将tesor打平后求max、min索引</span><br><span class="line"></span><br><span class="line">a.argmax(dim = 1)</span><br><span class="line">#tensor([3, 3])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="dim-keepdim">dim / keepdim</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(4, 10)</span><br><span class="line">a.max(dim = 1)</span><br><span class="line">#tensor([0.8362, 1.7015, 1.1297, 0.6386]), tensor([3, 8, 6, 4])</span><br><span class="line"></span><br><span class="line">a.max(dim = 1, keepdim = True)  #dim与原tensor保持一致</span><br><span class="line">#tensor([[0.8362],</span><br><span class="line">         [1.7015],</span><br><span class="line">         [1.1297],</span><br><span class="line">         [0.6386]]), tensor([[3],</span><br><span class="line">                             [8],</span><br><span class="line">                             [6],</span><br><span class="line">                             [4]])</span><br><span class="line">                             </span><br><span class="line">a.argmax(dim = 1, keepdim = True)</span><br><span class="line">#tensor([[3],</span><br><span class="line">         [8],</span><br><span class="line">         [6],</span><br><span class="line">         [4]])</span><br></pre></td></tr></table></figure>
<h1 id="top-k-k-th">top-k / k-th</h1>
<ul>
<li>top-k 返回最大的k个数和其索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.randn(4, 10)</span><br><span class="line">a.topk(3, dim = 1)</span><br><span class="line">#tensor([[0.8362, 0.3913, -0.1830],</span><br><span class="line">         [1.7832, 1.4828,  1.2393],</span><br><span class="line">         [0.6392, 0.3824,  0.2227],</span><br><span class="line">         [0.9928, 0.1215, -0.3927]]), tensor([[3, 8, 9],</span><br><span class="line">         [8, 6, 5],</span><br><span class="line">         [2, 3, 6],</span><br><span class="line">         [5, 7, 9]])</span><br><span class="line"> </span><br><span class="line">a.topk(3, dim = 1, largest = false)    #返回最小的k个</span><br></pre></td></tr></table></figure>
<ul>
<li>kthvalue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.kthvalue(8, dim = 1)</span><br><span class="line">#tensor([-0.1830, 1.2393, 0.2227, -0.3927]), tensor([9, 5, 6, 9])</span><br><span class="line">#返回第8小的元素及其索引（在这里是第3大）</span><br><span class="line">a.kthvalue(8)       #结果同上</span><br></pre></td></tr></table></figure>
<h1 id="compare">compare</h1>
<blockquote>
<p>&gt;, &gt;=, &lt;, &lt;=, !=, == <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a &gt; 0</span><br><span class="line">#tensor([[0, 0, 0, 1, ...],</span><br><span class="line">         [0, 0, 0, 0, ...],</span><br><span class="line">         [0, 1, 1, 0, ...],</span><br><span class="line">         [0, 0, 0, 0, ...]])</span><br><span class="line">torch.gt(a, 0)  #结果同上</span><br><span class="line"></span><br><span class="line">b = rand(2, 2)</span><br><span class="line">torch.eq(b, b)</span><br><span class="line">#tensor([[1, 1],</span><br><span class="line">         [1, 1]])</span><br><span class="line">torch.equal(b, b)</span><br><span class="line">#True</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch笔记07----基本运算</title>
    <url>/Learning/Notes/PyTorch/PyTorch07/</url>
    <content><![CDATA[<p>PyTorch的一些基本运算</p>
<span id="more"></span>
<ul>
<li>add / minus / multiply / divide</li>
<li>matmul</li>
<li>pow</li>
<li>sqrt / rsqrt</li>
<li>round</li>
</ul>
<h1 id="basic">basic</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(3, 4)</span><br><span class="line">b = torch.rand(4)</span><br><span class="line"></span><br><span class="line">torch.all(torch.eq(a + b, torch.add(a, b))) #tensor(True)</span><br><span class="line"></span><br><span class="line">torch.all(torch.eq(a - b, torch.sub(a, b))) #tensor(True)</span><br><span class="line"></span><br><span class="line">torch.all(torch.eq(a * b, torch.mul(a, b))) #tensor(True)</span><br><span class="line"></span><br><span class="line">torch.all(torch.eq(a / b, torch.div(a, b))) #tensor(True)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>//</code>是整除</p>
</blockquote>
<h1 id="matmul-矩阵乘法">matmul 矩阵乘法</h1>
<ul>
<li><code>torch.mm</code> only for 2d，因此不推荐</li>
<li><code>torch.matmul</code> 或 <code>@</code></li>
</ul>
<blockquote>
<p><code>*</code>是相同位置元素相乘，<code>.matmul</code>是矩阵乘法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a                   #tensor([[3., 3.],</span><br><span class="line">                             [3., 3.]])</span><br><span class="line">b = torch.ones(2, 2)</span><br><span class="line"></span><br><span class="line">torch.mm(a, b)      #tensor([[6., 6.],</span><br><span class="line">                             [6., 6.]])</span><br><span class="line">                             </span><br><span class="line">torch.matmul(a, b)</span><br><span class="line">a @ b</span><br><span class="line">#结果相同     </span><br></pre></td></tr></table></figure>
<h2 id="example">example</h2>
<p>神经网络线性层的相加 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(4, 784)</span><br><span class="line">x = torch.rand(4, 784)</span><br><span class="line"></span><br><span class="line">w = torch.rand(512, 784)    #降维，把784降到512</span><br><span class="line"># 默认是[channel-out, channel-in]</span><br><span class="line"></span><br><span class="line">(x @ w.t()).shape           #tensor.Size([4, 512])</span><br><span class="line">#如果w是高维的，使用transpose交换</span><br></pre></td></tr></table></figure></p>
<h2 id="tensor-matmul">tensor matmul</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(4, 3, 28, 64)</span><br><span class="line">b = torch.rand(4, 3, 64, 32)</span><br><span class="line"></span><br><span class="line">torch.mm(a, b).shape</span><br><span class="line">--------ERROR--------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">torch.matmul(a, b).shape        #tensor.Size([4, 3, 28, 32]) 只用最后两维运算，前面的不变</span><br><span class="line"></span><br><span class="line">b = torch.rand(4, 1, 64, 32)</span><br><span class="line">torch.matmul(a, b).shape        #tensor.Size([4, 3, 28, 32]) 使用了broadcast机制</span><br><span class="line"></span><br><span class="line">b = torch.rand(2, 64, 32)</span><br><span class="line">torch.matmul(a, b).shape</span><br><span class="line">--------ERROR--------</span><br></pre></td></tr></table></figure>
<h1 id="power-sqrt-rsqrt">power / sqrt / rsqrt</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.full([2, 2], 3)</span><br><span class="line">a.power(2)      #tensor([[9., 9.],</span><br><span class="line">                         [9., 9.]])</span><br><span class="line">a ** 2          #结果相同</span><br><span class="line"></span><br><span class="line">aa = a ** 2</span><br><span class="line">aa.sqrt()       #tensor([[3., 3.],</span><br><span class="line">                         [3., 3.]])</span><br><span class="line">aa.rsqrt()      #tensor([[0.3333, 0.3333],</span><br><span class="line">                         [0.3333, 0.3333]])</span><br><span class="line">#是sqrt的倒数</span><br><span class="line"></span><br><span class="line">a ** 0.5        #同sqrt()</span><br><span class="line">```                         </span><br><span class="line"></span><br><span class="line"># exp / log</span><br></pre></td></tr></table></figure>
<p>a = torch.exp(torch.ones(2, 2)) a #tensor([[2.7183, 2.7183], [2.7183,
2.7183]])</p>
<p>torch.log(a) #tensor([[1., 1.], [1., 1.]])
#默认以e为底，还可使用log2()、log10() <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># approximation 近似值</span><br><span class="line">- `.floor()` / `.ceil()` 向下取整与向上取整</span><br><span class="line">- `.round()` 四舍五入</span><br><span class="line">- `.trunc()` / `.frac()` 整数部分与小数部分</span><br><span class="line"></span><br><span class="line"># clamp 裁剪</span><br><span class="line">- gradient clipping 梯度裁剪（梯度弥散、梯度爆炸）</span><br><span class="line">&gt; 时不时要打印梯度的模`w.grad.norm(2)`</span><br><span class="line"></span><br></pre></td></tr></table></figure> grad = torch.rand(2,
3) * 15 grad #tensor([[14.8737, 10.1571, 4.4872], [11.3591, 8.9101,
14.0524]])</p>
<p>grad.max() #tensor(14.8737) grad.median() #tensor(10.1571) 中间值</p>
<p>grad.clamp(10) #将grad中的小于10的部分变为10 #tensor([[14.8737,
10.1571, 10.0000], [11.3591, 10.0000, 14.0524]])</p>
<p>grad.clamp(0, 10) #将grad中的数据设置为0～10直接，超出算10，小于算0
#tensor([[10.0000, 10.0000, 4.4872], [10.0000, 8.9101, 10.0000]])
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">梯度裁剪：</span><br></pre></td></tr></table></figure> for w in [] #wlist clamp(w.grad, 10) ```</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch笔记06----拼接与拆分</title>
    <url>/Learning/Notes/PyTorch/PyTorch06/</url>
    <content><![CDATA[<p>Tensor的拼接与拆分操作</p>
<span id="more"></span>
<ul>
<li>Cat</li>
<li>Stack</li>
<li>Split</li>
<li>Chunk</li>
</ul>
<h1 id="cat">cat</h1>
<p>Statisics about scores - [class1-4, students, scores] - [class5-9,
students, scores]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(4, 32, 8)</span><br><span class="line">b = torch.rand(5, 32, 8)</span><br><span class="line"></span><br><span class="line">torch.cat([a, b], dim = 0).shape</span><br><span class="line">#torch.Size([9, 32, 8])</span><br><span class="line">#第一个参数是一个list，包含了所有需要拼接的Tensor</span><br><span class="line">#第二个参数dim决定了合并的维度</span><br><span class="line">#其他维度要一样</span><br><span class="line">c = torch.rand(3, 32, 1)</span><br><span class="line">torch.cat([a, c], dim = 0).shape</span><br><span class="line">--------ERROR--------</span><br></pre></td></tr></table></figure>
<h1 id="stack">stack</h1>
<p>create new dim <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(32, 8)</span><br><span class="line">b = torch.rand(32, 8)</span><br><span class="line"></span><br><span class="line">torch.stack([a, b], dim = 0).shape</span><br><span class="line">#torch.Size([2, 32, 8])</span><br><span class="line">torch.stack([a, b], dim = 1).shape</span><br><span class="line">#torch.Size([32, 2, 8])</span><br></pre></td></tr></table></figure> 例如一个老师统计了一个班的成绩:
[students, scores]，另一个老师也是，那么使用stack得到[2, students,
scores]，而不是把students那一维度拼接起来</p>
<p><strong>stack必须维度一致</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(30, 8)</span><br><span class="line">b = torch.rand(32, 8)</span><br><span class="line">torch.stack([a, b], dim = 0)</span><br><span class="line">--------ERROR--------</span><br></pre></td></tr></table></figure></p>
<h1 id="split-by-len">split: by len</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = torch.rand(32, 8)</span><br><span class="line">a.shape     #torch.Size([32, 8])</span><br><span class="line">c = torch.stack([a, b], dim = 0)</span><br><span class="line">c.shape     #torch.Size([2, 32, 8])</span><br><span class="line"></span><br><span class="line">aa, bb = c.split(1, dim = 0)    #第一个参数是长度</span><br><span class="line">aa.shape, bb.shape</span><br><span class="line">#torch.Size([1, 32, 8]), torch.Size([1, 32, 8])</span><br><span class="line"></span><br><span class="line">aa, bb = c.split([1, 1], dim = 0)   #第一个参数是长度的list</span><br><span class="line">#结果同上</span><br><span class="line"></span><br><span class="line">aa, bb = c.split(2, dim = 0)</span><br><span class="line">-------ERROR--------</span><br></pre></td></tr></table></figure>
<h1 id="chunk-by-num">chunk: by num</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = torch.rand(32, 8)</span><br><span class="line">a.shape     #torch.Size([32, 8])</span><br><span class="line">c = torch.stack([a, b], dim = 0)</span><br><span class="line">c.shape     #torch.Size([2, 32, 8])</span><br><span class="line"></span><br><span class="line">aa, bb = c.chunk(2, dim = 0)    #平均分成2块</span><br><span class="line">aa.shape, bb.shape</span><br><span class="line">#torch.Size([1, 32, 8]), torch.Size([1, 32, 8])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch笔记05----Broadcast自动扩展</title>
    <url>/Learning/Notes/PyTorch/PyTorch05/</url>
    <content><![CDATA[<p>PyTorch的自动扩展</p>
<span id="more"></span>
<ul>
<li>Expand，可以维度扩展</li>
<li>without copying data，扩展时不用拷贝数据，能节省空间</li>
</ul>
<h1 id="key-idea">Key idea</h1>
<ul>
<li>Insert 1 dim ahead</li>
<li>Expand dims with size 1 to same size</li>
</ul>
<p>Feature maps: [4, 32, 14, 14] Bias: [32] --&gt; [32, 1, 1] --&gt; [1,
32, 1, 1] --&gt; [4, 32, 14, 14]</p>
<p>Broadcast示意图： <img data-src="/images/body/PyTorch/PyTorch05.png"
alt="Figure1" /></p>
<h1 id="why-broadcasting">Why broadcasting</h1>
<ol type="1">
<li>for actual demanding
<ul>
<li>[class, student, scores]</li>
<li>Add bias for every students: +5 score</li>
<li>[4, 32, 8] + [5.0] (标量)</li>
<li><code>bias.unsqueeze(0).unsqueeze(0).expand_as(A)</code></li>
</ul></li>
<li>memory consumption 节省内存消耗</li>
</ol>
<h1 id="is-it-broadcasting-able">Is it broadcasting-able?</h1>
<h2
id="match-from-last-dim-从最后一维匹配一般最后一维是物理意义上的小维度">Match
from <strong>Last</strong> dim
从最后一维匹配（一般最后一维是物理意义上的小维度）</h2>
<ul>
<li>If current dim = 1, expand to same</li>
<li>If either has no dim, insert one dim and expand to same</li>
<li>otherwise, NOT broadcasting-able</li>
</ul>
<blockquote>
<p>例如[8, 32, 8]（8个班，每班32个学生，每个学生修八门课即八个成绩）bias
= [5]是 [1]的shape，对八门课都要加，对每个班每个学生都适用 --&gt; [1, 1,
1] ---&gt; [32, 32, 8]</p>
</blockquote>
<blockquote>
<p>如果仅对某一门课的成绩添加bias，那么bias = [0, 0, 5, ..., 0]是
[8]的shape，每个班每个学生都适用 --&gt; [1, 1, 8] --&gt; [32, 32, 8]</p>
</blockquote>
<blockquote>
<p>A: [4, 32, 8], bias: [4] NOT broadcasting-able</p>
</blockquote>
<h1 id="situation">Situation</h1>
<h2 id="situation-1">Situation 1</h2>
<p>A: [4, 32, 14, 14] B: [1, 32, 1, 1] --&gt; [4, 32, 14, 14]</p>
<h2 id="situation-2">Situation 2</h2>
<p>A: [4, 32, 14, 14] B: [14, 14] --&gt; [1, 1, 14, 14] --&gt; [4, 32,
14, 14]</p>
<h2 id="situation-3">Situation 3</h2>
<p>A: [4, 32, 14, 14] B: [2, 32, 14, 14] NOT broadcasting-able</p>
<h1 id="how-to-understand-this-behavior">How to understand this
behavior?</h1>
<h2 id="when-it-has-no-dim">When it has no dim</h2>
<ul>
<li>treat it as all own the same</li>
<li>[class, student, scores] + [scores]</li>
</ul>
<h2 id="when-it-has-dim-of-size-1">When it has dim of size 1</h2>
<ul>
<li>treat it shared by all</li>
<li>[class, student, scores] + [student, 1]（a学生所有课程 +
0，b学生所有课程 + 1 ...这种情况）</li>
</ul>
<p><strong><em>match from LAST dim</em></strong></p>
<p>+ [1, 1, 1, 1] 等价 + [1]</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>如何自制宝可梦Gen4与Gen5的配信器</title>
    <url>/Pokemon/Strategies/In-Game/WCD-Distribution-Patch/</url>
    <content><![CDATA[<p>这是宝可梦自制四五代配信器的教程. 如有纰漏，请<a
href="/about/">与我联系</a>，万分感谢！</p>
<p>封面 [ID:84354949].</p>
<span id="more"></span>
<p><strong>注意，本教程仅支持<a
href="https://wiki.52poke.com/wiki/%E7%AC%AC%E5%9B%9B%E4%B8%96%E4%BB%A3">宝可梦第四世代</a>正作游戏与<a
href="https://wiki.52poke.com/wiki/%E7%AC%AC%E4%BA%94%E4%B8%96%E4%BB%A3">宝可梦第五世代</a>正作游戏.</strong></p>
<p>如果你在找<a
href="https://wiki.52poke.com/wiki/%E7%AC%AC%E4%B8%89%E4%B8%96%E4%BB%A3">宝可梦第三世代</a>的船票配信方法，请点击<a
href="https://github.com/mrhappyasthma/NDSEventTool.nds">这里</a>.</p>
<h1 id="准备工作">准备工作</h1>
<p><strong>请确保你了解一些计算机基础知识</strong></p>
<h2 id="硬件准备">硬件准备</h2>
<ul>
<li>能够游玩第四、五世代宝可梦卡带的<em>NDS</em>、<em>3DS</em>系列机器<strong>两台</strong>（以下简称
<em>DS</em> 系列掌机）.</li>
<li>电脑.</li>
<li><em>NDS</em>烧录卡与读卡器.</li>
</ul>
<h2 id="下载配信所需工具">下载配信所需工具：</h2>
<ul>
<li><p>四代<a
href="https://gbatemp.net/threads/wcdpatcher.129568/">WCDPatcher</a>
上面帖子里的下载地址失效了，可以点击<a
href="https://projectpokemon.org/home/files/file/1808-pok%C3%A9mon-wcd-patcher/">这里</a>下载.</p></li>
<li><p><a
href="https://projectpokemon.org/home/files/category/2-event-gallery/">你想要的配信的Mystery
Gift and Wonder Card files</a></p></li>
<li><p>或者点击<a
href="/download/WCD-Distribution-Patch.rar">这里</a>下载由b站用户<a
href="https://space.bilibili.com/3691432">翾樾non</a>整理的自制配信器所需的所有文件.
&gt;
很遗憾我没有找到他这里第五世代的<code>LTDCE.exe</code>文件的发布网站，但找到了另外一个第五世代配信器制作软件<a
href="https://github.com/PlasticJustice/PKMG5DC">PKMG5DC</a>，感兴趣的话可以自行研究一下</p></li>
</ul>
<blockquote>
<p>b站用户<a
href="https://space.bilibili.com/3691432">翾樾non</a>有发布很详细的<a
href="https://www.bilibili.com/video/BV1QW411D78Q?share_source=copy_web">视频教学</a>，请先观看该视频.</p>
</blockquote>
<h1 id="制作配信器">制作配信器</h1>
<p>如果你下载的是压缩包，请先解压. &gt; 接下来的教程将会以下载<a
href="https://space.bilibili.com/3691432">翾樾non</a>提供的压缩包为例.</p>
<h2 id="第四世代">第四世代</h2>
<figure>
<img data-src="/images/body/WCD-Distribution-Patch/Figure1.png"
alt="Figure1" />
<figcaption aria-hidden="true">Figure1</figcaption>
</figure>
<ul>
<li><p>打开<em>Gen4</em>文件夹中的<code>WCDPatcher.exe</code>.
点击红色框.</p></li>
<li><p>在弹出的<em>Select the Distribution
ROM</em>窗口中选择同一目录下的<code>NTR-AARE-USA - GameStop Deoxys.nds</code>文件并点击<em>打开</em>.</p></li>
<li><p>点击<code>WCDPatcher.exe</code>上的蓝色框.</p></li>
<li><p>在弹出的<em>Select the Wondercard
ROM</em>窗口中，打开文件夹<code>Gen4\PPorg_GenIV_WCs\PPorg_GenIV_WCs\</code>并寻找你所需要的配信文件并点击<em>打开</em>.
如<code>Gen4\PPorg_GenIV_WCs\PPorg_GenIV_WCs\Darkrai - Movie 2007\</code>文件夹下的<code>007 Movie Darkrai ENG-USA [PPorg].pcd</code>文件.</p>
<blockquote>
<p>注意，每个配信对应的文件夹中的文件分游戏语音（地区）版本，请选择你接收的游戏对应的版本</p>
</blockquote></li>
<li><p>点击<code>WCDPatcher.exe</code>上的紫色框，并选择对应地区语言版本.</p></li>
<li><p>点击<code>WCDPatcher.exe</code>上的黄色框.</p></li>
<li><p>在弹出的<em>Select the New ROM
Location</em>窗口中，打开到你想要保存的位置，在文件名处随意命名，点击<em>保存</em>.</p></li>
<li><p>得到<code>.nds</code>文件.</p></li>
</ul>
<h2 id="第五世代">第五世代</h2>
<figure>
<img data-src="/images/body/WCD-Distribution-Patch/Figure2.png"
alt="Figure2" />
<figcaption aria-hidden="true">Figure2</figcaption>
</figure>
<ul>
<li>打开<em>Gen5</em>文件夹中的<code>LTDCE.exe</code>. 点击<strong>Open
ROM</strong>.</li>
<li>在弹出的<em>Open Nintendo DS
ROM</em>窗口中选择同一目录下的<code>2046 Liberty Pass ENG .nds</code>文件并点击<em>打开</em>.</li>
<li>点击<code>LTDCE.exe</code>上的红色框.</li>
<li>在弹出的<em>Open Pokemon Mystery Gift
File</em>窗口中，打开文件夹<code>Gen5\PPorg_GenV_WCs\PPorg_GenV_WCs</code>并根据你的游戏语言版本进入对应文件夹，寻找你所需要的配信文件并点击<em>打开</em>.
如<code>Gen5\PPorg_GenV_WCs\PPorg_GenV_WCs\English</code>文件夹下的<code>028 Dark Explorer Darkrai ENG [PPorg].pgf</code>文件.</li>
<li>点击<code>LTDCE.exe</code>上的绿色框，并选择对应地区语言版本.</li>
<li>点击<code>LTDCE.exe</code>上的蓝色框.</li>
<li>在弹出的<em>Save Nintendo DS
ROM</em>窗口中，打开到你想要保存的位置，在文件名处随意命名，点击<em>保存</em>.</li>
<li>得到<code>.nds</code>文件.</li>
</ul>
<h1 id="进行配信">进行配信</h1>
<ul>
<li>将上一步得到的<code>.nds</code>文件放入烧录卡中，使用一台
<em>DS</em> 系列掌机打开该nds文件.</li>
<li>另一台 <em>DS</em> 系列掌机运行游戏，按照正常配信步骤配信即可.
参考<a
href="https://wiki.52poke.com/wiki/%E7%A5%9E%E7%A7%98%E7%A4%BC%E7%89%A9#.E7.AC.AC.E5.9B.9B.E4.B8.96.E4.BB.A3">神百--神秘礼物</a>界面.</li>
</ul>
<blockquote>
<p>注意，这一步请确保 <em>DS</em> 系列掌机的WiFi开关打开（New 3DS、New
2DS、2DS、DSi系列需要在设置中打开，3DS需要打开侧边开关，DS、DS
Lite系列不用管）</p>
</blockquote>
]]></content>
      <categories>
        <category>Pokemon</category>
      </categories>
      <tags>
        <tag>Pokemon</tag>
        <tag>Pokemon-Distribution</tag>
        <tag>Pokemon-Gen4</tag>
        <tag>Pokemon-Gen5</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch笔记04----Tensor维度变换</title>
    <url>/Learning/Notes/PyTorch/PyTorch04/</url>
    <content><![CDATA[<p>PyTorch的一些Tensor维度变换方式</p>
<span id="more"></span>
<h1 id="view-reshape">View / Reshape</h1>
<blockquote>
<p>通用，要有物理意义，否则是污染数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(4, 1, 28, 28)</span><br><span class="line">a.shape         #torch.Size([4, 1, 28, 28])</span><br><span class="line"></span><br><span class="line">a.view(4, 28 * 28).shape        #torch.Size([4, 784])</span><br><span class="line">#特别适合全连接层</span><br><span class="line"></span><br><span class="line">b = a.view(4, 784)      #会丢失原来的维度信息</span><br><span class="line">b.view(4, 28, 28, 1)    #造成了数据污染</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>Flewible but prone to corrupt 如果view的size不同，会报错
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.view(4, 783)</span><br><span class="line">--------Error--------</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="squeeze-unsqueeze">Squeeze / Unsqueeze</h1>
<h2 id="unsqueeze">Unsqueeze</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.shape         #torch.Size([4, 1, 28, 28])</span><br><span class="line"></span><br><span class="line">a.unsqueeze(0).shape    #torch.Size([1, 4, 1, 28, 28]) 在位置0处增加一维</span><br><span class="line"></span><br><span class="line">a.unsqueeze(-1).shape   #torch.Size([4, 1, 28, 28, 1])</span><br><span class="line"></span><br><span class="line">a.unsqueeze(5).shape</span><br><span class="line">---------Error--------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.tensor([1.2, 2.3])</span><br><span class="line">a.unsqueeze(-1)</span><br><span class="line">#tensor([[1.2000],</span><br><span class="line">         [2.3000]])</span><br><span class="line">#shape由[2]变为[2,1]</span><br><span class="line"></span><br><span class="line">a.unsqueeze(0)</span><br><span class="line">#tensor([[1.2000, 2.3000]])</span><br><span class="line">#shape由[2]变为[1,2]</span><br></pre></td></tr></table></figure>
<ul>
<li>Example &gt; 将shape为[32]的bias增加到shape为[4， 32， 14，
14]的FeatureMap的channel中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = torch.rand(32)</span><br><span class="line">f = torch.rand(4, 32, 14, 14)</span><br><span class="line"></span><br><span class="line">b = b.unsqueeze(1).unsqueeze(2).unsqueeze(0)</span><br><span class="line">#注意第二次的unsqueeze参数是按第一次操作过后的索引</span><br><span class="line"></span><br><span class="line">b.shape     #torch.Size([1, 32, 1, 1])</span><br></pre></td></tr></table></figure>
<h2 id="squeeze">Squeeze</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b.shape             #torch.Size([1, 32, 1, 1])</span><br><span class="line">b.squeeze().shape   #torch.Size([32]) 不传递参数时将能挤压的全部挤压</span><br><span class="line">b.squeeze(0).shape  #torch.Size([32, 1, 1])</span><br><span class="line"></span><br><span class="line">b.squeeze(1).shape  #torch.Size([1, 32, 1, 1]) 维度不是1，所以不能挤压，但不会报错</span><br></pre></td></tr></table></figure>
<h1 id="expand-repeat">Expand / Repeat</h1>
<p>维度扩展
之前的<code>b: [1, 32, 1, 1]``f: [4, 32, 14, 14]</code>仍不能相加，需要分别将第0、2、3维度扩展4、14、14倍</p>
<ul>
<li>Expand：broadcasting. 只改变理解方式，不改变数据</li>
<li>Repeat：memory copied. 增加数据，都拷贝一遍.</li>
</ul>
<blockquote>
<p>推荐Expand，省略复制数据，只在操作必要时复制.
运行速度快且节约内存.</p>
</blockquote>
<h2 id="expand">Expand</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(4, 32, 14, 14)</span><br><span class="line">b.shape         #torch.Size(1, 32, 1, 1)</span><br><span class="line">b.expand(4, 32, 14, 14).shape       #torch.Size(4, 32, 14, 14)</span><br><span class="line">#前提：前后dim一致（这里都为4），1扩展到N，M扩展到M</span><br><span class="line"></span><br><span class="line">b.expand(-1, 32, -1, -1).shape       #torch.Size(1, 32, 1, 1) -1保持不变</span><br><span class="line"></span><br><span class="line">b.expand(-1, 32, -1, -4).shape       #torch.Size(1, 32, 1, -4)  是个bug，无意义</span><br></pre></td></tr></table></figure>
<h2 id="repeat">Repeat</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b.shape         #torch.Size(1, 32, 1, 1)</span><br><span class="line">b.repeat(4, 32, 1, 1).shape     #torch.Size(4, 1024, 1, 1) repeat的参数是对应维度复制的次数</span><br><span class="line"></span><br><span class="line">b.repeat(4, 1, 14, 14).shape     #torch.Size(4, 32, 14, 14)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>会使得你无法使用原来的数据，占用内存变多会重新申请一片空间</p>
</blockquote>
<h1 id="t-矩阵转置">T 矩阵转置</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.randn(3, 4)</span><br><span class="line">a.t().shape     #torch.Size([4, 3])</span><br><span class="line">#仅支持2D，1D、3D...都不支持</span><br></pre></td></tr></table></figure>
<h1 id="transpose-交换维度">Transpose 交换维度</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.shape = [4, 3, 32, 32]</span><br><span class="line">a1 = a.transpose(1, 3).view(4, 3*32*32).view(4, 3, 32, 32)</span><br><span class="line">-------------ERROR------------</span><br><span class="line">#transpose操作之后会使得元素不连续，所以在view之前要加上contiguous操作</span><br><span class="line"></span><br><span class="line">a1 = a.transpose(1, 3).contiguous().view(4, 3*32*32).view(4, 3, 32, 32) #污染数据</span><br><span class="line">a1.shape        #torch.Size([4, 3, 32, 32])</span><br><span class="line"></span><br><span class="line">a2 = a.transpose(1, 3).contiguous().view(4, 3*32*32).view(4, 32, 32, 3).transpose(1, 3) #与a等价，注意第二个view与a1不同</span><br><span class="line">a2.shape                        #torch.Size([4, 3, 32, 32])</span><br><span class="line"></span><br><span class="line">#验证，用eq函数比较各个数据是否一致，返回[4, 3, 32, 32]的张量，all函数判断其所有元素是否都为True</span><br><span class="line">torch.all(torch.eq(a, a1))      #tensor(False)</span><br><span class="line"></span><br><span class="line">torch.all(torch.eq(a, a2))      #tensor(True)</span><br></pre></td></tr></table></figure>
<h1 id="permute">Permute</h1>
<p>transpose只能两两交换 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = torch.rand(4, 3, 28, 32)</span><br><span class="line">b.tanspose(1, 3).transpose(1, 2).shape</span><br><span class="line">#torch.Size([4, 28, 32, 3])</span><br><span class="line"></span><br><span class="line">b.permute(0, 2, 3, 1).shape</span><br><span class="line">#torch.Size([4, 28, 32, 3])</span><br><span class="line">#permute的参数为排列后的索引</span><br></pre></td></tr></table></figure> &gt;
permute函数也会打乱内存顺序，需要时也要用到contifuous函数，也就是重新生成一片内存再复制过来.</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch笔记03----索引与切片</title>
    <url>/Learning/Notes/PyTorch/PyTorch03/</url>
    <content><![CDATA[<p>PyTorch中的索引与切片.</p>
<span id="more"></span>
<h1 id="indexing">Indexing</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(4, 3, 28, 28)</span><br><span class="line"></span><br><span class="line">a[0].shape      #torch.Size([3, 28, 28])</span><br><span class="line">a[0, 0].shape   #torch.Size([28, 28])</span><br><span class="line">a[0, 0, 2, 4]   #tensor(0.8082)</span><br></pre></td></tr></table></figure>
<h1 id="select-first-last-n">select first / last N</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.shape         #torch.Size([4, 3, 28, 28])</span><br><span class="line">a[:2].shape     #torch.Size([2, 3, 28, 28]) 左闭右开</span><br><span class="line">a[:2, :1, :,:]  #torch.Size([2, 1, 28, 28])</span><br><span class="line">a[:2, 1:, :,:]  #torch.Size([2, 2, 28, 28])</span><br><span class="line">a[:2, -1:, :,:] #torch.Size([2, 1, 28, 28])</span><br></pre></td></tr></table></figure>
<h1 id="select-by-steps">select by steps</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[:, :, 0:28:2, 0:28:2].shape</span><br><span class="line">#torch.Size([4, 3, 14, 14]) 后两个维度每两个取一个，2是step</span><br><span class="line">a[:, :, ::2, ::2].shape     #与上面的等价</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同Python切片</p>
</blockquote>
<h2 id="select-by-specific-index">select by specific index</h2>
<ul>
<li>index_select()
第一个参数表示操作的维度，第二个参数直接给索引号（必须是Tensor）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.index_select(0, torch.Tensor([0, 2])).shape</span><br><span class="line">#torch.Size([2, 3, 28, 28])</span><br><span class="line">a.index_select(1, torch.Tensor([1, 2])).shape</span><br><span class="line">#torch.Size([4, 2, 28, 28])</span><br><span class="line"></span><br><span class="line">a.index_select(2, torch.arange(8)).shape</span><br><span class="line">#torch.Size([4, 3, 8, 28])</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="select-by-...">select by <code>...</code></h2>
<blockquote>
<p><code>...</code>代表任意维度，贪心匹配（？） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[...].shape            #等价于a[:, :, :, :].shape</span><br><span class="line">a[0, ...].shape         #等价于a[0].shape</span><br><span class="line">a[0,...,::2].shape      #torch.Size([1, 3, 28, 14])</span><br><span class="line">a[:, 1, ...].shape      #torch.Size([4, 1, 28, 28])</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="select-by-mask">select by mask</h2>
<blockquote>
<p>使用掩码选择，会打平数据，用的不多</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.randn(3, 4)</span><br><span class="line">#tensor([[-1.3911, -0.7871, -1.6558, -0.2542],</span><br><span class="line">         [-0.9011,  0.5404, -0.6612,  0.3917],</span><br><span class="line">         [-0.3854,  0.2968,  0.6040,  1.5771]])</span><br><span class="line">         </span><br><span class="line">mask = x.ge(0.5)        #大于等于0.5的记为1</span><br><span class="line">#tensor([[0, 0, 0, 0],</span><br><span class="line">         [0, 1, 0, 0],</span><br><span class="line">         [0, 0, 1, 1]], dtype = torch.uint8)</span><br><span class="line">         </span><br><span class="line">torch.masked_select(x, mask)</span><br><span class="line">#tensor([0.5404, 0.6040, 1.5771])</span><br><span class="line">torch.masked_select(x, mask).shape</span><br><span class="line">#torch.Size([3]) 与原shape无关</span><br></pre></td></tr></table></figure>
<h2 id="select-by-flatten-index">select by flatten index</h2>
<ul>
<li>take函数也会打平数据，用的不多</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src = torch.tensor([[4, 3, 5],</span><br><span class="line">                    [6, 7, 8]])</span><br><span class="line">torch.take(src, torch.tensor([0, 2, 5]))</span><br><span class="line">#tensor([4, 5, 8])</span><br><span class="line">#[2, 3]先打平成[6]，再选index为0，2，5的数据</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch笔记02----创建Tensor</title>
    <url>/Learning/Notes/PyTorch/PyTorch02/</url>
    <content><![CDATA[<p>PyTorch各种创建Tensor方式</p>
<span id="more"></span>
<h1 id="import-from-numpy">import from numpy</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = np.array([2, 3.3])</span><br><span class="line">torch.from_numpy(a) #tensor([2.000, 3.300], dtype = torch.float64)</span><br><span class="line"></span><br><span class="line">a = np.ones([2, 3])</span><br><span class="line">torch.from_numpy(a) #tensor([[1., 1., 1.],</span><br><span class="line">                             [1., 1., 1.]], dtype = torch.float64)</span><br></pre></td></tr></table></figure>
<h1 id="import-from-list">import from list</h1>
<blockquote>
<p>torch承载的参数是现成的数据：numpy或者list
Torch、FloatTensor接收shape作为参数，生成一个没有初始化的类型.
或使用list来接收现有数据（不建议）. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.tensor([2, 3.2])  #tensor([2.0000, 3.2000])</span><br><span class="line"></span><br><span class="line">torch.FloatTensor([2., 3.2])    #tensor([2.0000, 3.2000])</span><br><span class="line"></span><br><span class="line">torch.tensor([[2., 3.2],[1., 22.3]])</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="uninitialized">uninitialized</h1>
<ul>
<li>torch.empty(d1, d2)</li>
<li>torch.FloatTensor(d1, d2, d3)</li>
<li>torch.IntTensor(d1, d2, d3)</li>
</ul>
<blockquote>
<p>要把未初始化的数据覆盖掉，如果出现torch.nan或者torch.inf，可能就是使用了未初始化的数据.</p>
</blockquote>
<h1 id="set-default-type">set default type</h1>
<blockquote>
<p>一般使用Tensor默认是FloatTensor</p>
</blockquote>
<p>使用<code>torch.set_default_tensor_type(torch.DoubleTensor)</code>来改变默认类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.tensor([1.2, 3]).type #&#x27;torch.FloatTensor&#x27;</span><br><span class="line">torch.set_default_tensor_type(torch.DoubleTensor)</span><br><span class="line">torch.tensor([1.2, 3]).type #&#x27;torch.DoubleTensor&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="randrand_like-randint">rand/rand_like, randint</h1>
<ul>
<li><p>rand 随机使用[0, 1]均匀分布 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.rand(3, 3)    #按均匀分布生成3*3shape的随机张量</span><br></pre></td></tr></table></figure></p></li>
<li><p>rand_like 接受的参数是一个tensor，生成一个和其shape相同的随机张量
&gt; *_like</p></li>
<li><p>randint(min, max, [shape])，左闭右开 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">randint(1, 10, [3, 3])</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h1 id="randn-标准正态分布">randn 标准正态分布</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.randn(3, 3)    #按标准正态分布生成3*3shape的随机张量</span><br></pre></td></tr></table></figure>
<p>如果想自定义均值和方差，使用normal生成一维张量后reshape
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.normal(mean = torch.full([10], 0), std = torch.arange(1, 0, -0.1)) </span><br><span class="line">#torch.full([10], 0)生成一个10*1的全0张量</span><br><span class="line">#均值为0，方差依次递减[1, 0.9, ...]</span><br></pre></td></tr></table></figure></p>
<h1 id="full">full</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.full([2, 3], 7)   #tensor([[7., 7., 7.],</span><br><span class="line">                                 [7., 7., 7.])</span><br><span class="line">torch.full([], 7)   #tensor(7.)</span><br></pre></td></tr></table></figure>
<h1 id="arange-range">arange / range</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.arange(0, 4)   #tensor([0, 1, 2, 3])</span><br><span class="line">torch.arange(0, 4, 2)   #ensor([0, 2])</span><br><span class="line">torch.range(0, 4)   #tensor([0, 1, 2, 3, 4]) 不建议使用range</span><br></pre></td></tr></table></figure>
<h1 id="linspace-logspace">linspace / logspace</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.linspace(0, 10, steps = 4)    #第三个参数是数量</span><br><span class="line">#tensor([0.0000, 3.3333, 6.6666, 10.0000])</span><br><span class="line"></span><br><span class="line">torch.logspace(0, -1, steps = 10)   #相当于linspace生成的这些数作为10的幂</span><br><span class="line">#tensor([1.0000, 0.7743, ..., 0.1000])</span><br></pre></td></tr></table></figure>
<h1 id="ones-zeros-eye">Ones / Zeros / Eye</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.ones(2, 2)</span><br><span class="line">#tensor([[1, 1],</span><br><span class="line">         [1, 1])</span><br><span class="line">         </span><br><span class="line">torch.zeros(2, 2)</span><br><span class="line">#tensor([[0, 0],</span><br><span class="line">         [0, 0])</span><br><span class="line">         </span><br><span class="line">torch.eye(2, 3)</span><br><span class="line">#tensor([[1, 0, 0],</span><br><span class="line">         [0, 1, 0])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.eye(3)</span><br><span class="line">#tensor([[1, 0, 0],</span><br><span class="line">         [0, 1, 0],</span><br><span class="line">         [0, 0, 1]])</span><br><span class="line"></span><br><span class="line">a = torch.zeros(3, 3)</span><br><span class="line">torch.ones_like(a)</span><br><span class="line">#tensor([[1, 1, 1],</span><br><span class="line">         [1, 1, 1],</span><br><span class="line">         [1, 1, 1]])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>eye最多两个参数</p>
</blockquote>
<h1 id="randperm">randperm</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.randperm(10)</span><br><span class="line">#tensor([1, 5, 4, 2, 0, 6, 3, 9, 7, 8]) 生成随机索引</span><br></pre></td></tr></table></figure>
<ul>
<li>random.shuffle &gt; 为了保持配对 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(2, 3)</span><br><span class="line">b = torch.rand(2, 2)</span><br><span class="line">idx = torch.randperm(2)</span><br><span class="line">idx #tensor([1, 0])</span><br><span class="line"></span><br><span class="line">a[idx]</span><br><span class="line">b[idx]</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch笔记01----基本数据类型</title>
    <url>/Learning/Notes/PyTorch/PyTorch01/</url>
    <content><![CDATA[<p>PyTorch基本数据类型</p>
<span id="more"></span>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">python</th>
<th style="text-align: center;">PyTorch</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Int</td>
<td style="text-align: center;">IntTensor of size()</td>
</tr>
<tr class="even">
<td style="text-align: center;">Float</td>
<td style="text-align: center;">FloatTensor of size()</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Int array</td>
<td style="text-align: center;">IntTensor of size[d1, d2, ...]</td>
</tr>
<tr class="even">
<td style="text-align: center;">Float array</td>
<td style="text-align: center;">FloatTensor of size[d1, d2, ...]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">String</td>
<td style="text-align: center;">--</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Pytorch不是一个完备的语言库，不支持String.</p>
</blockquote>
<h1 id="how-to-denote-string">How to denote string</h1>
<ul>
<li><p>One-hot Encoding [0, 1, 0, 0, ...] 每一维代表一个单词 &gt;
数据量过大时，整个向量会变得特别稀疏. &gt;
不同的单词有相近的意思，如like、love，这种方法无法体现这种相关性.</p></li>
<li><p>Embedding</p>
<ul>
<li>Word2vec</li>
<li>glove</li>
</ul></li>
</ul>
<h1 id="data-type">Data type</h1>
<p>CPU tensor: - torch.FloatTensor - torch.IntTensor - ...</p>
<p>GPU tensor: 在torch与tensor之间加上cuda - torch.cuda.FloatTensor -
torch.cuda.IntTensor - ...</p>
<h1 id="type-check">Type check</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.randn(2, 3)   #使用随机正态分布</span><br><span class="line">a.type()    #&#x27;torch.FloatTensor&#x27;</span><br><span class="line"></span><br><span class="line">type(a)     #&#x27;torch.Tensor&#x27;返回基本的数据类型</span><br><span class="line"></span><br><span class="line">isinstance(a, torch.FloatTensor)    #True</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isinstance(data, torch.cuda.DoubleTensor)   #False</span><br><span class="line">data = data.cuda()</span><br><span class="line">isinstance(data, torch.cuda.DoubleTensor)   #True</span><br></pre></td></tr></table></figure>
<h1 id="dimension-0-rank-0-标量">Dimension 0 / Rank 0 标量</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.tensor(1.)    #直接生成标量Tensor(1.)</span><br><span class="line">torch.tensor(1.3)   #直接生成标量tensor(1.300)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>经常用于计算<em>Loss</em> --- 维度为0的标量.</p>
</blockquote>
<p>如何确定Dim为0？ <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loss.shape  #torch.Size([])</span><br><span class="line"></span><br><span class="line">len(Loss.shape) #0</span><br><span class="line"></span><br><span class="line">Loss.dim()  #0</span><br><span class="line"></span><br><span class="line">Loss.size() #torch.Size([])</span><br></pre></td></tr></table></figure></p>
<h1 id="dimension-1-rank-1-向量">Dimension 1 / Rank 1 向量</h1>
<blockquote>
<p>PyTorch里一维多维向量统称tensor张量 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.tensor([1.1])     #tensor([1.1000]) 注意有中括号</span><br><span class="line">torch.tensor([1.1, 2.2])    #tensor([1.1000, 2.2000])</span><br><span class="line"></span><br><span class="line">torch.FloatTensor(1)    #tensor([3.2239e-25]) 指定长度，random初始化</span><br><span class="line">torch.FloatTensor(2)    #tensor([3.2239e-25, 4.5915e-41])</span><br><span class="line"></span><br><span class="line">#还可以通过numpy引入</span><br><span class="line">data = np.ones(2)       #生成一个[1, 1]的向量</span><br><span class="line">data        #array([1., 1.])</span><br><span class="line"></span><br><span class="line">torch.from_numpy(data)  #tensor([1., 1.], dtype=torch.float64)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Dim 1的张量一般用于Bias（偏置）、Linear
Input（神经网络线性层的输入）（如[28,
28]的图片展开成[748]长度的向量输入）.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.ones(2)</span><br><span class="line">a.shape     #torch.Size([2])</span><br><span class="line">a.size()    #torch.Size([2])</span><br></pre></td></tr></table></figure>
<h1 id="dimension-2dimension-3......">Dimension 2、Dimension
3、......</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.randn(2,3)</span><br><span class="line">a       #tensor([[-0.4423, 0.5949, 1.1440],</span><br><span class="line">                 [-2.0935, 0.2051, 1.2781]])</span><br><span class="line">                 </span><br><span class="line">a.shape #torch.Size([2,3])</span><br><span class="line">a.size(0)   #2 第一个维度的长度</span><br><span class="line">a.shape[0]  #2</span><br><span class="line">a.size(1)   #3 第二个维度的长度</span><br><span class="line">a.shape[1]  #3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Dim 2的张量一般用于Linear Input batch（如4张[28,
28]的图片，我们将它们叠在一起，形成[4,
784]，4表示4张照片，784表示一张照片的数据）</p>
</blockquote>
<hr />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.rand(1,2,3)   #使用随机均匀分布</span><br><span class="line">a   #tensor([[[0.0764, 0.2590, 0.9816],</span><br><span class="line">              [0.6798, 0.1568, 0.7919]]])</span><br><span class="line"></span><br><span class="line">a.shape #torch.Size([1, 2, 3])</span><br><span class="line"></span><br><span class="line">a[0]    #tensor([[0.0764, 0.2590, 0.9816],</span><br><span class="line">                 [0.6798, 0.1568, 0.7919]])</span><br><span class="line">            </span><br><span class="line">list(a.shape)   #[1, 2, 3]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Dim 3在RNN Input Batch中使用非常广泛：
一句话有10个单词，每个单词用一个100维的One-hot编码，一次送入20句话，就是[10,
20, 100]</p>
</blockquote>
<blockquote>
<p>Dim 4适合彩色图片： [2, 3, 28, 28]
2张图片，3个通道（RGB，如果是黑白图片则是1），28*28像素的图片</p>
</blockquote>
<pre><code>a = torch.rand(2, 3, 28, 28)

a.dim() #4
a.numel()   #4704 4704 = 2 * 3 * 28 * 28</code></pre>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>宝可梦有电的红蓝宝石实机乱数（不包含 ID 或 Egg）</title>
    <url>/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part2/</url>
    <content><![CDATA[<p>这是宝可梦有电红蓝宝石的实机乱数教程. 不包含 ID 与 Egg 的乱数教程.
如有纰漏，请<a href="/about/">与我联系</a>，万分感谢！</p>
<p>封面 [ID:88418874].</p>
<span id="more"></span>
<p><strong>注意，本教程仅支持：有电的红蓝宝石.</strong></p>
<p>如果你在找绿宝石及没电红蓝宝石的红蓝宝石实机乱数教程，请点击<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part1/">这里</a>.</p>
<p>如果你在找火红叶绿的实机乱数，请点击<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part3/">这里</a>.</p>
<blockquote>
<p>实机很难实现，难度很高.</p>
</blockquote>
<blockquote>
<p>成果展示: <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part2/Result.png"
alt="Result" /></p>
</blockquote>
<h1 id="准备工作">准备工作</h1>
<p>如果你想要乱数闪光宝可梦，你需要知道你的<a
href="https://wiki.52poke.com/wiki/ID_No.#.E9.87.8CID_No.">SID</a>.</p>
<blockquote>
<p>如果你想要乱数的是已经创建好的存档，这可能会需要你导出存档并使用
<em>PKHex</em>
等软件查看你的存档（不涉及修改与导入），请根据自身接受程度使用.（本教程默认读者使用<em>NDS</em>烧录卡进行存档提取来方便查看个体）</p>
</blockquote>
<blockquote>
<p>由于我没有怎么研究过乱数ID，所以如果你想要乱数ID，请参考：<a
href="https://www.smogon.com/ingame/rng/rs_nonbredrng#idsid">Smogon ID
乱数教程</a>.<br> 之后如果自己研究了一遍就会上传Blog.</p>
</blockquote>
<blockquote>
<p>不会导出存档？看看这篇博客：<a
href="/Pokemon/Strategies/In-Game/How-To-Back-Up-Your-Savefiles/">如何备份你的存档</a>.</p>
</blockquote>
<h2 id="硬件准备">硬件准备</h2>
<ul>
<li>能够游玩第三世代宝可梦卡带的<em>NDS</em>系列机器（初代 <em>NDS</em>
或 <em>NDS lite</em>，以下统称 <em>NDS</em>）.</li>
<li>电脑.</li>
<li><em>NDS</em>烧录卡与读卡器.</li>
</ul>
<blockquote>
<p>本教程默认读者使用<em>NDS</em>烧录卡进行存档提取来方便查看个体，如若抗拒，请参考
<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part1/">宝可梦绿宝石及没有电的红蓝宝石实机乱数（不包含
ID 或 Egg）</a> 中提及的方法（使用神奇糖果）.</p>
</blockquote>
<h2 id="下载乱数所需工具">下载乱数所需工具：</h2>
<ul>
<li>计时器<a href="/download/CCTimer.rar">CCTimer</a>
因为没有找到该软件的发布页，所以上传至仓库可直接点击下载，如果你知道它的发布页，请与我联系.</li>
<li>乱数工具<a
href="https://www.dropbox.com/sh/68qqg26op3uaymc/AAC8QFFKYxAqQjG80abgcHZ1a?dl=0">3genSearch</a>
国内需要科学上网，因原作者禁止二次发布所以这里不提供直接下载，可以通过各搜索引擎找到别人的分享.</li>
<li>乱数工具<a
href="https://github.com/Admiral-Fish/RNGReporter/releases">RNGReporter</a>
如果因为国内 GitHub 下载速度原因不好下载，可以点击<a
href="/download/RNGReporter.zip">这里</a>进行下载.</li>
<li>时钟修复软件<a
href="https://wiki.52poke.com/wiki/%E6%97%B6%E9%92%9F%E7%94%B5%E8%B7%AF%EF%BC%88%E6%BC%8F%E6%B4%9E%EF%BC%89#.E5.A4.96.E9.83.A8.E9.93.BE.E6.8E.A5">rtcread</a>
将<code>.nds</code>文件放在烧录卡的储存卡中. 也可以点击<a
href="/download/rtcread-ds.rar">这里</a>进行下载.</li>
<li>存档编辑软件<a
href="https://github.com/kwsch/PKHeX/releases">PKHex</a>
将使用其查看宝可梦的个体，不会涉及到存档修改. 如果因为国内 GitHub
下载速度原因不好下载，可以点击<a
href="/download/PKHeX(190705).zip">这里</a>进行下载（版本：19.07.05）.</li>
<li>seed查找工具<a
href="https://www.smogon.com/forums/threads/rng-manipulation-in-firered-leafgreen-wild-pok%C3%A9mon-supported-in-rng-reporter-9-93.62357/">FRLGSeedFinder</a>
如果选用3genSearch可以不用此工具. 也可以点击<a
href="/download/FRLGSeedFinder.zip">这里</a>进行下载.</li>
</ul>
<blockquote>
<p>两个乱数工具选择任意一个都可以，本教程使用的是 <em>3genSearch</em>.
RNGReporter的使用与之类似，还请读者自行探索.</p>
</blockquote>
<h2 id="了解乱数机制">了解乱数机制</h2>
<p>请参考<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part1/#了解乱数机制">宝可梦绿宝石及没有电的红蓝宝石实机乱数（不包含
ID 或 Egg）</a> 中的相应部分.
这里不同的是，我们需要知道有电的红蓝宝石（以下简称
<strong><em>RS</em></strong>）进入游戏的初始 seed. 而
<strong><em>RS</em></strong> 的初始 seed
在每一分钟都是相同的，也就是说，控制进入游戏时 <em>RTC</em>
的时间在同一分钟就可以固定住初始 seed，因此我们使用时钟修复软件
rtcread.</p>
<blockquote>
<p>我在参阅外网资料时有看到，<strong><em>RS</em></strong> 的初始 seed
每分钟推进 1，但实际操作中发现并不是这样. 有时会推进
1，有时会推进或者倒退很多（但不会太多，大约 2~16左右）. 因此 seed
并不会变化太快.</p>
</blockquote>
<h2 id="确定乱数目标">确定乱数目标</h2>
<p>与<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part1/#确定乱数目标">宝可梦绿宝石及没有电的红蓝宝石实机乱数（不包含
ID 或 Egg）</a>相同.
<strong><em>如果选择了野外相遇的宝可梦，请在队伍中准备一只习得了<a
href="https://wiki.52poke.com/wiki/%E7%94%9C%E7%94%9C%E9%A6%99%E6%B0%94%EF%BC%88%E6%8B%9B%E5%BC%8F%EF%BC%89#.E5.8F.AF.E4.BB.A5.E5.AD.A6.E4.BC.9A.E8.AF.A5.E6.8B.9B.E5.BC.8F.E7.9A.84.E5.AE.9D.E5.8F.AF.E6.A2.A6">甜甜香气</a>的宝可梦.</em></strong>
确定乱数目标后，选择相应的 <em>Method</em>. 如果是乱数蛋，请参阅<a
href="https://www.smogon.com/ingame/rng/emerald_rng_part4">这里</a>.</p>
<h3 id="method-1"><em>Method 1</em></h3>
<ul>
<li>御三家（<strong><em>RS</em></strong>、<strong><em>E</em></strong>
一周目与 <strong><em>E</em></strong> 二周目）</li>
<li>定点宝可梦</li>
<li>釜炎镇 NPC 赠送的小果然的蛋</li>
<li><strong><em>RS</em></strong> 通过甜甜香气遭遇的宝可梦</li>
<li><strong><em>RS</em></strong> 通过钓鱼遭遇的宝可梦（除丑丑鱼）</li>
<li><strong><em>RS</em></strong> 通过碎岩遭遇的宝可梦</li>
</ul>
<h3 id="method-2"><em>Method 2</em></h3>
<ul>
<li>草丛/海草/深沙/洞穴/水上/可以遇到宝可梦的建筑中通过移动/转向
遭遇的宝可梦（除了游走宝可梦）</li>
<li><strong><em>E</em></strong> 通过甜甜香气遭遇的宝可梦</li>
<li><strong><em>E</em></strong> 钓鱼钓上来的宝可梦</li>
<li><strong><em>E</em></strong> 通过碎岩遇到的宝可梦</li>
</ul>
<h3 id="method-4"><em>Method 4</em></h3>
<ul>
<li>钓鱼钓上来的丑丑鱼</li>
</ul>
如果是 <em>Method
1</em>中的前三类，点击下面的谜拟Q来查看保存游戏的位置与生成帧的所在时机（
<strong><em>E</em></strong> 与 <strong><em>RS</em></strong>
有些会有区别）：
<details>
<summary>
<img no-lazy data-src="/images/mimikyu.png" alt="Method 2 请点击丘丘" align=left>
</summary>
<br> -- 御三家：在博士的包前保存，在问你“Do you choose this
POKéMON?”时等待生成帧 <br> -- 飘浮泡泡：在反派干部前保存，在研究员说“It
might be an odd way of thanking you, but take this POKéMON.”时等待生成帧
<br> --
游走水都：击败冠军后在出自己的房间门前存档，在让你选择红蓝时等待生成帧
<br> -- 复活化石：在研究员前保存，在他说“The fossil was an ancient
POKéMON. [LILEEP/ANORITH], it was!”时等待生成帧 <br> -- 小果然的蛋：在
NPC 前存档，在她说“Good! I hope you'll walk plenty with this here
EGG!”时等待生成帧 <br> -- 变隐龙：在隐形的变隐龙前存档，在提示“The
startled POKéMON attacked!”时等待生成帧 <br> --
大吾的铁哑铃：在精灵球前存档，在选择是否拿走时等待生成帧 <br> --
胡说树：在其面前存档，在提示“The weird tree attacked!”时等待生成帧 <br>
--
盖欧卡与固拉多：在距离剧情触发前一步存档，在进入战斗前最后一段时等待生成帧
<br> -- 凤王：Save on the first space of the peak of the cliff. Last
input is pressing up on the directional pad to place yourself on the
second space of the cliff. <br> -- 梦幻：Save in the area it appears in.
Last input is a press of the A button to "tag" it. <br> --
其他：在宝可梦/触发物前保存，在进入战斗前最后一段时等待生成帧 <br> <br>
凤王和梦幻的不知道怎么表达比较好，看英文感受一下.
</details>
<p><br><br></p>
<p>如果是 <em>Method 2</em> 或 <em>Method 1</em>
的后三类，在进入战斗前最后一次点击作为生成帧.</p>
<blockquote>
<p>实际生成帧可能会更往后，如甜甜香气，但这段时间是固定的，可以通过多次尝试来更新.</p>
</blockquote>
<h1 id="开始乱数">开始乱数</h1>
<h2 id="确定初始seed">确定初始seed</h2>
<ol type="1">
<li>在<em>NDS</em>上插入 <strong><em>RS</em></strong> 游戏卡带与烧录卡.
<img data-src="/images/body/Pokemon-RNG-Abuse-Gen3-Part2/Figure1.png"
alt="Figure1" /></li>
<li>打开烧录卡，选择时钟修复软件 rtcread 运行. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part2/Figure2.png"
alt="Figure2" /></li>
<li>按下 <em>start</em> 键，你可以看到当前 <strong><em>RS</em></strong>
卡带的RTC. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part2/Figure3.png"
alt="Figure3" /></li>
<li>按下 <em>select</em> 键，进入修改RTC时间模式.</li>
<li>选择一个时间，并且让秒数归零，如图选择的是 <strong>2002-10-31
10:42:00</strong>. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part2/Figure4.png"
alt="Figure4" /></li>
<li>按下 <em>start</em> 键，并尽快关机.</li>
<li>尽快开机进入游戏，任意捕捉一只宝可梦后存档并关机（宝可梦相遇越快越好）.</li>
<li>使用 NDS烧录卡 提取游戏存档后使用 PKHex 打开.</li>
<li>找到你捕捉的宝可梦，右击选择 <em>查看</em> 并选择左侧选项卡的
<em>数值</em>. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part2/Figure5.png"
alt="Figure5" /></li>
<li>打开乱数工具，选择<em>个体逆算</em>，并根据 PKHex 中的数据填入并点击
<em>计算</em>（游戏版本与地点、相遇方式等也别忘了修改）
再根据PKHex左侧选项卡的 <em>主页面</em> 确定
<em>开始seed</em>（第一列）或
<em>生成seed</em>（第二列）（如果有多个无法区分，都记下，并可能需要再来一次.
此外，其实只要保证<strong>pid</strong>相同即可）. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part2/Figure6.png"
alt="Figure6" /> <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part2/Figure7.png"
alt="Figure7" /></li>
<li>右击复制该<em>开始seed</em>，选择<em>其他-初期seed检索</em>
，将复制的<em>开始seed</em>填入<em>目标seed</em>，勾选上
<em>初期seed全探索</em>. [F]
处第二个空填入18000左右即可（根据你遇到这只宝可梦的游戏时间决定，一分钟约3600
F），点击 <em>计算</em>. &gt;
图中实例宝可梦并非游戏一开始就遇到的，仅为教程作参考，以实际为准. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part2/Figure8.png"
alt="Figure8" /></li>
<li>记下F最接近实际相遇时间的<em>初期seed</em>.
这就是该RTC时间下的初始seed</li>
</ol>
<blockquote>
<p>之后的步骤与<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part1/#开始乱数">宝可梦绿宝石及没有电的红蓝宝石实机乱数（不包含
ID 或
Egg）</a>相应部分类似，但每次开始游戏前需要执行一遍步骤2~6，且需尽快开机进入游戏以确保seed不变.</p>
</blockquote>
<h2 id="搜索目标宝可梦">搜索目标宝可梦</h2>
<p>打开乱数工具，选择/填入图中红框中内容： <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part1/Figure1.png"
alt="Figure1" /></p>
<ol type="1">
<li>根据乱数目标选择<em>固定</em>或<em>野生</em>.</li>
<li>如果选择了<em>野生</em>，可以修改绿框中的地点、版本信息.</li>
<li>输入之前得到的初期 seed.</li>
<li>F为搜索帧数的范围，建议800~10000，因为 seed
固定了所以可能很靠后才有你想要的帧.（1秒约60帧，请自行推测是否有耐心）（请根据实际情况调整，如甜甜香气动画较长，所以起始帧会高一些）.</li>
<li><em>Method</em> 选择之前确定的 <em>Method</em>.</li>
<li>检索区域根据自己的需要填写，若勾选
<strong><em>只显示异色</em></strong> ，需要在勾选框上方填入表里ID.</li>
<li>点击黑框<em>计算</em>，得到结果.</li>
</ol>
<blockquote>
<p>没有想要的宝可梦怎么办？<br>
不建议帧数再加了，10w帧约27.8分钟了，可以试着降低一下要求.</p>
</blockquote>
<blockquote>
<p>闪帧太靠后了怎么办？<br> 回到 <a href="#确定初始seed">确定初始
seed</a>步骤，并在第五步选择一个不同的时间（精确到 min）.</p>
</blockquote>
<p>在结果中选择一个满意的结果作为目标帧，将其
<strong><em>F</em></strong>
栏（即为你的<em>目标帧</em>）填入蓝框中（蓝框后面的内容不需要管）.</p>
<h2 id="校准误差">校准误差</h2>
<p><strong><em>如果你的目标宝可梦不是野外宝可梦（如定点宝可梦），那么要在步骤1结束后，将存档备份</em></strong></p>
<ol type="1">
<li><p>在游戏中你应该存档的位置存档（如果你准备在洞穴或是能出现宝可梦的建筑中使用甜甜香气，请往深处走一些距离，否则甜甜香气可能会失效），存档完成后关机.</p></li>
<li><p>打开计时器 <em>CCTimer</em>，选择
<em>Setting</em>，点击红框内容，根据游戏平台选择对应选项. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part1/Figure2.png"
alt="Figure2" /></p></li>
<li><p>回到 <em>Timer</em>，在蓝框内填入你刚刚的 <em>目标帧</em> 并点击
<strong><em>Add</em></strong> . <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part1/Figure3.png"
alt="Figure3" /></p></li>
<li><p><strong><em>执行一遍<a href="#确定初始seed">确定初始
seed</a>步骤的2~6，且需尽快开机进入游戏以确保seed不变.</em></strong>
点击 <strong><em>Start</em></strong>
按钮的同时开始游戏(设置过的nds是直接开机，未设置过的nds系列是在主页面点击GBA游戏图标).</p></li>
<li><p>在游戏中快速到达目标帧的确定位置（如：在选择宝可梦使用甜甜香气的界面）.</p></li>
<li><p>在 <em>CCTimer</em> 上的倒计时归零的瞬间按下机器的
<strong><em>A</em></strong> 键，然后等待进入战斗界面.</p></li>
<li><p>捕捉这只宝可梦.</p></li>
<li><p>保存并关闭游戏，提取存档，使用读卡器连接到电脑后使用 PKHex
打开存档，查看刚捕捉的宝可梦的数据.</p></li>
<li><p>回到乱数工具，在黄框中填入刚捕捉到的宝可梦数据（如果不是闪光记得不要勾选
<strong><em>只显示异色</em></strong> ），点击 <em>计算</em>.
记下橙色框中的数字（如有多个，选择离<em>目标帧</em>最近的）. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part1/Figure4.png"
alt="Figure4" /></p></li>
<li><p>回到
<em>CCTimer</em>，计算<em>目标帧</em>减去刚刚橙色框中的数字的值，点击
<strong><em>Clear</em></strong> 按钮清除后输入该值并点击
<strong><em>Add</em></strong> .</p>
<blockquote>
<p>例如 CCTimer 中的值（目标帧）是2156，击中帧是2177，2156 - 2177 =
-21（橙色框中数字为 21），那么将 CCTimer 中的值更新为 2156 - 21 =
2135.</p>
</blockquote></li>
</ol>
<p>误差校准完成.</p>
<blockquote>
<p>注意，如果你更换了目标，即宝可梦获得方式改变（如Method不同 或
由游戏厅切换为固拉多），请重新进行误差校准！</p>
</blockquote>
<h2 id="乱数">乱数</h2>
<p><strong><em>如果你的目标宝可梦不是野外宝可梦（如定点宝可梦），那么要先将备份存档恢复</em></strong>
和校准误差的4、5、6步一致：</p>
<ol type="1">
<li><strong><em>执行一遍<a href="#确定初始seed">确定初始
seed</a>步骤的2~6，且需尽快开机进入游戏以确保seed不变.</em></strong>
点击 <strong><em>Start</em></strong> 按钮的同时开始游戏.</li>
<li>在游戏中快速到达目标帧的确定位置.</li>
<li>在 <em>CCTimer</em> 上的倒计时归零的瞬间按下机器的
<strong><em>A</em></strong> 键，然后等待进入战斗界面.</li>
<li>如果得到的不是<em>目标帧</em>，可以选择再次进行误差校准或者再多尝试几次.</li>
</ol>
<blockquote>
<p>因为手工操作多少会有些误差，建议多尝试几次，若十几二十次失败再考虑重新校准误差.</p>
</blockquote>
<ol start="5" type="1">
<li>乱数成功，得到目标！</li>
</ol>
<h1 id="如果选用-rngreporter">如果选用 RNGReporter</h1>
<p>发现这两个软件在反查初始seed有些不同，下面记录一下RNGReporter反查seed的方法：</p>
<ul>
<li>打开RNGReporter，选择<em>4th Gen Tools</em> 中的 <em>Calculate PID
from IVs</em>. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part2/Figure9.png"
alt="Figure9" /></li>
<li>输入个体性格与你的ID，点击<em>Find</em>，选择<strong>PID</strong>对应的一栏.
<img data-src="/images/body/Pokemon-RNG-Abuse-Gen3-Part2/Figure10.png"
alt="Figure10" /></li>
<li>这里得到的seed是<em>生成seed</em>，将其输入工具<em>FRLGSeedFinder</em>中（虽然写的FRLG，但是三代通用）.
<img data-src="/images/body/Pokemon-RNG-Abuse-Gen3-Part2/Figure11.png"
alt="Figure11" /></li>
<li>得到初始seed.</li>
</ul>
<h1 id="写在后面">写在后面</h1>
<ul>
<li>在<a href="#确定初始seed">确定初始
seed</a>步骤可以多选择几个RTC时间，捉完宝可梦后保存然后再次重复，导出存档一起确定seed，然后选择最满意的.</li>
<li>还有一种比较麻烦的方法，在这里描述一下，十分费时费力，就不展开说了：
<ul>
<li>准备大量的神奇糖果.</li>
<li>使用玩家自制的软件 <a
href="https://www.smogon.com/forums/threads/fr-lg-rng-timer.3554964/">FR/LG
RNG Timer</a>. 也可以点击<a
href="/download/FRLG_RNG_Timer.jar">这里</a>进行下载.</li>
<li>进入游戏的同时开始计时器.</li>
<li>捕捉一只宝可梦并通过糖果确定个体.</li>
<li>使用个体查出初始seed.</li>
<li>查找该seed下满意的宝可梦，将目标帧数输入 FR/LG RNG Timer 点击
Submit.</li>
<li>游戏推进到等待生成帧.</li>
<li>倒计时结束触发生成帧.</li>
<li>捕捉并通过糖果确认个体.</li>
<li>利用个体查找击中帧数，记录校准值.</li>
<li>利用校准值再来一次.</li>
</ul></li>
</ul>
<h1 id="reference">Reference</h1>
<ul>
<li><a
href="https://taiyaki3gen.hatenablog.com/entry/2020/05/30/162400">3genSearch
作者博客</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc21vZ29uLmNvbS9pbmdhbWUvcm5nLw==">Smogon RNG
教程<i class="fa fa-external-link-alt"></i></span></li>
<li><a
href="https://www.smogon.com/forums/threads/rng-manipulation-in-firered-leafgreen-wild-pok%C3%A9mon-supported-in-rng-reporter-9-93.62357/">RNG
Manipulation in FireRed/LeafGreen: Wild Pokémon Supported in RNG
Reporter 9.93</a></li>
<li><a
href="https://www.smogon.com/forums/threads/fr-lg-rng-timer.3554964/">Programming
- FR/LG RNG Timer</a></li>
</ul>
<h1 id="appreciation">Appreciation</h1>
<ul>
<li>感谢<strong>Rai</strong>为我纠正了一些错误.</li>
</ul>
]]></content>
      <categories>
        <category>Pokemon</category>
      </categories>
      <tags>
        <tag>Pokemon</tag>
        <tag>Pokemon-RNG-Abuse</tag>
        <tag>Pokemon-Gen3</tag>
      </tags>
  </entry>
  <entry>
    <title>宝可梦卡带鉴别</title>
    <url>/Pokemon/Strategies/Out-Game/Pokemon-Cartridges-Authenticate/</url>
    <content><![CDATA[<p>从我的b站专栏：<a
href="https://www.bilibili.com/read/cv10463502">宝可梦前代卡带鉴别</a>搬过来的，稍微有些修改.
主要就是宝可梦 <em>GBA</em> 和 <em>NDS</em> 卡带真伪的鉴别.
如果对你有帮助可以去专栏给个三连~</p>
<p>封面 [ID:78728436].</p>
<span id="more"></span>
<hr />
<p>宝可梦前代作为比较保值甚至理财的游戏卡带最近价格一路飞升，而很多入坑的新人却对卡带真假的辨别毫无知识储备.
虽然很多大佬已经写过很多卡带鉴别帖，但有些可能不够有条理（？）决定再写一份.</p>
<p>由于3ds卡带没有假卡（反正我没见过），所以
<strong><em>本博客主要讨论宝可梦三代到四代的主系列游戏卡带、卡盒鉴别方法以及美版中纯美版（北美版）、加拿大美版和亚太美版的区别</em></strong>.</p>
<p>感谢<strong>犬犬</strong>补充与提供部分图片！</p>
<p>感谢<strong>大黄</strong>！为难这个懒b了，我这就爬.</p>
<p>感谢<strong>xxc</strong>提供的部分图片.</p>
<p><del>我就不信这个老金看不懂</del></p>
<p>大部分图片源自网络 侵删</p>
<blockquote>
<p>因为假卡制作成本固定而<strong><em>日版</em></strong>价格偏低，所以日版几乎没有假卡.
有也都是一眼就能看出来的（比如黑色卡壳的宝石什么的）.
所以日版可以大胆放心的买.
但不排除价格飞升后奸商开始把目光转到日版的情况，所以建议也稍微学一下卡带鉴别.</p>
</blockquote>
<h1 id="卡带">卡带</h1>
<h2
id="gba系列红宝石-蓝宝石-火红-叶绿-绿宝石">GBA系列（红宝石 蓝宝石 火红 叶绿 绿宝石）</h2>
<ul>
<li><p>卡壳颜色以及贴纸颜色/字体，可以参照一下下面的对比图，还是比较明显的.
<img data-src="/images/body/Pokemon-Cartridges-Authenticate/Figure1.webp"
alt="Figure1" /> <br><br></p></li>
<li><p>正版卡带贴纸右侧有钢印.
这个方法可以确定这个壳子是正版壳，不排除里面芯片被人为换成假卡芯片的情况，不过有些钢印比较难拍出也有点难看出来.
<img data-src="/images/body/Pokemon-Cartridges-Authenticate/Figure2.webp"
alt="Figure2" /> <br><br></p></li>
<li><p>正版卡带左上方侧面有方形，火叶壳子没那么透不是很清楚. <img
src="/images/body/Pokemon-Cartridges-Authenticate/Figure3.webp"
alt="Figure3" /> <img
src="/images/body/Pokemon-Cartridges-Authenticate/Figure4.webp"
alt="Figure4" /> <br><br></p></li>
<li><p>正版卡带芯片背面左上方有田字（火叶相较宝石偏下一些）.
假卡芯片背面很多圆点. 这个方法可以判别卡带芯片是否为正版. <img
src="/images/body/Pokemon-Cartridges-Authenticate/Figure5.webp"
alt="Figure5" /> <br><br></p></li>
<li><p>芯片下方有行白字（Nintendo那行）.
有的假卡会没有，版本批次不同后面的数字不一样，但是每个版本一般固定只有两种.
假卡印刷歪一点. 理论上，看背面就好了（大黄原话）. <img
src="/images/body/Pokemon-Cartridges-Authenticate/Figure6.webp"
alt="Figure6" /> <br><br></p></li>
<li><p>与第四世代的联动. 据说现在假卡已经能做到了，而且新出的gba烧录卡也能做到，所以这个方法失效.
不过不能联动的肯定不是正卡.</p></li>
</ul>
<p><br><br></p>
<h2
id="nds系列第一类珍珠-钻石-白金">NDS系列第一类（珍珠 钻石 白金）</h2>
<p>这一类卡带偏灰色，较难辨别.</p>
<ul>
<li>首先是正面贴纸的颜色、字体、粗细等等，参照对比图. <img
src="/images/body/Pokemon-Cartridges-Authenticate/Figure7.webp"
alt="Figure7" /></li>
</ul>
<p>上真下假. <br><br></p>
<ul>
<li>背面三行字的字体、粗细，其中第二行是反光材质的，有的角度拍不太清楚可以要求拍反光.</li>
<li>如果金手指（卡带背面下方金属部分）上方绿色部分的字不正便是假卡.
但不同角度照片也可能把正卡拍的比较歪，而且有的假卡做的已经很正了.
此外金手指上的字一般差不太多，不会像这个离谱到有Nintendo字样. <img
src="/images/body/Pokemon-Cartridges-Authenticate/Figure8.webp"
alt="Figure8" /></li>
</ul>
<p>第二点与第三点的图. <br><br></p>
<ul>
<li>与第五世代的联动.
这个同GBA系列第四点，有的假卡已经能做到了，所以失效. <br><br></li>
</ul>
<h2
id="nds系列第二类心金-魂银-黑-白-黑2-白2">NDS系列第二类（心金 魂银 黑 白 黑2 白2）</h2>
<p>这一类卡带呈深黑色，与灰色还是有区别的.</p>
<ul>
<li>正版卡带在强光下卡带透红. 这个基本已经可以区别正卡假卡了. <img
src="/images/body/Pokemon-Cartridges-Authenticate/Figure9.webp"
alt="Figure9" /></li>
</ul>
<p>都是正卡. <br><br></p>
<ul>
<li><p>正面贴纸的颜色、字体、粗细等等，同第一类. <br><br></p></li>
<li><p>背面字体、粗细，同第一类. <br><br></p></li>
<li><p>金手指的字正不正、对不对，同第一类. <br><br></p></li>
<li><p>心魂的与第五代联动，同第一类. <br><br></p></li>
<li><p>与宝可梦银行（Mover）（黑白与黑白2）或AR搜寻器的联动（黑白2）可以用于区分，暂时假卡好像还不能联动.
<br><br></p></li>
</ul>
<blockquote>
<p>大概的就是这些，比较难区分的就是NDS系列第一类（dppt）了.
需要多看看，积累经验才能准确辨别.</p>
</blockquote>
<h1 id="卡盒">卡盒</h1>
<h2 id="gba系列">GBA系列</h2>
<p>这个比较好认，色调啥的完全不对，一般一眼就能看出来.
假盒花里胡哨闪的过分. <br><br></p>
<h2 id="nds系列">NDS系列</h2>
<ul>
<li>全新的NDS美版卡带的塑封是没有中间一条Nintendo的，只有欧版全新才带那个塑封.
<img data-src="/images/body/Pokemon-Cartridges-Authenticate/Figure10.webp"
alt="Figure10" /></li>
</ul>
<p>假. <br><br></p>
<ul>
<li>美版看左下角 <strong>E</strong> 字及其附近的粗细与字体. <img
src="/images/body/Pokemon-Cartridges-Authenticate/Figure11.webp"
alt="Figure11" /></li>
</ul>
<p>上假下真 上面的E和下面的E在框框里的位置不太一样，粗细也不同.
<br><br></p>
<ul>
<li>蓝色 wifi 标上 Nintendo 的字体（假卡不全是第二种）. <img
src="/images/body/Pokemon-Cartridges-Authenticate/Figure12.webp"
alt="Figure12" /></li>
</ul>
<p>上正下假 <br><br></p>
<ul>
<li>美版是黑灰色的盒子，欧版是白透色的盒子.
白透色的盒子上有个美版分级E很明显是假盒. <img
src="/images/body/Pokemon-Cartridges-Authenticate/Figure13.webp"
alt="Figure13" /></li>
</ul>
<p>假 <br><br></p>
<ul>
<li>避免买只有三张说明书的（一张游戏说明书两张白色的纸片），很有可能是假盒
+ 假说明书.</li>
</ul>
<p>一般来说假卡配假盒，假卡壳配假芯片的多.
但现在还有不少奸商真盒塞假卡或是真卡配假盒，所以还是要擦亮眼睛.</p>
<p><br><br></p>
<hr />
<p><br><br></p>
<h1 id="美版的分类">美版的分类</h1>
<p>纯美版（北美版）、加美版、亚太美版见图 <img
src="/images/body/Pokemon-Cartridges-Authenticate/Figure14.webp"
alt="Figure14" /></p>
<p>依次为纯美、加美、亚太美.
说明书上纯美加美没啥区别（具体的不太清楚，应该一样的），亚太美只有几张薄薄的小白纸.</p>
<p><br><br></p>
<hr />
<p><br><br></p>
<h1 id="大黄的叮嘱">大黄的叮嘱：</h1>
<figure>
<img data-src="/images/body/Pokemon-Cartridges-Authenticate/BigYellow.webp"
alt="BigYellow" />
<figcaption aria-hidden="true">BigYellow</figcaption>
</figure>
]]></content>
      <categories>
        <category>Pokemon</category>
      </categories>
      <tags>
        <tag>Collection</tag>
        <tag>Pokemon</tag>
      </tags>
  </entry>
  <entry>
    <title>VS. Recorder</title>
    <url>/Pokemon/VS-Recorder/</url>
    <content><![CDATA[<p>此 Blog 用于记录一些宝可梦对战比赛，终有一日成为宝可梦大师！
平时比赛可能不是很勤，尽量8.</p>
<p>封面 [ID:79621961].</p>
<span id="more"></span>
<h1 id="年10月苏州月赛战报-冠军">2020年10月苏州月赛战报-冠军</h1>
<figure>
<img data-src="/images/body/VS-Recorder/SPL-2020-10-05.png"
alt="SPL-2020-10-05" />
<figcaption aria-hidden="true">SPL-2020-10-05</figcaption>
</figure>
<h2 id="date-2020-10-05">Date: 2020-10-05</h2>
<h2 id="rule-不限标-允许携带最多一个幻兽">Rule: 不限标
允许携带最多一个幻兽</h2>
<h2 id="record">Record:</h2>
<ul>
<li>第一轮瑞士轮 轮空</li>
<li>第二轮瑞士轮 vs red X 首发谜拟Q+霜奶仙 对面首发野菊+妙蛙
赌对面点谜拟Q开空间所以霜奶仙换后排魔女 谜拟Q影袭队友触发弱测
结果对面打霜奶仙位 开空间 跪了</li>
<li>第三轮瑞士轮 vs bd O bd开卡包开到高罕太激动了
嘎啦没点防壁被装饰jjh谜拟Q秒了
然后就被谜拟Q杀穿了（感觉点了防壁也赢不了？）</li>
</ul>
<p>2-1勉强进半决赛</p>
<ul>
<li>半决赛 vs red O 同样的首发 直接装饰jjh谜拟Q开干
霜奶仙退场后梦幻变身谜拟Q 两只谜拟Q杀穿了</li>
<li>决赛 vs 乌笔澄 bo3规则 OO
<ul>
<li>第一轮首发谜拟Q+风妖精 对面咆哮虎+智挥猩 谜拟Q剑舞
风妖精被击掌触发按钮白给换上霜奶仙 再次霜奶仙配合jjh谜拟Q贯穿</li>
<li>第二轮对面首发垃圾之翼+毒电开顺风 还是被谜拟Q+霜奶仙秒了毒电
最后残局对面健康西施 我方残血霜奶仙+风妖精 霜奶仙给风妖精装饰后被打死
风妖精掉包换来了西施的背心 然后月爆对攻西施结束 拿下冠军</li>
</ul></li>
</ul>
<h2 id="sentiment">Sentiment</h2>
<p>没想到大部分钢属性幻兽的情况下这队表现能这么好！点名表扬谜拟Q
霜奶仙和风妖精. 真爱队胜利还是很开心的，以后再接再厉. ## Team:
有些配置记不清了，大概如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mimikyu @ Babiri Berry  </span><br><span class="line">Ability: Disguise  </span><br><span class="line">Level: 50  </span><br><span class="line">EVs: 252 HP / 160 Atk / 94 Def / 4 SpD  </span><br><span class="line">Adamant Nature  </span><br><span class="line">- Play Rough  </span><br><span class="line">- Shadow Sneak  </span><br><span class="line">- Swords Dance  </span><br><span class="line">- Shadow Claw  </span><br><span class="line"></span><br><span class="line">Alcremie @ Safety Goggles  </span><br><span class="line">Ability: Aroma Veil  </span><br><span class="line">Level: 50  </span><br><span class="line">EVs: 252 HP / 74 Def / 4 SpA / 180 Spe  </span><br><span class="line">Timid Nature  </span><br><span class="line">- Decorate  </span><br><span class="line">- Dazzling Gleam  </span><br><span class="line">- Protect  </span><br><span class="line">- Helping Hand  </span><br><span class="line"></span><br><span class="line">Whimsicott @ Focus Sash  </span><br><span class="line">Ability: Prankster  </span><br><span class="line">Level: 50  </span><br><span class="line">EVs: 252 HP / 6 SpD / 252 Spe  </span><br><span class="line">Timid Nature  </span><br><span class="line">IVs: 0 Atk  </span><br><span class="line">- Tailwind  </span><br><span class="line">- Endeavor  </span><br><span class="line">- Memento  </span><br><span class="line">- Helping Hand  </span><br><span class="line"></span><br><span class="line">Rotom-Heat @ Wiki Berry  </span><br><span class="line">Ability: Levitate  </span><br><span class="line">Level: 50  </span><br><span class="line">EVs: 252 HP / 66 Def / 116 SpA / 76 Spe  </span><br><span class="line">Modest Nature  </span><br><span class="line">IVs: 0 Atk  </span><br><span class="line">- Thunderbolt  </span><br><span class="line">- Nasty Plot  </span><br><span class="line">- Protect  </span><br><span class="line">- Overheat  </span><br><span class="line"></span><br><span class="line">Hatterene-Gmax (F) @ Weakness Policy  </span><br><span class="line">Ability: Magic Bounce  </span><br><span class="line">Level: 50  </span><br><span class="line">EVs: 252 HP / 4 Def / 252 SpA  </span><br><span class="line">Quiet Nature  </span><br><span class="line">IVs: 0 Atk  </span><br><span class="line">- Psychic  </span><br><span class="line">- Dazzling Gleam  </span><br><span class="line">- Calm Mind  </span><br><span class="line">- Trick Room  </span><br><span class="line"></span><br><span class="line">Mew @ Aguav Berry  </span><br><span class="line">Ability: Synchronize  </span><br><span class="line">Level: 50  </span><br><span class="line">EVs: 252 HP / 252 Spe  </span><br><span class="line">Jolly Nature  </span><br><span class="line">IVs: 30 Atk  </span><br><span class="line">- Tailwind  </span><br><span class="line">- Transform  </span><br><span class="line">- Fake Out  </span><br><span class="line">- Helping Hand  </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<hr />
<p><br></p>
]]></content>
      <tags>
        <tag>Life</tag>
        <tag>Pokemon</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐的喷喷生活</title>
    <url>/Game/Share-Splatoon2-Happiness/</url>
    <content><![CDATA[<p>[\]:Share-Splatoon2-Happiness</p>
<p>以此Blog记录我爱的 <em>Splatoon</em> 和朋友们.</p>
<p>封面 [ID:82331425].</p>
<span id="more"></span>
<h1 id="thanks-to">Thanks TO</h1>
<h2 id="先感谢专业摄影师-口一宝">先感谢专业摄影师
<em>口一宝</em>——————</h2>
<p><img data-src="/images/body/Share-Splatoon2-Happiness/Photographer.png"
alt="Photographer" /> ## 感谢和我一起玩的朋友们： - 天才口一狗勾 -
蜜柑xbb - 童泡泡 - 梨梨猫猫 - 浴缸狂魔钢蛋 -
还有海产群的以及和我一起快乐喷喷的各位!</p>
<h1 id="gallery">Gallery</h1>
<p><img data-src="/images/body/Share-Splatoon2-Happiness/S(1).png" /> <img
src="/images/body/Share-Splatoon2-Happiness/S(2).png" /> <img
src="/images/body/Share-Splatoon2-Happiness/S(3).png" /> <img
src="/images/body/Share-Splatoon2-Happiness/S(4).png" /> <img
src="/images/body/Share-Splatoon2-Happiness/S(5).png" /> <img
src="/images/body/Share-Splatoon2-Happiness/S(6).png" /> <img
src="/images/body/Share-Splatoon2-Happiness/S(7).png" /> <img
src="/images/body/Share-Splatoon2-Happiness/S(8).png" /> <img
src="/images/body/Share-Splatoon2-Happiness/S(9).png" /></p>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>Life</tag>
        <tag>Splatoon</tag>
      </tags>
  </entry>
  <entry>
    <title>亲爱的宝可梦♡</title>
    <url>/Pokemon/See-My-Loving-Pokemons/</url>
    <content><![CDATA[<p>以此博客纪念我爱的宝可梦们~~ 封面 [ID:79498766].</p>
<span id="more"></span>
<h1 id="写在这里">写在这里：</h1>
<p>希望大家都能喜爱并珍惜与自己相遇的那些宝可梦！
享受宝可梦带来的快乐！</p>
<p><br><br></p>
<hr />
<hr />
<h1 id="チュチュ">チュチュ</h1>
<figure>
<img data-src="/images/body/See-My-Loving-Pokemons/kyukyu.png"
alt="チュチュ" />
<figcaption aria-hidden="true">チュチュ</figcaption>
</figure>
<h2 id="about">About</h2>
<p><img data-src="/images/body/See-My-Loving-Pokemons/kyukyu-Summary.png"
alt="Summary" /> - 种类：#778 <a
href="https://wiki.52poke.com/wiki/%E8%B0%9C%E6%8B%9F%EF%BC%B1">谜拟Q</a>
- 相遇时间：2021-01-03 - 相遇地点：阿罗拉地区乌拉乌拉岛超值超市旧址<img
src="/images/body/See-My-Loving-Pokemons/Thrifty-Megamart.png"
alt="Thrifty-Megamart" /> - 相遇版本：ポケットモンスター サン</p>
<p><img data-src="/images/body/See-My-Loving-Pokemons/kyukyu-Encounter1.png"
alt="Encounter1" /> <img
src="/images/body/See-My-Loving-Pokemons/kyukyu-Encounter2.png"
alt="Encounter2" /></p>
<p><br><br></p>
<hr />
<p><br><br></p>
<h1 id="volta">Volta</h1>
<figure>
<img data-src="/images/body/See-My-Loving-Pokemons/Volta.png" alt="Volta" />
<figcaption aria-hidden="true">Volta</figcaption>
</figure>
<h2 id="about-1">About</h2>
<p><img data-src="/images/body/See-My-Loving-Pokemons/Volta-Summary.png"
alt="Summary" /> - 种类：#478 <a
href="https://wiki.52poke.com/wiki/%E9%9B%AA%E5%A6%96%E5%A5%B3">雪妖女</a>
- 相遇时间：2021-04-19 - 相遇地点：丰缘地区浅滩洞穴冰之房间<img
src="/images/body/See-My-Loving-Pokemons/Hoenn_Shoal_Cave_Map.png"
alt="Thrifty-Megamart" /> - 相遇版本：Pokemon Ruby</p>
<figure>
<img data-src="/images/body/See-My-Loving-Pokemons/Volta-Encounter1.png"
alt="Encounter1" />
<figcaption aria-hidden="true">Encounter1</figcaption>
</figure>
<h2 id="plans">Plans</h2>
<ul>
<li>集齐3代奖章后传去4代进化.</li>
</ul>
<p><br><br></p>
<hr />
<p><br><br></p>
<h1 id="ivy">Ivy</h1>
<figure>
<img data-src="/images/body/See-My-Loving-Pokemons/Ivy.png" alt="Ivy" />
<figcaption aria-hidden="true">Ivy</figcaption>
</figure>
<h2 id="about-2">About</h2>
<p><img data-src="/images/body/See-My-Loving-Pokemons/Ivy-Summary.png"
alt="Summary" /> - 种类：#282 <a
href="https://wiki.52poke.com/wiki/%E6%B2%99%E5%A5%88%E6%9C%B5">沙奈朵</a>
- 相遇时间：2021-01-22 - 相遇地点：丰缘地区102号道路<img
src="/images/body/See-My-Loving-Pokemons/Route102.webp"
alt="Thrifty-Megamart" /> - 相遇版本：Pokemon Ruby</p>
<p><img data-src="/images/body/See-My-Loving-Pokemons/Ivy-Encounter1.png"
alt="Encounter1" /> ## Evolution <img
src="/images/body/See-My-Loving-Pokemons/Ivy-Evolution1.png"
alt="Evolution1" /> ## Plans - 集齐3代奖章.</p>
<p><br><br></p>
<hr />
<p><br><br></p>
<h1 id="jirachi">Jirachi</h1>
<figure>
<img data-src="/images/body/See-My-Loving-Pokemons/Jirachi.png"
alt="Jirachi" />
<figcaption aria-hidden="true">Jirachi</figcaption>
</figure>
<h2 id="about-3">About</h2>
<p><img data-src="/images/body/See-My-Loving-Pokemons/Jirachi-Summary.png"
alt="Summary" /> - 种类：#385 <a
href="https://wiki.52poke.com/wiki/%E5%9F%BA%E6%8B%89%E7%A5%88">基拉祈</a>
- 相遇时间：2021-02-18 - 相遇地点：<a
href="https://wiki.52poke.com/wiki/%E5%91%BD%E4%B8%AD%E6%B3%A8%E5%AE%9A%E8%88%AC%E7%9A%84%E7%9B%B8%E9%81%87">Fateful
Encounter</a>. - 相遇版本：Pokemon Ruby</p>
<figure>
<img data-src="/images/body/See-My-Loving-Pokemons/Jirachi-Encounter1.png"
alt="Encounter1" />
<figcaption aria-hidden="true">Encounter1</figcaption>
</figure>
<p><br><br></p>
<hr />
<p><br><br></p>
<h1 id="charizard">Charizard</h1>
<figure>
<img data-src="/images/body/See-My-Loving-Pokemons/Charizard.png"
alt="Charizard" />
<figcaption aria-hidden="true">Charizard</figcaption>
</figure>
<h2 id="about-4">About</h2>
<ul>
<li>种类：#006 <a
href="https://wiki.52poke.com/wiki/%E5%96%B7%E7%81%AB%E9%BE%99">喷火龙</a></li>
<li>相遇时间：2021-07-26</li>
<li>相遇地点：关都地区真新镇<img
src="/images/body/See-My-Loving-Pokemons/Pallet-Town.webp"
alt="Pallet Town" /></li>
<li>相遇版本：Pokemon Leaf Green</li>
</ul>
<p><img
src="/images/body/See-My-Loving-Pokemons/Charizard-Encounter1.png"
alt="Encounter1" /> ## Evolution <img
src="/images/body/See-My-Loving-Pokemons/Charizard-Evolution1.png"
alt="Evolution1" /> <img
src="/images/body/See-My-Loving-Pokemons/Charizard-Evolution2.png"
alt="Evolution2" /> ## Plans - 集齐3代奖章.</p>
<p><br><br></p>
<blockquote>
<p>Not The End. :D</p>
</blockquote>
<p><br><br></p>
<hr />
<p><br><br></p>
<h1 id="ditto">DITTO</h1>
<figure>
<img data-src="/images/body/See-My-Loving-Pokemons/DITTO.jpg" alt="DITTO" />
<figcaption aria-hidden="true">DITTO</figcaption>
</figure>
<h2 id="about-5">About</h2>
<p><img data-src="/images/body/See-My-Loving-Pokemons/DITTO-Summary.jpg"
alt="Summary" /> - 种类：#132 <a
href="https://wiki.52poke.com/wiki/%E7%99%BE%E5%8F%98%E6%80%AA">百变怪</a>
- 相遇时间：2022-05-07 - 相遇地点：关都地区红莲镇宝可梦屋<img
src="/images/body/See-My-Loving-Pokemons/Pokémon_Mansion.webp"
alt="Pokémon_Mansion" /> - 相遇版本：Pokemon Leaf Green</p>
<figure>
<img data-src="/images/body/See-My-Loving-Pokemons/DITTO-Encounter1.png"
alt="Encounter1" />
<figcaption aria-hidden="true">Encounter1</figcaption>
</figure>
<h2 id="plans-1">Plans</h2>
<ul>
<li>集齐全奖章.</li>
</ul>
<p><br><br></p>
<hr />
<hr />
<p><br><br></p>
<h1 id="more">More</h1>
<h2 id="第三世代">第三世代</h2>
<p><img data-src="/images/body/See-My-Loving-Pokemons/More/G3/G3(1).png" />
<img data-src="/images/body/See-My-Loving-Pokemons/More/G3/G3(2).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(3).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(4).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(5).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(6).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(7).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(8).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(9).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(10).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(11).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(12).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(13).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(14).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(15).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(16).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(17).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(18).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(19).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G3/G3(20).png" /></p>
<p><br><br></p>
<hr />
<p><br><br></p>
<h2 id="第四世代">第四世代</h2>
<p><img data-src="/images/body/See-My-Loving-Pokemons/More/G4/G4(1).png" />
<img data-src="/images/body/See-My-Loving-Pokemons/More/G4/G4(2).png" /></p>
<p><br><br></p>
<hr />
<p><br><br></p>
<h2 id="第五世代">第五世代</h2>
<p><img data-src="/images/body/See-My-Loving-Pokemons/More/G5/G5(1).png" />
<img data-src="/images/body/See-My-Loving-Pokemons/More/G5/G5(2).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G5/G5(3).png" /></p>
<p><br><br></p>
<hr />
<p><br><br></p>
<h2 id="第六世代">第六世代</h2>
<p><img data-src="/images/body/See-My-Loving-Pokemons/More/G6/G6(1).png" />
<img data-src="/images/body/See-My-Loving-Pokemons/More/G6/G6(2).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G6/G6(3).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G6/G6(4).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G6/G6(5).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G6/G6(6).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G6/G6(7).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G6/G6(8).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G6/G6(9).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G6/G6(10).png" /> <img
src="/images/body/See-My-Loving-Pokemons/More/G6/G6(11).png" /></p>
<p><br><br></p>
<hr />
<p><br><br></p>
<h2 id="第七世代">第七世代</h2>
<p>No Hurry.</p>
<p><br><br></p>
<hr />
<p><br><br></p>
<h2 id="第八世代">第八世代</h2>
<p>No Hurry.</p>
]]></content>
      <tags>
        <tag>Life</tag>
        <tag>Pokemon</tag>
      </tags>
  </entry>
  <entry>
    <title>如何备份你的存档</title>
    <url>/Pokemon/Strategies/In-Game/How-To-Back-Up-Your-Savefiles/</url>
    <content><![CDATA[<p>这篇文章是宝可梦正版正作卡带从 <em>Gen1</em> 到 <em>Gen7</em>
的存档提取与导入教程.
不局限于宝可梦正作，其他卡带也可以通过同样的方法提取.
如果你对备份存档感到介意，请根据自身情况取舍.</p>
<p>封面 [ID:86927624].</p>
<span id="more"></span>
<h1 id="写在前面">写在前面</h1>
<p>已经有人在贴吧写了详细的傻瓜教程，比我写的详细很多：<a
href="https://tieba.baidu.com/p/6349601583?share=9105&amp;fr=sharewise&amp;see_lz=0&amp;share_from=post&amp;sfc=copy&amp;client_type=2&amp;client_version=12.15.1.0&amp;st=1640142523&amp;unique=9EBFF40D479B24A05CA7FA461487C5A9&amp;qq-pf-to=pcqq.group&amp;red_tag=0588212229">【教程】全版本正版游戏卡带存档导出导入教程</a>
这篇注重于收录常规方法而非详细教程（都有写的那么详细的了）.</p>
<p>除了下面提到的方法，更多方法请参考<a
href="https://projectpokemon.org/home/forums/topic/15107-nds-how-to-backuprestore-your-retail-cartridge-save-file-for-ds-games/">NDS:
How to Backup/Restore your retail cartridge save file for DS
games</a>.</p>
<h1 id="gb-与-gbc-卡带"><em>GB</em> 与 <em>GBC</em> 卡带</h1>
<p>包含的宝可梦卡带有：</p>
<ul>
<li>宝可梦 红 / 绿 / 蓝 / 黄</li>
<li>宝可梦 金 / 银 / 水晶</li>
</ul>
<p>这类应该只能通过特殊设备提取与导入，如 <em>Flash Boy</em> 、 <em>GB
Operator</em> 等.</p>
<h2 id="flash-boy"><em>Flash Boy</em></h2>
<p><img data-src="/images/body/How-To-Back-Up-Your-Savefiles/Flash-Boy1.png"
alt="Flash Boy" /> <img
src="/images/body/How-To-Back-Up-Your-Savefiles/Flash-Boy2.png"
alt="Flash Boy" /> 在各电商应该都有购买方式.</p>
<h2 id="gb-operator"><em>GB Operator</em></h2>
<p><a
href="https://www.epilogue.co/product/gb-operator">官网地址</a></p>
<figure>
<img data-src="/images/body/How-To-Back-Up-Your-Savefiles/GB-Operator.gif"
alt="GB Operator" />
<figcaption aria-hidden="true">GB Operator</figcaption>
</figure>
<blockquote>
<p>注意，这类卡带的存档依赖电池，如果电池没电了会导致存档丢失.</p>
</blockquote>
<h1 id="gba-卡带"><em>GBA</em> 卡带</h1>
<p>包含的宝可梦卡带有：</p>
<ul>
<li>宝可梦 红宝石 / 蓝宝石 / 绿宝石</li>
<li>宝可梦 火红 / 叶绿</li>
</ul>
<p>这类存档提取与导入可以通过：</p>
<ol type="1">
<li>使用特殊设备提取，如上述 <em>Flash Boy</em> 、 <em>GB
Operator</em>.</li>
<li>使用 <em>初版 NDS</em> 或 <em>NDS lite</em> 配合 NDS
烧录卡与存档提取软件 <strong><em>GBA Backup Tool</em></strong>.</li>
</ol>
<ul>
<li><a
href="https://www.gamebrew.org/wiki/GBA_Backup_Tool">使用方法</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aWViYS5iYWlkdS5jb20vcC80MTkxNDAwNzQ1">使用方法 -
中文<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="/download/GBA-Backup-Tool.nds">下载</a></li>
<li><a href="/Game/DSTWO/">DSTWO相关资源整理</a></li>
</ul>
<figure>
<img
src="/images/body/How-To-Back-Up-Your-Savefiles/GBA-Backup-Tool.png"
alt="GBA Backup Tool" />
<figcaption aria-hidden="true">GBA Backup Tool</figcaption>
</figure>
<h1 id="nds-与-3ds-卡带-以及-3ds-vc-系列"><em>NDS</em> 与 <em>3DS</em>
卡带 以及 <em>3DS</em> <strong>VC</strong> 系列</h1>
<p>包含的宝可梦卡带有：</p>
<ul>
<li>宝可梦 珍珠 / 钻石 / 白金</li>
<li>宝可梦 心金 / 魂银</li>
<li>宝可梦 黑 / 白</li>
<li>宝可梦 黑2 / 白2</li>
<li>宝可梦 X / Y</li>
<li>宝可梦 欧米伽红宝石／阿尔法蓝宝石</li>
<li>宝可梦 日 / 月</li>
<li>宝可梦 究极之日 / 究极之月</li>
<li>宝可梦 VC 系列</li>
</ul>
<p>这类存档提取与导入需要使用破解 <em>3DS</em> ，想要破解 <em>3DS</em>
请参见：<span class="exturl" data-url="aHR0cHM6Ly9zdHJheS1zb3VsLmNvbS8=">一只火狐的杂物间<i class="fa fa-external-link-alt"></i></span>.
请具备一定的破解 3DS 软件安装能力.</p>
<ul>
<li>使用 <em>3DS</em> 存档提取软件 <strong><em>CheckPoint</em></strong>
（推荐）或者 <strong><em>TWLSaveTool</em></strong> .
<ul>
<li><a
href="https://projectpokemon.org/home/tutorials/save-editing/managing-3ds-saves/using-checkpoint-r25/">CheckPoint使用方法</a></li>
<li><a
href="https://projectpokemon.org/home/tutorials/save-editing/managing-nds-saves/using-twl-save-tool-r59/">TWLSaveTool使用方法</a></li>
<li><a
href="https://github.com/FlagBrew/Checkpoint/releases">CheckPoint下载</a></li>
<li><a
href="https://github.com/TuxSH/TWLSaveTool/releases">TWLSaveTool下载</a></li>
</ul></li>
</ul>
<p>Checkpoint界面： <img
src="/images/body/How-To-Back-Up-Your-Savefiles/CheckPoint.png"
alt="CheckPoint" /> TWLSaveTool界面： <img
src="/images/body/How-To-Back-Up-Your-Savefiles/TWLSaveTool.png"
alt="TWLSaveTool" /></p>
<h1 id="已失效的与未经测试的-3ds-卡带存档提取外设">已失效的与未经测试的
<em>3DS</em> 卡带存档提取外设</h1>
<h2 id="cyber-save-editor"><strong>Cyber Save Editor</strong></h2>
<p><img
src="/images/body/How-To-Back-Up-Your-Savefiles/Cyber-Save-Editor01.png"
alt="Cyber Save Editor" /> &gt; 网站已经停止服务了，应该仅支持日版.</p>
<figure>
<img
src="/images/body/How-To-Back-Up-Your-Savefiles/Cyber-Save-Editor02.jpg"
alt="Cyber Save Editor" />
<figcaption aria-hidden="true">Cyber Save Editor</figcaption>
</figure>
<h2 id="cyber-save-editor-2"><strong>Cyber Save Editor 2</strong></h2>
<p>普通版 <img
src="/images/body/How-To-Back-Up-Your-Savefiles/Cyber-Save-Editor03.png"
alt="Cyber Save Editor 2" /> <img
src="/images/body/How-To-Back-Up-Your-Savefiles/Cyber-Save-Editor04.png"
alt="Cyber Save Editor 2" /> <br></p>
<p>典藏版 <img
src="/images/body/How-To-Back-Up-Your-Savefiles/Cyber-Save-Editor05.webp"
alt="Cyber Save Editor 2" /> &gt;
<strong>仅支持日版</strong>，是否停止服务未知，如果你知道，请<a
href="/about/">与我联系</a>. - <a
href="https://www.tldevtech.com/best-3ds-save-editor-cyber-save-editor/">Cyber
Save Editor 2使用方法</a></p>
<h1 id="写在最后">写在最后</h1>
<p>不建议滥用存档导入导出，还请保持对游戏、对宝可梦的热爱进行使用！
如果你知道更多的方法，还请<a href="/about/">不吝赐教</a>！</p>
]]></content>
      <categories>
        <category>Pokemon</category>
      </categories>
      <tags>
        <tag>Pokemon</tag>
      </tags>
  </entry>
  <entry>
    <title>宝可梦绿宝石及没有电的红蓝宝石实机乱数（不包含 ID 或 Egg）</title>
    <url>/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part1/</url>
    <content><![CDATA[<p>这是宝可梦绿宝石及没电红蓝宝石的实机乱数教程. 不包含 ID 与 Egg
的乱数教程. 如有纰漏，请<a href="/about/">与我联系</a>，万分感谢！</p>
<p>封面 [ID:57789285]. <span id="more"></span></p>
<p><strong>注意，本教程仅支持：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Support</th>
<th style="text-align: center;">红蓝宝石</th>
<th style="text-align: center;">绿宝石</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">电池有电</td>
<td style="text-align: center;">✘</td>
<td style="text-align: center;">✔</td>
</tr>
<tr class="even">
<td style="text-align: center;">电池没电</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
</tr>
</tbody>
</table>
<p>如果你在找有电的红蓝宝石实机乱数教程，请点击<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part2/">这里</a>.</p>
<p>如果你在找火红叶绿的实机乱数，请点击<a
href="/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part3/">这里</a>.</p>
<blockquote>
<p>实机很难实现，难度很高.</p>
</blockquote>
<h1 id="准备工作">准备工作</h1>
<p>如果你想要乱数闪光宝可梦，你需要知道你的<a
href="https://wiki.52poke.com/wiki/ID_No.#.E9.87.8CID_No.">SID</a>.</p>
<blockquote>
<p>如果你想要乱数的是已经创建好的存档，这可能会需要你导出存档并使用
<em>PKHex</em>
等软件查看你的存档（不涉及修改与导入），请根据自身接受程度使用.</p>
</blockquote>
<blockquote>
<p>由于我没有怎么研究过乱数ID，所以如果你想要乱数ID，请参考：<a
href="https://www.smogon.com/ingame/rng/rs_nonbredrng#idsid">Smogon ID
乱数教程</a>.<br> 之后如果自己研究了一遍就会上传Blog.</p>
</blockquote>
<blockquote>
<p>不会导出存档？看看这篇博客：<a
href="/Pokemon/Strategies/In-Game/How-To-Back-Up-Your-Savefiles/">如何备份你的存档</a>.</p>
</blockquote>
<h2 id="硬件准备">硬件准备</h2>
<ul>
<li>能够游玩第三世代宝可梦卡带的机器（<em>GBA</em>系列、初代<em>NDS</em>
或 <em>NDS lite</em>，不推荐使用 <em>NGC</em>）.</li>
<li>电脑.</li>
<li>（若使用初代<em>NDS</em> 或 <em>NDS
lite</em>可选）<em>NDS</em>烧录卡与读卡器.</li>
</ul>
<blockquote>
<p>使用
<em>NDS</em>烧录卡提取存档进行查看可以大幅节省部分步骤的时间，强烈推荐.请根据自身接受程度使用.<br>
如果不准备使用烧录卡，请准备足够的神奇糖果.</p>
</blockquote>
<h2 id="下载乱数所需工具">下载乱数所需工具：</h2>
<ul>
<li>计时器<a href="/download/CCTimer.rar">CCTimer</a>
因为没有找到该软件的发布页，所以上传至仓库可直接点击下载，如果你知道它的发布页，请与我联系.</li>
<li>乱数工具<a
href="https://www.dropbox.com/sh/68qqg26op3uaymc/AAC8QFFKYxAqQjG80abgcHZ1a?dl=0">3genSearch</a>
国内需要科学上网，因原作者禁止二次发布所以这里不提供直接下载，可以通过各搜索引擎找到别人的分享.</li>
<li>乱数工具<a
href="https://github.com/Admiral-Fish/RNGReporter/releases">RNGReporter</a>
如果因为国内 GitHub 下载速度原因不好下载，可以点击<a
href="/download/RNGReporter.zip">这里</a>进行下载.</li>
</ul>
<blockquote>
<p>两个乱数工具选择任意一个都可以，本教程使用的是 <em>3genSearch</em>.
RNGReporter的使用与之类似，还请读者自行探索.</p>
</blockquote>
<h2 id="了解乱数机制">了解乱数机制</h2>
<p>我会尽量讲的简洁易懂一些，了解乱数机制可以为你理解每一步所做的原因，同时掌握各种乱数方法也会更迅速牢固.</p>
<h3 id="随机数">随机数</h3>
<blockquote>
<p>真正意义上的随机数（或者随机事件）在某次产生过程中是按照实验过程中表现的分布概率随机产生的，其结果是不可预测的，是不可见的。而计算机中的随机函数是按照一定算法模拟产生的，其结果是确定的，是可见的。我们可以这样认为这个可预见的结果其出现的概率是100%。所以用计算机随机函数所产生的“随机数”并不随机，是伪随机数。</p>
</blockquote>
<h3 id="游戏机制与乱数目标">游戏机制与乱数目标</h3>
<p>由于宝可梦绿宝石与没有电的红蓝宝石（以下简称
<strong><em>E</em></strong> 与 <strong><em>RS</em></strong>
）的初始seed相同（<strong><em>E</em></strong> :
<code>0x 0</code>，<strong><em>RS</em></strong> :
<code>0x 5A0</code>），而当进入游戏后，会以每秒约60帧的速度过帧（根据运行机器不同会有极小差别）.当游戏判断需要生成一只宝可梦的时候便会使用当前帧的数据来生成，我称之为
<em>生成帧</em> . <em>3genSearch</em> 与 <em>RNGReporter</em>
都可以用来获取一个seed下产生的帧的信息.
我们的目标就是在某一seed下准确击中想要的帧数，即控制
<em>生成帧</em>.</p>
<h2 id="确定乱数目标">确定乱数目标</h2>
<p><strong><em>如果选择了野外相遇的宝可梦，请在队伍中准备一只习得了<a
href="https://wiki.52poke.com/wiki/%E7%94%9C%E7%94%9C%E9%A6%99%E6%B0%94%EF%BC%88%E6%8B%9B%E5%BC%8F%EF%BC%89#.E5.8F.AF.E4.BB.A5.E5.AD.A6.E4.BC.9A.E8.AF.A5.E6.8B.9B.E5.BC.8F.E7.9A.84.E5.AE.9D.E5.8F.AF.E6.A2.A6">甜甜香气</a>的宝可梦.</em></strong>
确定乱数目标后，选择相应的 <em>Method</em>. 如果是乱数蛋，请参阅<a
href="https://www.smogon.com/ingame/rng/emerald_rng_part4">这里</a>.</p>
<h3 id="method-1"><em>Method 1</em></h3>
<ul>
<li>御三家（<strong><em>RS</em></strong>、<strong><em>E</em></strong>
一周目与 <strong><em>E</em></strong> 二周目）</li>
<li>定点宝可梦</li>
<li>釜炎镇 NPC 赠送的小果然的蛋</li>
<li><strong><em>RS</em></strong> 通过甜甜香气遭遇的宝可梦</li>
<li><strong><em>RS</em></strong> 通过钓鱼遭遇的宝可梦（除丑丑鱼）</li>
<li><strong><em>RS</em></strong> 通过碎岩遭遇的宝可梦</li>
</ul>
<h3 id="method-2"><em>Method 2</em></h3>
<ul>
<li>草丛/海草/深沙/洞穴/水上/可以遇到宝可梦的建筑中通过移动/转向
遭遇的宝可梦（除了游走宝可梦）</li>
<li><strong><em>E</em></strong> 通过甜甜香气遭遇的宝可梦</li>
<li><strong><em>E</em></strong> 钓鱼钓上来的宝可梦</li>
<li><strong><em>E</em></strong> 通过碎岩遇到的宝可梦</li>
</ul>
<h3 id="method-4"><em>Method 4</em></h3>
<ul>
<li>钓鱼钓上来的丑丑鱼</li>
</ul>
如果是 <em>Method
1</em>中的前三类，点击下面的谜拟Q来查看保存游戏的位置与生成帧的所在时机（
<strong><em>E</em></strong> 与 <strong><em>RS</em></strong>
有些会有区别）：
<details>
<summary>
<img no-lazy data-src="/images/mimikyu.png" alt="Method 2 请点击丘丘" align=left>
</summary>
<br> -- 御三家：在博士的包前保存，在问你“Do you choose this
POKéMON?”时等待生成帧 <br> -- 飘浮泡泡：在反派干部前保存，在研究员说“It
might be an odd way of thanking you, but take this POKéMON.”时等待生成帧
<br> --
游走水都：击败冠军后在出自己的房间门前存档，在让你选择红蓝时等待生成帧
<br> -- 复活化石：在研究员前保存，在他说“The fossil was an ancient
POKéMON. [LILEEP/ANORITH], it was!”时等待生成帧 <br> -- 小果然的蛋：在
NPC 前存档，在她说“Good! I hope you'll walk plenty with this here
EGG!”时等待生成帧 <br> -- 变隐龙：在隐形的变隐龙前存档，在提示“The
startled POKéMON attacked!”时等待生成帧 <br> --
大吾的铁哑铃：在精灵球前存档，在选择是否拿走时等待生成帧 <br> --
胡说树：在其面前存档，在提示“The weird tree attacked!”时等待生成帧 <br>
--
盖欧卡与固拉多：在距离剧情触发前一步存档，在进入战斗前最后一段时等待生成帧
<br> -- 凤王：Save on the first space of the peak of the cliff. Last
input is pressing up on the directional pad to place yourself on the
second space of the cliff. <br> -- 梦幻：Save in the area it appears in.
Last input is a press of the A button to "tag" it. <br> --
其他：在宝可梦/触发物前保存，在进入战斗前最后一段时等待生成帧 <br> <br>
凤王和梦幻的不知道怎么表达比较好，看英文感受一下.
</details>
<p><br><br></p>
<p>如果是 <em>Method 2</em> 或 <em>Method 1</em>
的后三类，在进入战斗前最后一次点击作为生成帧. &gt;
实际生成帧可能会更往后，如甜甜香气，但这段时间是固定的，可以通过多次尝试来更新.</p>
<h1 id="开始乱数">开始乱数</h1>
<h2 id="搜索目标宝可梦">搜索目标宝可梦</h2>
<p>打开乱数工具，选择/填入图中红框中内容： <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part1/Figure1.png"
alt="Figure1" /></p>
<ol type="1">
<li>根据乱数目标选择<em>固定</em>或<em>野生</em>.</li>
<li>如果选择了<em>野生</em>，可以修改绿框中的地点、版本信息.</li>
<li>输入初期 seed，<strong><em>E</em></strong> 为
0，<strong><em>RS</em></strong> 为 5A0.</li>
<li>F为搜索帧数的范围，建议800~100000，因为 seed
固定了所以可能很靠后才有你想要的帧.（1秒约60帧，请自行推测是否有耐心）（请根据实际情况调整，如甜甜香气动画较长，所以起始帧会高一些）.</li>
<li><em>Method</em> 选择之前确定的 <em>Method</em>.</li>
<li>检索区域根据自己的需要填写，若勾选
<strong><em>只显示异色</em></strong> ，需要在勾选框上方填入表里ID.</li>
<li>点击黑框<em>计算</em>，得到结果.</li>
</ol>
<blockquote>
<p>没有想要的宝可梦怎么办？<br>
不建议帧数再加了，10w帧约27.8分钟了，可以试着降低一下要求.<br></p>
</blockquote>
<blockquote>
<p>闪帧太靠后了怎么办？<br> 换个存档叭. 太非了这个档.</p>
</blockquote>
<p>在结果中选择一个满意的结果作为目标帧，将其
<strong><em>F</em></strong>
栏（即为你的<em>目标帧</em>）填入蓝框中（蓝框后面的内容不需要管）.</p>
<h2 id="校准误差">校准误差</h2>
<p><strong><em>如果你的目标宝可梦不是野外宝可梦（如定点宝可梦）且准备使用烧录卡协助乱数，那么要在步骤1结束后，使用GBA_Backup软件将存档提取出来</em></strong>
&gt; GBA_Backup软件可在<a
href="/How-To-Back-Up-Your-Savefiles/">这里</a>找到.</p>
<ol type="1">
<li><p>在游戏中你应该存档的位置存档（如果你准备在洞穴或是能出现宝可梦的建筑中使用甜甜香气，请往深处走一些距离，否则甜甜香气可能会失效），存档完成后关机.</p></li>
<li><p>打开计时器 <em>CCTimer</em>，选择
<em>Setting</em>，点击红框内容，根据游戏平台选择对应选项. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part1/Figure2.png"
alt="Figure2" /></p></li>
<li><p>回到 <em>Timer</em>，在蓝框内填入你刚刚的 <em>目标帧</em> 并点击
<strong><em>Add</em></strong> . <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part1/Figure3.png"
alt="Figure3" /></p></li>
<li><p>点击 <strong><em>Start</em></strong>
按钮的同时开始游戏(gba系列和设置过的nds是直接开机，未设置过的nds系列是在主页面点击GBA游戏图标).</p></li>
<li><p>在游戏中快速到达目标帧的确定位置（如：在选择宝可梦使用甜甜香气的界面）.</p></li>
<li><p>在 <em>CCTimer</em> 上的倒计时归零的瞬间按下机器的
<strong><em>A</em></strong> 键，然后等待进入战斗界面.</p></li>
<li><p>捕捉这只宝可梦.</p></li>
<li><ul>
<li>如果你不准备使用烧录卡：将宝可梦的性格、等级、能力值等输入个体值计算软件得到其个体，如果无法得到唯一的个体，使用足够多的神奇糖果后重试.
这之后，关闭游戏.
<strong><em>如果你的目标宝可梦不是野外宝可梦（如定点宝可梦），记住不要保存</em></strong></li>
<li>如果你准备使用烧录卡：保存并关闭游戏，使用GBA_Backup软件提取出存档，使用读卡器连接到电脑后使用
<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t3c2NoL1BLSGVYL3JlbGVhc2Vz">PKHex<i class="fa fa-external-link-alt"></i></span>
软件打开存档，查看刚捕捉的宝可梦的数据.</li>
</ul></li>
<li><p>回到乱数工具，在黄框中填入刚捕捉到的宝可梦数据（如果不是闪光记得不要勾选
<strong><em>只显示异色</em></strong> ），点击 <em>计算</em>.
记下橙色框中的数字（如有多个，选择离<em>目标帧</em>最近的）. <img
src="/images/body/Pokemon-RNG-Abuse-Gen3-Part1/Figure4.png"
alt="Figure4" /></p></li>
<li><p>回到
<em>CCTimer</em>，计算<em>目标帧</em>减去刚刚橙色框中的数字的值，点击
<strong><em>Clear</em></strong> 按钮清除后输入该值并点击
<strong><em>Add</em></strong> .</p>
<blockquote>
<p>例如 CCTimer 中的值（目标帧）是2156，击中帧是2177，2156 - 2177 =
-21（橙色框中数字为 21），那么将 CCTimer 中的值更新为 2156 - 21 =
2135.</p>
</blockquote></li>
</ol>
<p>误差校准完成.</p>
<blockquote>
<p>注意，如果你更换了目标，即宝可梦获得方式改变（如Method不同 或
由游戏厅切换为固拉多），请重新进行误差校准！</p>
</blockquote>
<h2 id="乱数">乱数</h2>
<p><strong><em>如果你的目标宝可梦不是野外宝可梦（如定点宝可梦）且使用烧录卡协助乱数，那么先使用GBA_Backup软件将备份存档导入</em></strong>
和校准误差的4、5、6步一致： 1. 点击 <strong><em>Start</em></strong>
按钮的同时开始游戏. 2. 在游戏中快速到达目标帧的确定位置. 3. 在
<em>CCTimer</em> 上的倒计时归零的瞬间按下机器的
<strong><em>A</em></strong> 键，然后等待进入战斗界面. 4.
如果得到的不是<em>目标帧</em>，可以选择再次进行误差校准或者再多尝试几次.</p>
<blockquote>
<p>因为手工操作多少会有些误差，建议多尝试几次，若十几二十次失败再考虑重新校准误差.</p>
</blockquote>
<ol start="5" type="1">
<li>乱数成功，得到目标！</li>
</ol>
<h1 id="reference">Reference</h1>
<ul>
<li><a
href="https://taiyaki3gen.hatenablog.com/entry/2020/05/30/162400">3genSearch
作者博客</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc21vZ29uLmNvbS9pbmdhbWUvcm5nLw==">Smogon RNG
教程<i class="fa fa-external-link-alt"></i></span></li>
<li><a
href="https://www.bilibili.com/video/BV14Z4y1M7rM?share_source=copy_web">呆呆兽都能学会的【三代定点宝可梦乱数教程】
-- 百分之零点六 哔哩哔哩</a></li>
</ul>
<h1 id="appreciation">Appreciation</h1>
<ul>
<li>感谢<strong>Rai</strong>为我纠正了一些错误.</li>
</ul>
]]></content>
      <categories>
        <category>Pokemon</category>
      </categories>
      <tags>
        <tag>Pokemon</tag>
        <tag>Pokemon-RNG-Abuse</tag>
        <tag>Pokemon-Gen3</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo与GitHub制作私人博客</title>
    <url>/Learning/Blog/Build-Your-Own-Blog-Like-This-One/</url>
    <content><![CDATA[<p>想要搭建自己的博客？跟着这篇文章做下去，谜拟Q都能搭出私人博客！</p>
<p>以此文章记录丘丘Blog的制作过程.</p>
<p>封面 [ID:91018415]. <span id="more"></span></p>
<h1 id="前言">前言</h1>
<p><strong>注意，这篇仅针对Windows用户，如果你的系统是Mac或者Linux，请参考<a
href="https://hexo.io/zh-cn/docs/">官方文档</a>.</strong></p>
<p>说实话我做Blog就是为了记录分享，最重要的是很有意思，捣鼓捣鼓出来很有成就感.
不过我觉得这篇知乎专栏写的很不错，有兴趣的可以看看.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xOTc0Mzg2MQ==">为什么你要写博客？ -
陈素封的文章 - 知乎<i class="fa fa-external-link-alt"></i></span></p>
<p>接下来我将记录一下这个博客的搭建与完善过程.</p>
<p>谜拟Q都能看懂的博客搭建教程 开工！</p>
<h1 id="搭建">搭建</h1>
<p>这部分主要实现博客的从无到有，是做成自己独一无二博客的基础.</p>
<h2 id="github">GitHub</h2>
<h3 id="注册-github-账号">注册 GitHub 账号</h3>
<p>这个很简单，<a
href="https://github.com/signup?ref_cta=Sign+up&amp;ref_loc=header+logged+out&amp;ref_page=%2F&amp;source=header-home">点击这里</a>来创建
GitHub 账号.</p>
<h3
id="在个人主界面里选择创建一个新的-repository">在个人主界面里选择创建一个新的
<em>Repository</em></h3>
<p><em>Repository name</em> 处填写 <code>username.github.io</code>. 其中
<em>username</em> 是你的 GitHub 用户名. <strong>请勾选 <em>Add a README
file</em> 选项.</strong> <img
src="/images/body/Build-Your-Own-Blog-Like-This-One/Figure1.png"
alt="Figure1" /> &gt; 图中因为我已经创建过了，所以会报错.</p>
<p>创建后默认自动启用 HTTPS，博客地址为：https://username.github.io.
其中 <em>username</em> 是你的 GitHub 账号名.
（不过可能进去没啥东西）</p>
<h2 id="环境搭建">环境搭建</h2>
<p>Hexo 基于 Node.js，搭建过程中还需要使用 <code>npm</code>（Node.js
已带） 和 <code>git</code>，因此先搭建本地操作环境，安装 Node.js 和
Git.</p>
<blockquote>
<p>这里我全部按默认配置完成安装</p>
</blockquote>
<h3 id="安装-node.js">安装 Node.js</h3>
<p>访问 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">Node.js
官方网站<i class="fa fa-external-link-alt"></i></span>下载并安装Node.js . 这里我选择的是LTS版本（16.13.1），当前
<span class="exturl" data-url="dHRwczovL2hleG8uaW8vemgtY24vZG9jcy8=">Hexo 官方文档<i class="fa fa-external-link-alt"></i></span>建议 Node.js
版本高于12.0.0，可随时确认.</p>
<blockquote>
<p>此外，使用 Node.js 官方安装程序时，请确保勾选 <em>Add to PATH</em>
选项（默认已勾选）</p>
<p>安装完成后，组合键<kbd>Win</kbd>+<kbd>R</kbd> 输入 <code>cmd</code>
并打开，依次输入
<code>node -v</code>、<code>npm -v</code>并回车，如下图出现程序版本号即安装成功.</p>
</blockquote>
<figure>
<img data-src="/images/body/Build-Your-Own-Blog-Like-This-One/Figure2.png"
alt="Figure2" />
<figcaption aria-hidden="true">Figure2</figcaption>
</figure>
<h3 id="安装-git">安装 Git</h3>
<p>访问 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb3dubG9hZC93aW4=">Git
官方下载地址<i class="fa fa-external-link-alt"></i></span>下载并安装 Git.</p>
<blockquote>
<p>安装完成后，组合键 <kbd>Win</kbd>+<kbd>R</kbd> 输入 <code>cmd</code>
并打开，输入
<code>git --version</code>、并回车，如下图出现程序版本号即安装成功.</p>
</blockquote>
<figure>
<img data-src="/images/body/Build-Your-Own-Blog-Like-This-One/Figure3.png"
alt="Figure3" />
<figcaption aria-hidden="true">Figure3</figcaption>
</figure>
<h2 id="连接-github">连接 GitHub</h2>
<p>打开 <em>Git Bash</em> ，输入以下代码设置用户名和邮箱： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub 用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub 邮箱&quot;</span><br></pre></td></tr></table></figure>
&gt; 用自己的 GitHub 用户名与邮箱替代代码中的相应部分.</p>
<h3 id="创建-ssh-密钥">创建 SSH 密钥</h3>
<p>继续输入代码<code>ssh-keygen -t rsa -C "GitHub 邮箱"</code>
然后一路回车.</p>
<h3 id="添加密匙">添加密匙</h3>
<p>进入 &lt;C:\.ssh&gt;
目录（可能需要勾选显示“隐藏的项目”，如果没有，请查看输出信息中的默认生成位置），用记事本打开公钥
<em>id_rsa.pub</em> 文件并复制里面的内容.</p>
<p>登陆 GitHub ，进入个人 <em>Settings</em> 页面，选择左边栏的 <em>SSH
and GPG keys</em> ，点击 <em>New SSH key</em>.</p>
<p>Title 随便填写一个名字，将 <em>id_rsa.pub</em> 内容复制粘贴到 Key
中，点击 <em>Add SSH key</em> 完成添加. <img
src="/images/body/Build-Your-Own-Blog-Like-This-One/Figure4.png"
alt="Figure4" /></p>
<h3 id="验证连接">验证连接</h3>
<p>打开 <em>Git Bash</em>，输入 <code>ssh -T git@github.com</code> 出现
<strong><em>“Are you sure……”</em></strong> 字样时，输入 <em>yes</em>
并回车确认.</p>
<p>显示 <strong><em>“Hi xxx! You've successfully……”</em></strong>
即连接成功.</p>
<h2 id="安装-hexo">安装 Hexo</h2>
<p>在喜欢的位置创建一个空文件夹，打开 <em>Git Bash</em> 利用
<code>cd</code> 命令移动至此文件夹.</p>
<blockquote>
<p>之后若无特殊说明则将此文件夹称为根目录</p>
</blockquote>
<p>输入 <code>npm install -g hexo-cli</code> 回车进行安装.</p>
<p>安装完成后输入以下代码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init   #初始化 hexo</span><br><span class="line">hexo g  # 生成页面</span><br><span class="line">hexo s  # 启用预览，默认端口4000</span><br></pre></td></tr></table></figure> 访问<a
href="http://localhost:4000" class="uri">http://localhost:4000</a>，出现
Hexo 默认页面，则本地博客安装成功.</p>
<blockquote>
<p>使用组合键 <kbd>Ctrl</kbd>+<kbd>C</kbd> 来关闭本地预览服务.</p>
<p>若组合键 <kbd>Ctrl</kbd>+<kbd>C</kbd> 没有效果，可打开 <em>cmd</em>
运行 <code>taskkill /f /t /im node.exe</code> 来关闭服务.</p>
<p>如果出现页面加载不出来，可能是端口被占用了. 组合键
<kbd>Ctrl</kbd>+<kbd>C</kbd> 关闭服务器，运行
<code>hexo server -p 5000</code> 更改端口号为5000后重试.</p>
</blockquote>
<p>Hexo 博客文件夹目录结构如下：(图源水印) <img
src="/images/body/Build-Your-Own-Blog-Like-This-One/Figure5.jpg"
alt="Figure5" /></p>
<h2 id="部署-hexo-到-github-pages">部署 Hexo 到 GitHub Pages</h2>
<p>在 <em>Git Bash</em> 中运行
<code>npm install hexo-deployer-git --save</code>.</p>
<p>打开根目录，找到文件 *_config.yml* 并打开，修改文件末尾的 Deployment
部分为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure> &gt; 用自己的 GitHub 用户名替换代码相应部分</p>
<p>接着，在 <em>Git Bash</em> 中运行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d  # 部署博客</span><br></pre></td></tr></table></figure></p>
<p>这时访问自己的 GitHub 域名 <span class="exturl" data-url="aHR0cHM6Ly91c2VybmFtZS5naXRodWIuaW8=">https://username.github.io<i class="fa fa-external-link-alt"></i></span> 就可以看到 Hexo 网站了.</p>
<p><br><br><br>到这里私人博客的搭建就差不多了，接下来便是去安装 hexo
的<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=">主题<i class="fa fa-external-link-alt"></i></span>与<a
href="https://hexo.io/plugins/">插件</a>了.</p>
<h1 id="完善">完善</h1>
<p>这部分将你的博客个性化，来创造自己独一无二的博客吧！</p>
<h2 id="选择并安装主题">选择并安装主题</h2>
<p>在 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=">Themes | Hexo<i class="fa fa-external-link-alt"></i></span>
选择一个喜欢的主题，按照官方文档进行安装即可. 这里我选择的是 <a
href="https://zhwangart.com/2018/11/30/Ocean/">Ocean 主题</a>.</p>
<p>因为官方文档的步骤都十分详细，因此这里不展开细说.
一般主题所需的插件也会在官方文档中提供安装与使用方法.</p>
<h2 id="完成">完成</h2>
<p>跟着官方文档做下去，再按照自己的需求更改，个性化的博客便做好了.
可以参考这篇文章<a
href="/Learning/Blog/Blog-Personalization/">博客个性化笔记----基于Ocean</a>.</p>
<h1 id="reference">Reference</h1>
<p><a
href="https://www.zhihu.com/question/20962496/answer/677815713">如何在
GitHub 上写博客？ - 少数派的回答 - 知乎</a></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MDU3ODQ2NA==">使用 Hexo+GitHub
搭建个人免费博客教程（小白向） - crystal的文章 - 知乎<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv">Hexo 官方中文文档<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHdhbmdhcnQuY29tLzIwMTgvMTEvMzAvT2NlYW4v">Ocean
官方文档<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Practical-Tips</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Ocean</tag>
      </tags>
  </entry>
  <entry>
    <title>解决访问GithHub速度慢的问题</title>
    <url>/Learning/Solutions/Accessing-GitHub-Slowly-Solution/</url>
    <content><![CDATA[<p>今天早上上 GitHub 又没上上去，去网上找了一下原因是 GitHub 的 CDN
域名遭到了 DNS 污染，导致无法连接使用 GitHub
的加速分发服务器，才使得国内访问速度很慢.</p>
<p>可以通过修改本地 <code>hosts</code> 文件来绕过 DNS 解析来加速.</p>
<p>封面 [ID:46018784].</p>
<span id="more"></span>
<h1 id="solution">Solution</h1>
<ul>
<li><p>首先打开<a
href="http://tool.chinaz.com/dns/">站长工具</a></p></li>
<li><p>填入 &lt;Github.com&gt; <img
src="/images/body/Accessing-GitHub-Slowly-Solution/Figure1.png"
title="在 请输入域名 栏填写" alt="Figure1" /></p></li>
<li><p>将检测列表里的 TTL 值最小的 IP 记为 <em>a.b.c.d</em>.</p></li>
<li><p>使用记事本打开 <code>hosts</code> 文件，位于 &lt;C:&gt;.</p></li>
<li><p>将以下内容加在 <code>host</code> 文件末尾： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.b.c.d www.github.com</span><br><span class="line">a.b.c.d github.global.ssl.fastly.net</span><br><span class="line">a.b.c.d nodeload.github.com</span><br></pre></td></tr></table></figure> &gt;
其中 <em>a.b.c.d</em> 是上述步骤中记录的 IP 地址. &gt;
如果没有修改权限可以将 <code>host</code>
文件移出该文件夹，修改完成后再移回去. &gt; 系统会确认你授权管理员权限.
<img data-src="/images/body/Accessing-GitHub-Slowly-Solution/Figure2.png"
title="系统向确认你授权管理员权限" alt="Figure2" /></p></li>
<li><p><em>cmd</em> 输入命令 <code>ipconfig /flushdns</code>
刷新DNS缓存.</p></li>
<li><p>Done！试试访问GitHub吧！</p></li>
</ul>
<h1 id="reference">Reference</h1>
<p><a
href="https://blog.csdn.net/CS13477062349/article/details/88020283?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&amp;spm=1001.2101.3001.4242.1">完美解决打开github速度慢的问题</a></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Practical-Tips</tag>
        <tag>GitHub</tag>
        <tag>Solutions</tag>
      </tags>
  </entry>
</search>
